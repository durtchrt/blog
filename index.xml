<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>개발 저장소</title>
    <link>http://durtchrt.github.io/blog/index.xml</link>
    <description>Recent content on 개발 저장소</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>durtchrt</copyright>
    <lastBuildDate>Fri, 25 Nov 2016 14:08:04 +0900</lastBuildDate>
    <atom:link href="http://durtchrt.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title> 20161125 나는 프로그래머다 컨퍼런스</title>
      <link>http://durtchrt.github.io/blog/conference/20161125/1/</link>
      <pubDate>Fri, 25 Nov 2016 14:08:04 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/conference/20161125/1/</guid>
      <description>

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;발표 후기 1&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;functional-programming-그게-뭐죠&#34;&gt;Functional Programming 그게 뭐죠?&lt;/h1&gt;

&lt;h4 id=&#34;함수&#34;&gt;함수&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;절차지향

&lt;ul&gt;
&lt;li&gt;subroutin&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;functional

&lt;ul&gt;
&lt;li&gt;수학에서 말하는 함수&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;why-functional-programming&#34;&gt;Why? Functional Programming&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;동시성
무어의 법칙이 깨진후
CPU제조업체가 멀티 코어 성능 향상을 꾀함.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;간결
expression의 조합
고민해야할 문제가 하나로 줄어듬.
oop의 단일책임원칙이 자연스럽게 적용됨.
동일 입력값이 동일 출력값으로&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;테스트
값을 직접입력하지 않아도 테스트 프레임워크가 자동으로 생성도 가능&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;재미!!!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;맛보기&#34;&gt;맛보기&lt;/h4&gt;

&lt;p&gt;과거 함수형 프로그래밍 언어는 느려서 못썼는데
요새는 속도가 빠름.&lt;/p&gt;

&lt;p&gt;haskel 샘플&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskel&#34;&gt;let add :: Int -&amp;gt; Int -&amp;gt; Int
add a b = a + b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(파라메터)  (리턴타입)
Int -&amp;gt;Int -&amp;gt; Int&lt;/p&gt;

&lt;p&gt;함수형언어들은 함수 우선권을 가짐
add 2 5 * 3
=&amp;gt; 21&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;1.toString()
==&amp;gt; error
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;1.toString
==&amp;gt; &amp;quot;1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자바에서의 1은 primitive type
scala에서의 1은 object   =&amp;gt; PURE object oriented programming language&lt;/p&gt;

&lt;p&gt;Full-blown
Functional Language
=&amp;gt; 순수 함수형 언어가 아닌 함수형 프로그래밍하기에 적합한 언어를 지칭
=&amp;gt; 스칼라가 이 범위에 있음.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;호주 이민은 스칼라&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;kevin github -&amp;gt; functional transaction without aop&lt;/p&gt;

&lt;h2 id=&#34;br-br-br-br-br-br-br&#34;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;발표 후기 2&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;machine-intelligence-at-google-service&#34;&gt;Machine Intelligence at Google Service&lt;/h1&gt;

&lt;p&gt;What we&amp;rsquo;ll cover
what is neural network and deep learning
machine learning use cases at google services
externalizing the power of ML
tensorFlow: the open source library for ML
tensorFlow in the wild
??&lt;/p&gt;

&lt;h4 id=&#34;what-is-neural-network-and-deep-learning&#34;&gt;What is Neural Network and Deep Learning&lt;/h4&gt;

&lt;p&gt;Neural network is a functio that can learn
-&amp;gt; 고양이의 이미지를 분석해서 레이블을 만듬.
-&amp;gt; 이러한 기술을 게임서버에서 로그를 분석해서 악성행위 분석 가능&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../1.png&#34; alt=&#34;spiral&#34; /&gt;&lt;/p&gt;

&lt;p&gt;나선 이미지를 보면 오렌지, 블루 색상을 사람은 쉽게 알 수 있음&lt;/p&gt;

&lt;p&gt;하지만 컴퓨터는&amp;hellip;
점마다 위치정보를 if-else하는 프로그래밍은 괴로움.
-&amp;gt; 이러한 문제를 해결하기 위해 ML사용&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://playground.tensorflow.org/#activation=tanh&amp;amp;batchSize=10&amp;amp;dataset=spiral&amp;amp;regDataset=reg-plane&amp;amp;learningRate=0.03&amp;amp;regularizationRate=0&amp;amp;noise=0&amp;amp;networkShape=4,2&amp;amp;seed=0.82086&amp;amp;showTestData=false&amp;amp;discretize=false&amp;amp;percTrainData=50&amp;amp;x=true&amp;amp;y=true&amp;amp;xTimesY=false&amp;amp;xSquared=false&amp;amp;ySquared=false&amp;amp;cosX=false&amp;amp;sinX=false&amp;amp;cosY=false&amp;amp;sinY=false&amp;amp;collectStats=false&amp;amp;problem=classification&amp;amp;initZero=false&amp;amp;hideText=false&#34;&gt;Neural network traning play ground&lt;/a&gt; - site sample&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;site에서 패턴인식하는게 실시간으로 나와서 파란색과 오렌지색을 인식하는것을 볼 수 있음&lt;/li&gt;
&lt;li&gt;더 많은 데이터와 더 많은 샘플을 주면 더 빠르고 더 정확하게 데이터를 학습함.&lt;/li&gt;
&lt;li&gt;한레이어에서 나오는 아웃풋을 그 다음 레이어의 인풋으로 제공해서 더 스마트헤거 됨.&lt;/li&gt;
&lt;li&gt;각각의 레이어는 단순하지만 이 것들이 통합하면서 스마트한 뉴런네트워크가 됨.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 사람이 이미지를 어떻게 인식하라고 알려주지 않아도 알아서 하는 것이 중요&lt;br&gt;
=&amp;gt; AI, AlphaGo가 이세돌을 이길수 있었던것.
=&amp;gt; 컴퓨터가 스스로 방법을 찾아내기 때문에 사람보다 뛰어난 방법을 찾아낼 수 있는 것.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.petdrugsonline.co.uk/images/page-headers/cats-master-header&#34; alt=&#34;cat&#34; /&gt;&lt;/p&gt;

&lt;p&gt;고양이 인식&lt;br&gt;
=&amp;gt; 고양이를 인식하기 위해 50개 이상의 레이어가 생성되고, 각각의 레이어(뉴런)은 단순 하지만 모이면 스마트해지면서 컴퓨터가 이미지상에서 고양이를 판별할 수 있게됨.&lt;/p&gt;

&lt;h4 id=&#34;machine-learning-use-cases-at-google-services&#34;&gt;machine learning use cases at google services&lt;/h4&gt;

&lt;p&gt;구글 검색을 통해 이를 사용하고 있음
최근에 구글은 랭크브레인이라는 서비스를 내놓음
Image를 컨텐츠에 따라 구분하는 google photo
gmail - smart reply in box mobile - 이메일을 자동으로 전송.
google translate with neural machine translation
data center - energy save
More&amp;hellip;. 60개 이상의 프로덕트에 사용&lt;/p&gt;

&lt;h4 id=&#34;externalizing-the-power-of-ml&#34;&gt;externalizing the power of ML&lt;/h4&gt;

&lt;p&gt;ML api는 머신러닝과 상관없는 개발자가 사용하도록 제공하려함.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CoudVision API
이미 트레이닝된 모델을 제공하기 때문에 이미지가 인풋되면 바로 결과가 나옴.
8만개 이상의 이미지를 이용해서 서비스를 사용.
사진을 주면 다양한 레이블 정보를 줌 (0_0 데모 우와~~)&lt;/li&gt;
&lt;li&gt;WebSpeech Api
google.com/speech&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;tensorflow-the-open-source-library-for-ml&#34;&gt;tensorFlow: the open source library for ML&lt;/h4&gt;

&lt;p&gt;자신의 뉴럴네트워크를 구축하고 싶을때 사용하는 오픈소스
Portable and Scalable&lt;/p&gt;

&lt;h4 id=&#34;tensorflow-in-the-wild&#34;&gt;tensorFlow in the wild&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;일본의 예를 보여줌.
어머니는 오이를 하루 8시간씩 골라내는 일을 함.
스스로 텐서플로우로 오이 분류기를 만듬.
embedded software 개발자로 머신러닝을 모르는 사람이지만 함!!!
현재 70%의 정확성으로 오이를 9개의 등급으로 나눌수 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;치킨너겟을 서빙하는 로봇 팔.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;드론으로 트럭의 갯수를 세는 것.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;distributed-training-and-prediction-in-computing-power&#34;&gt;Distributed training and prediction in Computing power(?)&lt;/h4&gt;

&lt;p&gt;컴퓨터 파워가 엄청 필요함.
GPU가 있어도 몇주가 걸리기도 함.&lt;/p&gt;

&lt;p&gt;구글 클라우드가 수십만개의 GPU 클러스터를 가짐.&lt;/p&gt;

&lt;p&gt;jupitor network
tensor processiong unit&lt;/p&gt;

&lt;p&gt;=&amp;gt; 40배 ~ 300배 성능 향상 가능&lt;/p&gt;

&lt;h2 id=&#34;br-br-br-br-br-br-br-1&#34;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;발표 후기 3&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;스칼라로-웹사이트-개발하기&#34;&gt;스칼라로 웹사이트 개발하기&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;라스칼라코딩단, 최정열 &amp;amp; 케빈리&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 라이브 코딩(작성 못함. T-T)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;나프다 동영상 참조. 시연신이 나오셔서 방해를 엄청하심;;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;br-br-br-br-br-br-br-2&#34;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;발표 후기 4&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;ms는-rx를-왜-만들었을까-feat-rxjs&#34;&gt;MS는 Rx를 왜 만들었을까?  feat. RxJS&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;네이버, 김훈민&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://huns.me/development/2051&#34;&gt;발표자가 발표 주제로 포스팅한 글&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;rx는-어디에서-왔을까&#34;&gt;Rx는 어디에서 왔을까?&lt;/h4&gt;

&lt;p&gt;volta project에서 시작
-&amp;gt; live labs 다양한 기술을 하나의 플랫폼에서 실행 GWT과 비슷하지만 많은 플랫폼과 대응하는게 목적.
-&amp;gt; volta 프로젝트는 좌초됨.&lt;/p&gt;

&lt;p&gt;volta =&amp;gt; Reactive Framework를 가져와서 =&amp;gt; .Net의 Reactive Extenstion&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2009.11.17
Rx.NET 릴리즈&lt;/li&gt;
&lt;li&gt;2010.03.17
RxJS&lt;/li&gt;
&lt;li&gt;2012.11.06
오픈소스 공개
Rx.NET, RxJS, Rx++&lt;/li&gt;
&lt;li&gt;2013.02.05
RxJava by Netflix&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://www.reactivemanifesto.org&#34;&gt;리액트 선언 - Reative Manifesto&lt;/a&gt;
&lt;img src=&#34;http://www.reactivemanifesto.org/images/reactive-traits.svg&#34; alt=&#34;설명&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-rx를-지탱하는-키워드&#34;&gt;2 Rx를 지탱하는 키워드&lt;/h4&gt;

&lt;p&gt;Reactive Programming
데이터 플로우와 상태 변경을 전파한다는 생각에 근간을 둔 프로그래밍 패러다임.&lt;/p&gt;

&lt;p&gt;1985 - on the development of reactive systems
=&amp;gt; 논문에 reactive란 용어 시초라고 봄.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;반응
자극은 밖에서 안으로 흐름
자극이 있어야만 반응하는 수동성&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://huns.me/wp/wp-content/uploads/2016/09/reactive-eric.png&#34; alt=&#34;참조이미지&#34; /&gt;&lt;/p&gt;

&lt;p&gt;iterator pattern - pull
observalbe pattern - push&lt;/p&gt;

&lt;p&gt;iterator - observable 쌍대 관계에 있다.
-&amp;gt; slide의 설명문을 보면  @_@
=&amp;gt; A와 B의 본질이 같다.&lt;/p&gt;

&lt;p&gt;메서드표 자료 참조&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;LINQ to Events
이벤트와  LINQ의 개념을 결합한 오퍼레이터(Operator) 제공
Language Intergrated Query
에릭마이어가 만든 통합 질의 언어 C# 3.0부터 등장 데이터 질의 문법 설탕
두가지 스타일을 지원&lt;/li&gt;
&lt;li&gt;Query syntax&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Method syntax&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Scheduler
비동기 환경에서 오퍼레이터 실행 시점 제어&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;rp와-frp의-경계에서&#34;&gt;RP와 FRP의 경계에서&lt;/h4&gt;

&lt;p&gt;RP != FRP&lt;/p&gt;

&lt;p&gt;FRAN(Functional Reactive Animaton)1997 - 표현과 모델링의 분리 -&amp;gt;  시간에 따라 변하는 값을 표현(Behavior)
-&amp;gt; 함수형 리액티브 프로그래밍의 시작&lt;/p&gt;

&lt;p&gt;Evan Czaplicki - Elm만든 사람.
Controlling Time and Space -&amp;gt; FRP 다양한 변종들 설명.&lt;/p&gt;

&lt;p&gt;FRP 번위를 간단히 좁히면 (FRAN 논문 저자 왈)
1. denotational : 연속하는 시간에 따라 변하는 값이 1급 시민으로 표현되어야함.
2. countinuous-time&lt;/p&gt;

&lt;p&gt;개념적인 FRAN, 실질적인 Rx불연속값 처리 스트림 결합시 일괁성 없는 동시 이벤트 처리 발생
단점 -&amp;gt; 구성성 결여&lt;/p&gt;

&lt;p&gt;rx는 순간 불일치(glitch) 생김 =&amp;gt; 진정한 FRP 구현체라고 보기 힘들어함.&lt;/p&gt;

&lt;p&gt;제대로된 reactive를 보고 싶으면 &amp;lsquo;reactive-banana&amp;rsquo; 라이브러리 참조.
=&amp;gt; FRP 설명을 하스켈로 설명.&lt;/p&gt;

&lt;h4 id=&#34;웹프론트엔드-그리고-rxjs&#34;&gt;웹프론트엔드, 그리고  RxJS&lt;/h4&gt;

&lt;p&gt;뷰와 상태의 동기화 문제를 프레임워크마다 푸는 방식
backborn - KVO(key-value observing) =&amp;gt; 데이터 변경 체크 까지만 프레임워크 뷰의 상태 변화는 개발자가(MVC)
angular - 양방향 databinding =&amp;gt; 속도 문제 발생
reactjs - virtual dom - 상대가 변경되면 뷰가 바낌.
flux - react는 view만 담당. 순수 함수 조합 단방향 데이터 플로우
MVI(Model-view-intent) 순환 스트림 설계 함수형 프로그래밍.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reactive&lt;/li&gt;
&lt;li&gt;Functinal&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;rx는-fe-개발자에게-좋은-자극제&#34;&gt;Rx는 FE 개발자에게 좋은 자극제&lt;/h4&gt;

&lt;p&gt;Elm에서 영감을 얻은 Redux, Cycle.js
다른 진영 또는 클래식한 기술에서 새로운 통찰을 경험.&lt;/p&gt;

&lt;h2 id=&#34;br-br-br-br-br-br-br-3&#34;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;발표 후기 5&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;스타트업-1인-개발-극복기-와-javascript-vs-scala-함수형-언어-관점으로-방황기&#34;&gt;&amp;lsquo;스타트업 1인 개발 극복기&amp;rsquo;와 &amp;lsquo;javascript vs Scala, (함수형 언어 관점으로)방황기&amp;rsquo;&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;I/O Inc, 박미정&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;왜-함수형-언어&#34;&gt;왜 함수형 언어?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;개인

&lt;ul&gt;
&lt;li&gt;성장욕구&lt;/li&gt;
&lt;li&gt;높은 추상화&lt;/li&gt;
&lt;li&gt;코드 신뢰성&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;회사

&lt;ul&gt;
&lt;li&gt;시간적 여유&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;lsquo;코드 신뢰성&amp;rsquo; -&amp;gt; 적은 코드가 적은 버그를 만들어낸다.&lt;/p&gt;

&lt;h4 id=&#34;어떻게-팀에-도입을&#34;&gt;어떻게 팀에 도입을?&lt;/h4&gt;

&lt;p&gt;매주 sw 세미나 -&amp;gt; (관심끌기 성공) -&amp;gt; 함수형 패러다임 도적 -&amp;gt; 프로덕션 적용 시작&lt;/p&gt;

&lt;p&gt;&amp;lsquo;관심끌기 사례&amp;rsquo;
 - &amp;gt; 같은 입력 같은 출력 (사이드이펙트가 없으니) TDD시에 상당히 자연스럽게 연결.&lt;/p&gt;

&lt;h4 id=&#34;어떻게-팀에-도입을-1&#34;&gt;어떻게 팀에 도입을?&lt;/h4&gt;

&lt;p&gt;함수형 언어에 등장하는 &amp;lsquo;특성들&amp;rsquo;을 &amp;lsquo;기존 제품의 서버에 적용&amp;rsquo; 해보고 함수형 패러다임의 &amp;lsquo;매력&amp;rsquo;을 멤버들과 동기화&lt;/p&gt;

&lt;h4 id=&#34;왜-scala&#34;&gt;왜 Scala&lt;/h4&gt;

&lt;p&gt;함수형 프로그래밍 언어 -&amp;gt; side effect 없는 프로그래밍을 지원하고 장려하는 언어&lt;/p&gt;

&lt;p&gt;scala oop+fP 다리역할
  -&amp;gt; 멤버들이 oop에 익숙한 상태에서 fp를 자연스럽게 넘어갈때 !!&lt;/p&gt;

&lt;p&gt;#(2번째 주제) 스타트업 1인 개발 극복기
&lt;a href=&#34;http://www.slideshare.net/ParkMijeong/ss-65069602&#34;&gt;슬라이드참조&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[발번역]The Java™ Tutorials - 2-2. Pausing Execution with Sleep</title>
      <link>http://durtchrt.github.io/blog/java/concurrency/5/</link>
      <pubDate>Thu, 24 Nov 2016 15:00:35 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/concurrency/5/</guid>
      <description>

&lt;h2 id=&#34;원문링크-http-docs-oracle-com-javase-tutorial-essential-concurrency-sleep-html&#34;&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/concurrency/sleep.html&#34;&gt;원문링크&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;sleep으로-실행-중지하기&#34;&gt;Sleep으로 실행 중지하기&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Pausing Execution with Sleep&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Thread.sleep은 현재 실행하는 쓰레드를 정해진 시간만큼 실행을 중지한다. 컴퓨터에서 동작하는 어플리케이션의 프로세서의 시간을 효율적으로 만든다. sleep 메서드는 아래 예제처럼 다른 스레드들간에 동일한 간격(4초)으로 실행하게 하는데 사용하거나 다음 섹션에 SimpleThreads처럼 다른 스레드를 기다리게할 수 있다.
&lt;code&gt;Thread.sleep causes the current thread to suspend execution for a specified period. This is an efficient means of making processor time available to the other threads of an application or other applications that might be running on a computer system. The sleep method can also be used for pacing, as shown in the example that follows, and waiting for another thread with duties that are understood to have time requirements, as with the SimpleThreads example in a later section.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;두가지 오버로드 버전 sleep 제공: 하나는 sleep 시간을 밀리초(ms)로, 다른 하나는 나노초(ns)로 명시햇다. 하지만 sleep되는 시간은 완벽하게는 보장되지 않는다. 왜냐하면 OS단에서 제공하는 기능 제약 때문이다. 또한 sleep 시간은 나중에 나올 섹션에 볼 수 있듯이 인터럽트에 의해 종료될수 있습니다.  어쨌든, sleep을 호출해서 설정한 시간을 완벽히 스레드가 정지한다고 확신 할 수 없다.
&lt;code&gt;Two overloaded versions of sleep are provided: one that specifies the sleep time to the millisecond and one that specifies the sleep time to the nanosecond. However, these sleep times are not guaranteed to be precise, because they are limited by the facilities provided by the underlying OS. Also, the sleep period can be terminated by interrupts, as we&#39;ll see in a later section. In any case, you cannot assume that invoking sleep will suspend the thread for precisely the time period specified.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;SleepMessage 예제는 4초 간격으로 메세지를 프린트하려 sleep 메서드를 사용한다.
&lt;code&gt;The SleepMessages example uses sleep to print messages at four-second intervals:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SleepMessages {
    public static void main(String args[])
        throws InterruptedException {
        String importantInfo[] = {
            &amp;quot;Mares eat oats&amp;quot;,
            &amp;quot;Does eat oats&amp;quot;,
            &amp;quot;Little lambs eat ivy&amp;quot;,
            &amp;quot;A kid will eat ivy too&amp;quot;
        };

        for (int i = 0;
             i &amp;lt; importantInfo.length;
             i++) {
            //Pause for 4 seconds
            Thread.sleep(4000);
            //Print a message
            System.out.println(importantInfo[i]);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;main 메서드는  InterruptedException을 throws 한다. 현재 실행되는 쓰레드가 sleep하는 동안 다른 쓰레드가 인터럽트를하면 sleep 메서드가 throws하는 예외입니다. 이 어플리케이션은 다른 쓰레드를 인터럽트하지 않기 때문에  InterruptedException이 발생하지 않습니다.
&lt;code&gt;Notice that main declares that it throws InterruptedException. This is an exception that sleep throws when another thread interrupts the current thread while sleep is active. Since this application has not defined another thread to cause the interrupt, it doesn&#39;t bother to catch InterruptedException.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[발번역]The Java™ Tutorials - 2-1. 쓰레드 정의와 시작 Defining and Starting a Thread</title>
      <link>http://durtchrt.github.io/blog/java/concurrency/4/</link>
      <pubDate>Thu, 24 Nov 2016 14:00:35 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/concurrency/4/</guid>
      <description>

&lt;h2 id=&#34;원문링크-http-docs-oracle-com-javase-tutorial-essential-concurrency-runthread-html&#34;&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html&#34;&gt;원문링크&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;쓰레드-정의와-시작&#34;&gt;쓰레드 정의와 시작&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Defining and Starting a Thread&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;쓰레드의 인스턴스를 생성하는 응용프로그램은 반드시 쓰레드에 run 메서드 코드를 제공해야합니다. 이는 두가지 방법이 있습니다.
&lt;code&gt;An application that creates an instance of Thread must provide the code that will run in that thread. There are two ways to do this:&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Runnable 객체 제공&lt;/code&gt; Runnable 인터페이스는 쓰레드에서 실행하는 코드를 포함하는 단일 메서드 run을 정의합니다. 이 Runnable 객체는 쓰레드 생성자에 인자로 전달됩니다. HelloRunnable 예제 참조
&lt;code&gt;Provide a Runnable object. The Runnable interface defines a single method, run, meant to contain the code executed in the thread. The Runnable object is passed to the Thread constructor, as in the HelloRunnable example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloRunnable implements Runnable {

public void run() {
    System.out.println(&amp;quot;Hello from a thread!&amp;quot;);
}

public static void main(String args[]) {
    (new Thread(new HelloRunnable())).start();
}

}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;서브클래스 쓰레드&lt;/code&gt; 쓰레드 클래스는 스스로 Runnable 인터페이스를 구현함에도 불구하고 run 메서드는 (main 메서드안에) 없습니다 어플리케이션은 HelloThread 예제처럼 자신의 run 메서드 구현체를 제공하여 Thread의 서브클래스화 할 수 있습니다.(Thread의 서브 클래스이므로 Thread로 동작 가능해짐.)
&lt;code&gt;Subclass Thread. The Thread class itself implements Runnable, though its run method does nothing. An application can subclass Thread, providing its own implementation of run, as in the HelloThread example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloThread extends Thread {

public void run() {
    System.out.println(&amp;quot;Hello from a thread!&amp;quot;);
}

public static void main(String args[]) {
    (new HelloThread()).start();
}

}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두 예제는 새 스레드를 시작하기위해 Thread.start를 호출한다.
&lt;code&gt;Notice that both examples invoke Thread.start in order to start the new thread.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;두 용례중 어느것을 사용하겠습니까? 첫번째 용례 Runnable 객체를 사용하는 것이 더 일반적이다 왜냐하면 Runnable 객체는 Thread가아닌 다른 클래스를 서브클래스화 할 수 있습니다. 두번째 용례는 간단한 응용프로그램에서 사용하기 쉽지만 태스크 클래스가 Thread의 하위 클래스여하는 제한이 있습니다. 이 수업에서는 실행하는 태스크인 Thread 객체로부터 Runnable 태스크를 분리하는 것에 초점을 두고있습니다. 이 방법은 더 유연하고 나중에 다를 고수준 쓰레드 관리 API에 적용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Which of these idioms should you use? The first idiom, which employs a Runnable object, is more general, because the Runnable object can subclass a class other than Thread. The second idiom is easier to use in simple applications, but is limited by the fact that your task class must be a descendant of Thread. This lesson focuses on the first approach, which separates the Runnable task from the Thread object that executes the task. Not only is this approach more flexible, but it is applicable to the high-level thread management APIs covered later.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;쓰레드 클래스는 쓰레드 관리를 위해 쓸만한 메서드들을 정의했다. 이는 쓰레드에대한 정보나 쓰레드의 상태에 영향에 대한 정적 메서들를 제공한다.(???? - the thread invoking the method.) 다른 메서드들은 다른 쓰레드로부터 호출됩니다.(쓰레드와 쓰레드 객체를 관리하는데 관련된) 우리는 이러한 메서드들을 다음 세션에서 검토할 것이다.
&lt;code&gt;The Thread class defines a number of methods useful for thread management. These include static methods, which provide information about, or affect the status of, the thread invoking the method. The other methods are invoked from other threads involved in managing the thread and Thread object. We&#39;ll examine some of these methods in the following sections.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[발번역]The Java™ Tutorials - 2. Thread Objects</title>
      <link>http://durtchrt.github.io/blog/java/concurrency/3/</link>
      <pubDate>Thu, 24 Nov 2016 13:00:35 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/concurrency/3/</guid>
      <description>

&lt;h2 id=&#34;원문링크-http-docs-oracle-com-javase-tutorial-essential-concurrency-threads-html&#34;&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/concurrency/threads.html&#34;&gt;원문링크&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;쓰레드-객체&#34;&gt;쓰레드 객체&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Thread Objects&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;쓰레드마다 클래스 쓰레드의 인스턴스와 연관되어있다. 병행 어플리케이션을 만드는 쓰레드 객체를 사용하기 위해서는 두가지 전략이 있다.
&lt;code&gt;Each thread is associated with an instance of the class Thread. There are two basic strategies for using Thread objects to create a concurrent application.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;직접적으로 쓰레드 생성과 관리를하려면, 어플리케이션이 비동기 태스크를 시작려는 필요할때마다 쓰레드를 인스턴스화합니다. 나머지 어플리케이션으로부터 추상 스레드를 관려하려면, 어플리케이션의 태스크를 executor에 전달하시요. 이 섹션에서는 쓰레드 객체의 사용법을 설명합니다.  Excutor는 고수준 병행 객체와 함께 논의합니다.
&lt;code&gt;To directly control thread creation and management, simply instantiate Thread each time the application needs to initiate an asynchronous task. 
To abstract thread management from the rest of your application, pass the application&#39;s tasks to an executor.
This section documents the use of Thread objects. Executors are discussed with other high-level concurrency objects.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[발번역]The Java™ Tutorials - 1. Processes and Threads </title>
      <link>http://durtchrt.github.io/blog/java/concurrency/2/</link>
      <pubDate>Thu, 24 Nov 2016 12:00:35 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/concurrency/2/</guid>
      <description>

&lt;p&gt;##&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html&#34;&gt;원문링크&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;프로세스와-쓰레드&#34;&gt;프로세스와 쓰레드&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Processes and Threads&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;병행 프로그래밍에서는 실행의 두개의 기본 개념이 있다(프로세스, 쓰레드). 자바 프로그래밍 언어에서는 병행 프로그래밍은 거의 대부분 쓰레드와 관련있다. 하지만 프로세스 역시 중요하다.
&lt;code&gt;In concurrent programming, there are two basic units of execution: processes and threads. In the Java programming language, concurrent programming is mostly concerned with threads. However, processes are also important.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;컴퓨터 시스템은 일반적으로 많은 활동적인 프로세스와 쓰레드를 가지고 있다. 싱글 코에서는 하나만 동작할 수 있으므로 한순간에는 한 스레드만 동작할 수 있다. (;;;;) 싱글코어는 타임슬라이싱이라고 불리는 OS 기능을 통해 프로세스와 스레드들간에 공유한다.(Processing time for ???)
&lt;code&gt;A computer system normally has many active processes and threads. This is true even in systems that only have a single execution core, and thus only have one thread actually executing at any given moment. Processing time for a single core is shared among processes and threads through an OS feature called time slicing.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;컴퓨터 시스템은 멀티 프로세서 또는  멀티 코어를 가지는건 점점 더 흔해지고 있다. 이건 시스템의  프로세스와 스레드의 병행 실행 능력을 훌륭하게 높여주였다. 하지만 병행성은 멀티프로세서 또는 멀티코어가 아니더라도 싱글코어 시스템에서도 가능하다.
&lt;code&gt;It&#39;s becoming more and more common for computer systems to have multiple processors or processors with multiple execution cores. This greatly enhances a system&#39;s capacity for concurrent execution of processes and threads — but concurrency is possible even on simple systems, without multiple processors or execution cores.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;프로세스&#34;&gt;프로세스&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Processes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;프로세스는 독립 실행환경을 가졌습니다. 프로세스는 일반적으로 완벽하고, 외부에 노출안되는  런타임 자원의 집합을 제공합니다.(말이 어렵네;;); 개별적으로 각각의 프로세스들은 자신만의 메모리 공간을 가집니다.
&lt;code&gt;A process has a self-contained execution environment. A process generally has a complete, private set of basic run-time resources; in particular, each process has its own memory space.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;프로세스는 프로그램 또는 어플리케이션과 유의어로 종종 인지한다. 하지만 사용자가 단일 어플리케이션처럼 보이는것은 사실 협력적인 프로세스일수 있습니다. 프로스스간에 통신이 잘될려면, OS는 파이프, 소켓 같은 IPC(Inter Process Communication)을 지원한다. IPC는 단순히 동일 시스템내에서 프록세스간의 통신뿐만 아니라 다른 시스템의 프로세스들간에도 사용됩니다.(뭔가 어려움;;)
&lt;code&gt;Processes are often seen as synonymous with programs or applications. However, what the user sees as a single application may in fact be a set of cooperating processes. To facilitate communication between processes, most operating systems support Inter Process Communication (IPC) resources, such as pipes and sockets. IPC is used not just for communication between processes on the same system, but processes on different systems.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;거의 모든 자바 가상머신은 싱글 프로세스로 구현된다. 자바 어플리케이션은 ProcessBuilder 객체를 사용해서 추가 프로세스들을 만들수 있습니다. 멀티프로세스 어플리케이션은 이 수업의 범위를 넘기므로 없습니다.
&lt;code&gt;Most implementations of the Java virtual machine run as a single process. A Java application can create additional processes using a ProcessBuilder object. Multiprocess applications are beyond the scope of this lesson.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;쓰레드&#34;&gt;쓰레드&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Threads&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;쓰레드는 때때로 가벼운 프로세스(lightwight processes)라고 불린다. 프로세스와 쓰레드는 실행환경을 제공하지만 새로운 프로세스를 생성하는 것보다 스레드를 생성하는게 자원 사용이 적다.
&lt;code&gt;Threads are sometimes called lightweight processes. Both processes and threads provide an execution environment, but creating a new thread requires fewer resources than creating a new process.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;쓰레드는 프로세스 안에 존재한다.(모든 프로세스는 최소한 하나의 스레드를 가진다.) 스레드는 프로세스의 메모리, 열린 파일등을 포함하여 자원을 공유한다. 이건 효과적이지만 잠재적으로 문제가 있습니다.(communication??)
&lt;code&gt;Threads exist within a process — every process has at least one. Threads share the process&#39;s resources, including memory and open files. This makes for efficient, but potentially problematic, communication.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;멀티쓰레드 동작은 자바 플랫폼의 필수적인 특징이다. 모든 어플리케이션은 최소한 하나의 (또는 여러개 )스레드를 가진다.메모리 관리와 시그널 핸들링과 같은 것과 같이 &amp;ldquo;시스템&amp;rdquo; 스레드를 셀 수 있습니다(???). 그러나 어플리케이션 프로그래머의 관점에서 보면 main 쓰레드라고 불리는 하나의 스레드로부터 시작합니다. 이 스레드는 추가 스레드를 생성하는 능력을 가졌다. 다음 섹션에서 설명하겠다.
&lt;code&gt;Multithreaded execution is an essential feature of the Java platform. Every application has at least one thread — or several, if you count &amp;quot;system&amp;quot; threads that do things like memory management and signal handling. But from the application programmer&#39;s point of view, you start with just one thread, called the main thread. This thread has the ability to create additional threads, as we&#39;ll demonstrate in the next section.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[발번역]The Java™ Tutorials - 0. Concurrency</title>
      <link>http://durtchrt.github.io/blog/java/concurrency/1/</link>
      <pubDate>Thu, 24 Nov 2016 12:00:34 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/concurrency/1/</guid>
      <description>

&lt;p&gt;##&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/concurrency/index.html&#34;&gt;원문링크&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lesson-concurrency&#34;&gt;Lesson: Concurrency&lt;/h1&gt;

&lt;p&gt;컴퓨터는 사용자에게 동일시간에 한가지 이상의 일을 할 수 있도록 시스템이 보장이 되야한다. 컴퓨터 사용자는 워드프로세서 작업을 할 때 다른 어플리케이션이 파일 다운로드, 스트리밍 오디오, 프린터 큐 관리등을 동시에 하는게 당연하사 생각한다. 심지어 하나의 어플레케이션이 한번에 한가지 이상의 동작하는 것을 종종 기대한다. 예를들면 스트리밍 오디오 어플레케이션은 반드시 동시에 네트워크로부터 디지털 오디오 읽기, 압축을 풀기, 재생 관리, 디스플레이 업데이트를 수행한다. 심지어 워드프로세서도 디스플레이 업데이트나 텍스트를 다시 포맷팅하는것이 얼마나 바쁜지 상관없이 키보드의 응답, 마우스 이벤트들의 응답을 대기해야한다. 그러한 것을 할 수 있는 소프트웨어를 병행성(동시성) 소프트웨어라고 알려져있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Computer users take it for granted that their systems can do more than one thing at a time. They assume that they can continue to work in a word processor, while other applications download files, manage the print queue, and stream audio. Even a single application is often expected to do more than one thing at a time. For example, that streaming audio application must simultaneously read the digital audio off the network, decompress it, manage playback, and update its display. Even the word processor should always be ready to respond to keyboard and mouse events, no matter how busy it is reformatting text or updating the display. Software that can do such things is known as concurrent software.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;자바 플랫폼은 병행 프로그래밍을 지원하도록 (밑바닥부터 끝까지) 설계 되었다. 자바 프로그래밍 언어와 자바 클래스 라이브러리들로 기본 병행성을 지원한다. 자바 플랫폼 5.0 버전부터는 고수준의 concurrency API도 포함되었다. 이번 자바 플랫폼의 수업은 기본 병행 지원과 몇가지 java.util.concurrent 패키지의 수준 API의 요약을 소개한다.
&lt;code&gt;The Java platform is designed from the ground up to support concurrent programming, with basic concurrency support in the Java programming language and the Java class libraries. Since version 5.0, the Java platform has also included high-level concurrency APIs. This lesson introduces the platform&#39;s basic concurrency support and summarizes some of the high-level APIs in the java.util.concurrent packages.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[컨퍼런스 후기- 20161123] playnode2016</title>
      <link>http://durtchrt.github.io/blog/conference/20161123/1/</link>
      <pubDate>Wed, 23 Nov 2016 11:55:37 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/conference/20161123/1/</guid>
      <description>

&lt;p&gt;&lt;code&gt;강연후기 1&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;javascrpt-everywhere-하나의-프로그래밍-언어로-모바일부터-로봇까지&#34;&gt;javascrpt everywhere - 하나의 프로그래밍 언어로 모바일부터 로봇까지&lt;/h1&gt;

&lt;p&gt;#소개
JavaScript Everywhere - 하나의 프로그래밍 언어로 천하통일을 꿈꾸는 메이커&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;JavaScript 와 Node.JS 만으로 IoT 제작/교육 플랫폼을 만들고, 로봇을 위한 임베디드도 Node.JS 로 제작한 사례를 공유합니다.
MongoDB 와 Elasticsearch 채용으로, 모바일 부터 로봇, 그리고 데이터 분석 까지 전 영역에 JavaScript 를 적용함으로써 얻은 교훈을 이야기 합니다.

박종건 | Circulus 대표/수원대학교 조교수

게임을 너무 좋아하여 휴학하고 다음 게임에 입사 하였다가, 직장이 아닌 직업을 찾기위해 IT개발을 위해 삼성SDS 정보기술연구소로 입사, IoT 기반 공급망/물류 시스템및 데이터 시각화 업무를 담당했습니다. 삼성 근무 시 내가 해야할 일은 남들도 누구나 SW+HW 를 이용하여 만들 수 있게 하자는 목적으로, 2013년 Circulus 커뮤니티를 시작, 뜻을 펼치기 위해 2016년 로봇 기반 에듀테크 스타트업 Circulus 를 시작하였습니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;주제&#34;&gt;주제&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;why? nodejs&lt;/li&gt;
&lt;li&gt;how?&lt;/li&gt;
&lt;li&gt;what&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;발표자&#34;&gt;발표자&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;rippertnt@gmail.com&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.circul.us&#34;&gt;http://www.circul.us&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;why-javascript&#34;&gt;Why - Javascript&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;One Language - Multi platform
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;과거
기계어 -&amp;gt; 저급언어 -&amp;gt; 하이레벨
==&amp;gt; 언어의 파편화&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;desktop : C#&lt;/li&gt;
&lt;li&gt;mobile: Object-C&lt;/li&gt;
&lt;li&gt;web: javascripot&lt;/li&gt;
&lt;li&gt;server : java&lt;/li&gt;
&lt;li&gt;embeded : c/c++&lt;/li&gt;
&lt;li&gt;database : sql&lt;/li&gt;

&lt;li&gt;&lt;p&gt;analysis : etc&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://namu.wiki/w/%EB%B0%94%EB%B2%A8%ED%83%91&#34;&gt;바벨탑&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;하나의 언어를 사용하던 시대에서&lt;/li&gt;
&lt;li&gt;바벨탑의 저로 언어가 다양해짐.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;자바스크립크 랭크&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://githut.info/&#34;&gt;github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/research/developer-survey-2016&#34;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;javascript-everywhere&#34;&gt;Javascript everywhere&lt;/h2&gt;

&lt;p&gt;모바일부터 로봇까지 가장 폭넓게 활용할 수 있는 언어&lt;/p&gt;

&lt;h5 id=&#34;개발자-메이커의-시대&#34;&gt;개발자 -&amp;gt; 메이커의 시대&lt;/h5&gt;

&lt;p&gt;기존 sw개발에서, HW + SW 결합하고 아이디어를 개발 SW개발자에서 융복합 메이커로의 진화&lt;/p&gt;

&lt;h5 id=&#34;opensource-hardware&#34;&gt;Opensource Hardware&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;저렴한 마이크로 컨트롤러/컴퓨터의 등장으로 H/W 영역도 실패가 가능해짐.(출시하면 납땜다시하지 않는이상 변경 불가였던 시절이 있었음 - 지금은 H/W rewrite 가능해짐)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kickstarter.com/projects/1598272670/chip-the-worlds-first-9-computer&#34;&gt;CHIP&lt;/a&gt; =&amp;gt; 9$ 컴퓨터&lt;/li&gt;
&lt;li&gt;3D 프린터&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;make-movement&#34;&gt;Make Movement&lt;/h5&gt;

&lt;p&gt;기존의 DIY 영역에서 ICT 기술이 접목.
&lt;a href=&#34;http://makerfaire.com/&#34;&gt;Maker Faire&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;S/W + H/W + Service 결합되어 다양한 아이디어들이 실제로 구현&lt;/p&gt;

&lt;h4 id=&#34;arduino-vs-raspberry-pi&#34;&gt;Arduino vs Raspberry Pi&lt;/h4&gt;

&lt;p&gt;Raspberry pi - microcomputer
(s/w)linux + javascript
(h/w) gpio
==&amp;gt; javascript로 개발하고 gpio와 연결된 외부 디바이스를 제어(ex- 모터, led)&lt;/p&gt;

&lt;h2 id=&#34;circulus&#34;&gt;Circulus&lt;/h2&gt;

&lt;p&gt;=&amp;gt; 발표자 회사 및 서비스 소개 자세한 내용은 슬라이드 참조.&lt;/p&gt;

&lt;h4 id=&#34;program-or-be-programmed&#34;&gt;Program or be programmed&lt;/h4&gt;

&lt;h4 id=&#34;education-making-with-circulus&#34;&gt;Education/Making with circulus&lt;/h4&gt;

&lt;h4 id=&#34;circulus-iot-platform&#34;&gt;Circulus Iot Platform&lt;/h4&gt;

&lt;h4 id=&#34;javascript-in-circulus&#34;&gt;javaScript in Circulus&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Web&lt;/th&gt;
&lt;th&gt;Server&lt;/th&gt;
&lt;th&gt;IoT platform&lt;/th&gt;
&lt;th&gt;Database&lt;/th&gt;
&lt;th&gt;win pc&lt;/th&gt;
&lt;th&gt;mobile&lt;/th&gt;
&lt;th&gt;wearable&lt;/th&gt;
&lt;th&gt;analysis&lt;/th&gt;
&lt;th&gt;embeded&lt;/th&gt;
&lt;th&gt;linux pc&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;javascript&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;mongodb&lt;/td&gt;
&lt;td&gt;nw.js&lt;/td&gt;
&lt;td&gt;cordova&lt;/td&gt;
&lt;td&gt;tizen&lt;/td&gt;
&lt;td&gt;elastic serach&lt;/td&gt;
&lt;td&gt;nodejs&lt;/td&gt;
&lt;td&gt;nw.js&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;how-robotics-intelligent-bot&#34;&gt;How - Robotics (Intelligent Bot)&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 발표자 회사 소개 자료..&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;code&gt;강연후기 2&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;how-the-node-js-event-loop-works&#34;&gt;How the Node.js event loop works&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Node.js프로그래머들은 비동기 I/O와 event loop에 대해 너무나 익숙합니다. 하지만 event loop가 실제 어떻게 작동되는지 아는 사람은 많지 않습니다. node가 Threads를 쓰는지 안쓰는지? Callback은 어디에서 오는지? nextTick을 쓸지 setImmediate을 쓸지? node 저변에는 &amp;quot;libuv&amp;quot;라이브러리가 여러 플랫폼 간의 이 모든 마법을 가능하게 합니다. HTTP 요청 처리 여부, 파일의 읽기나 타이머 처리까지 libuv 가 이 모든 것을 가능하게 합니다. 이 세션에서 libuv아키텍트인 Bert Belder는 event loop의 작동 방식, libuv가 어떻게 비동기화 I/O를 가능하게 하는지, 그리고 당신의 Node.js코드를 최대한 활용할 수 있도록 어떻게 돕는지에 대해 이해하기 쉽게 설명할 것입니다.

Bert Belder | Node.js core developer / Strongloop founder, IBM

Bert Belder는 2011년부터 Node.js 코어 컨트리뷰터로, 가장 오래된 node 메인테이너이자 지금도 활발하게 활동하고 있습니다. 2013년에 Bert는 동료 Ben Noordhuis와 함께 StrongLoop을 설립했습니다. 오픈 소스에는 libuv를 윈도우에 포팅하는 작업을 기점으로 첫 발을 들였으며, 그 이후로 지금까지 node 커뮤니티의 리더로 활동하고 있습니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;how-the-node-js-event-loop-works-1&#34;&gt;How the node.js event loop works&lt;/h1&gt;

&lt;p&gt;=&amp;gt; 사전 지식으로 커널에 대해 알고 있어야 이해가 감.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Bert Belder 
Node.js core developer / Strongloop founder, IBM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://www.google.co.kr/search?q=nodejs+eventloop&amp;amp;espv=2&amp;amp;biw=1246&amp;amp;bih=780&amp;amp;source=lnms&amp;amp;tbm=isch&amp;amp;sa=X&amp;amp;ved=0ahUKEwja-KWEib7QAhWJVLwKHQcICc0Q_AUIBigB&#34;&gt;구글 이미지 검색 node.js event loop&lt;/a&gt;
=&amp;gt; 모두 잘못되었다고 말함;; 임팩트를 줌!!&lt;/p&gt;

&lt;h4 id=&#34;네트워킹-프로그래밍을-할때-최소-3번은-blocking이-생긴다&#34;&gt;네트워킹 프로그래밍을 할때 최소 3번은 blocking이 생긴다.&lt;/h4&gt;

&lt;p&gt;(psedo code로 c 코드를 보여줌)
- I/O 작업시에 블럭킹 발생
    - connect method
    - write method
    - read method&lt;/p&gt;

&lt;p&gt;==&amp;gt; 그러나 컴퓨터 H/W는 비동기임.
==&amp;gt; 보여준 코드는 절차적이면서 스테이트먼트가 끝나려면 응답을 기다리는 blocking 구조임.&lt;/p&gt;

&lt;h4 id=&#34;h-w-비동기-참조-pio-dma&#34;&gt;H/W 비동기 참조 PIO -&amp;gt; DMA&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8_%EC%9E%85%EC%B6%9C%EB%A0%A5&#34;&gt;PIO&lt;/a&gt;
&lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%A7%81%EC%A0%91_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%A0%91%EA%B7%BC&#34;&gt;DMA&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;cpu &amp;ndash; command  &amp;mdash;&amp;gt;
    &amp;lt;&amp;ndash;interrupt  &amp;mdash;  disk &amp;lt;&amp;ndash;data&amp;mdash;&amp;gt; ram&lt;/p&gt;

&lt;h4 id=&#34;nodejs-eventloop&#34;&gt;nodejs eventloop&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;../1.jpg&#34; alt=&#34;설명자료1&#34; /&gt;
&lt;img src=&#34;../2.jpg&#34; alt=&#34;설명자료&#34; /&gt;
&lt;img src=&#34;../3.jpg&#34; alt=&#34;설명자료&#34; /&gt;
&lt;img src=&#34;../4.jpg&#34; alt=&#34;설명자료&#34; /&gt;
&lt;img src=&#34;../5.jpg&#34; alt=&#34;설명자료&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;유니콘-함수-설명&#34;&gt;유니콘 함수 설명.&lt;/h5&gt;

&lt;p&gt;function unicorn {
  //Put the main thread to sleep
  // Wake u when:
  * there ar events ffrom the kernel to process
  * a thread pool thread has completed an operation
  * the next timer goes off&lt;/p&gt;

&lt;p&gt;nonblocking o/s main method
linux - epoll_wait
ios- kevent
windows-GetQueuedCompletionStatusEx()&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h4 id=&#34;non-blocking-i-o&#34;&gt;Non-blocking I/O&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Try an I/O operation(rad, write)&lt;/li&gt;
&lt;li&gt;If it couldn&amp;rsquo;t be done immediately, EAGAIN or EWOULDBLCIK is returned&lt;/li&gt;
&lt;li&gt;Call epoll() / kqueue() to knwo when you should try again&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Overlapped I/O
1. send a command to the kernel(WSARecv, WSASend)
2. Call GetQueuedCompletionStatusEx() later to get the result.&lt;/p&gt;

&lt;h5 id=&#34;node에서-커널관심사&#34;&gt;node에서 커널관심사&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;../6.jpg&#34; alt=&#34;이미지&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;node-loop-tick&#34;&gt;node loop tick(??)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;../7.jpg&#34; alt=&#34;이미지&#34; /&gt;
원래는 nextTick/callback만 있었는데 Resolve/Promise&lt;/p&gt;

&lt;p&gt;발표자 트위터 @scisauresus&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;code&gt;강연후기 3&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;electron을-이용한-모바일-테스트-자동화-소프트웨어-개발&#34;&gt;Electron을 이용한 모바일 테스트 자동화 소프트웨어 개발&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Electron을 이용한 모바일 테스트 자동화 소프트웨어 개발

Node기반의 Electron을 이용하여 모바일 앱 테스트 자동화 소프트웨어 개발 사례를 소개하고, Node가 가진 인프라를(NPM) 프론트-엔드 기술에 접목시켰을 때의 효과와, 달라지는 것은 무엇인지에 대하여 알아보는 시간을 가져봅시다.

경준호 | 알서포트

자바스크립트를 매우 사랑하는 10년차 프론트-엔드 개발자입니다. Firejune이라는 닉으로 활동 중이며, 순수 미술을 전공했고 웹 디자인을 시작으로 IT업계에 발을 들여 놓았다가 안타깝게도 개발자가 되고 말았습니다…
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;agenda&#34;&gt;Agenda&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Test Atutomationwith ATDD&lt;/li&gt;
&lt;li&gt;node based desktop application&lt;/li&gt;
&lt;li&gt;introduction to project psyclone&lt;/li&gt;
&lt;li&gt;test cloud service with psyclone&lt;/li&gt;
&lt;li&gt;QA&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;test-automation-with-atdd&#34;&gt;Test Automation with ATDD&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;ATDD: Acceptance Test Driven Development&amp;rdquo;
수용가능한 테스트 주도 개발&lt;/p&gt;

&lt;p&gt;pullrequest시에 코드만 있고 테스트가 없을때&lt;/p&gt;

&lt;p&gt;Where is Test
정적테스트 -  개발중인 테스트 코드
Dynamic test - 이미 완성된 코드를 테스트할때&lt;/p&gt;

&lt;p&gt;TDD, BDD, ATDD cycle 이미지 참조&lt;/p&gt;

&lt;h3 id=&#34;web-e2e-testing-tools&#34;&gt;Web E2E Testing tools&lt;/h3&gt;

&lt;p&gt;selenium, Webdriver, nemo, nightwatch, protractor webdriverIO, &amp;hellip;.&lt;/p&gt;

&lt;p&gt;CI와 연계하면 좋음&lt;/p&gt;

&lt;h4 id=&#34;selenium&#34;&gt;Selenium&lt;/h4&gt;

&lt;p&gt;Webdriver - selenium이 만든 spec - 브라우저 벤더가 만들어줌. &lt;a href=&#34;https://www.w3.org/TR/webdriver/&#34;&gt;2015 W3C 채택&lt;/a&gt;
Grid
IDE
Remote Controlll&lt;/p&gt;

&lt;p&gt;Testscript -&amp;gt; webdriver client -&amp;gt; remote server -&amp;gt; selenium(?)&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;nightwatch-script&#34;&gt;Nightwatch Script&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://nightwatchjs.org/&#34;&gt;링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;examples/test/googleDemoTest.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  &#39;Demo test Google&#39; : function (client) {
    client
      .url(&#39;http://www.google.com&#39;)
      .waitForElementVisible(&#39;body&#39;, 1000)
      .assert.title(&#39;Google&#39;)
      .assert.visible(&#39;input[type=text]&#39;)
      .setValue(&#39;input[type=text]&#39;, &#39;rembrandt van rijn&#39;)
      .waitForElementVisible(&#39;button[name=btnG]&#39;, 1000)
      .click(&#39;button[name=btnG]&#39;)
      .pause(1000)
      .assert.containsText(&#39;ol#rso li:first-child&#39;,
        &#39;Rembrandt - Wikipedia&#39;)
      .end();
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;./bin/nightwatch -t examples/test/googleDemoTest.js&lt;/p&gt;

&lt;h5 id=&#34;node-based-desktop-application&#34;&gt;Node based Desktop Application&lt;/h5&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sindresorhus/awesome-electron&#34;&gt;Awesome Electron&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;electron-atom-shell&#34;&gt;Electron(Atom-Shell)&lt;/h4&gt;

&lt;p&gt;architecture&lt;/p&gt;

&lt;h4 id=&#34;psyclone&#34;&gt;Psyclone&lt;/h4&gt;

&lt;p&gt;Environments
- React + reduct
- mocha should
- node canvas
- opencv
- pty.js
- highcharts
- fallow W3c&amp;rsquo;s web driver spec
- next generator javascript
- custom npm modules&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/wycats/javascript-decorators&#34;&gt;javascript decorator&lt;/a&gt;
&lt;a href=&#34;https://github.com/a-framework/REMOVE-react-redux-decorators&#34;&gt;react-redux-decorators&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;code&gt;강연후기 4&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;docker-docker-swarm-관리-툴-gorae-project&#34;&gt;Docker, Docker Swarm 관리 툴 Gorae Project&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;React.js, Node.js 로 개발되어진 Docker 관리 도구인 Gorae 프로젝트의 개발 구조와 과정에 대해서 이야기하고 Docker 환경에 친해지고 인사이트를 얻을 수 있는 시간을 마련해보고자 합니다.

Rhio Kim (김양원) | CDNetworks

프론트 엔드 기술을 좋아하고 늘 꾸준한 개발과 연구를 즐겨합니다. Haroopress 와 Haroopad 개발자입니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;gorae&#34;&gt;Gorae&lt;/h4&gt;

&lt;p&gt;hypervisor vs LXC(LinuX Containers)
&lt;img src=&#34;http://blog.jayway.com/wp-content/uploads/2015/03/vm-vs-docker.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;hypervisor - kvm, vmware, hyper-v
LXC - docker &lt;a href=&#34;http://robinsystems.com/blog/linux-containers-comparison-lxc-docker/&#34;&gt;참고&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=UEK-mpfjrMM&amp;amp;feature=youtu.be&#34;&gt;참고동영상&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s Gorae&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Docker GUI tool&lt;/li&gt;
&lt;li&gt;Docker Swarm GUI tool&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;비슷한 docker ochestration tool(도커 컨테이너 관리,  WEB UI)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://kubernetes.io/&#34;&gt;kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/ui/&#34;&gt;kubernetes ui&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Components&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Gorae(ui)&lt;/li&gt;
&lt;li&gt;Gorae-swarm(ui)&lt;/li&gt;
&lt;li&gt;Gorae-server(Backend)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>4Clojure 문제 모음 1 ~ 25</title>
      <link>http://durtchrt.github.io/blog/clojure/4clojure/questions25/</link>
      <pubDate>Sun, 20 Nov 2016 04:22:01 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/clojure/4clojure/questions25/</guid>
      <description>

&lt;h3 id=&#34;1-진실만있다-nothing-but-the-truth-https-www-4clojure-com-problem-1&#34;&gt;1.진실만있다. &lt;a href=&#34;https://www.4clojure.com/problem/1&#34;&gt;Nothing but the Truth&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이것은 클로저 폼이다. 폼 평가를 true가 되도록 값을 넣으세요. 생각이 깊게 하지 마세요! 만약 헤갈린다면, 클로저 초급 문서를 보세요. Hint: true는 true와 같다&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is a clojure form. Enter a value which will make the form evaluate to true. Don&#39;t over think it! If you are confused, see the getting started page. Hint: true is equal to true.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= __ true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;true
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;2-간단한-수학-simple-math-https-www-4clojure-com-problem-2&#34;&gt;2. 간단한 수학&lt;a href=&#34;https://www.4clojure.com/problem/2&#34;&gt;Simple Math&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
polish notation(전위연산)이 익숙하지 않다면 간단한 계산 혼란을 느낄것이다.
중요: 빈칸을 채우세요(숫자 하나입니다.) - 문제 전체를 타이핑하지 마세요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;If you are not familiar with polish notation, simple arithmetic might seem confusing.
Note: Enter only enough to fill in the blank (in this case, a single number) - do not retype the whole problem. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= (- 10 (* 2 3)) __)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;4
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;3-문자열-소개-intro-to-strings-https-www-4clojure-com-problem-3&#34;&gt;3.문자열 소개&lt;a href=&#34;https://www.4clojure.com/problem/3&#34;&gt;Intro to Strings&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
클로저 String은 자바 String이다. 즉, 클로저 String은 자바 String 메서드를 사용할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Clojure strings are Java strings. This means that you can use any of the Java string methods on Clojure strings.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= __ (.toUpperCase &amp;quot;hello world&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;&amp;quot;HELLO WORLD&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;4-리스트-소개-intro-to-lists-https-www-4clojure-com-problem-4&#34;&gt;4.리스트 소개&lt;a href=&#34;https://www.4clojure.com/problem/4&#34;&gt;Intro to Lists&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도:초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
Lists는 함수 또는 quoted form으로 만들수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Lists can be constructed with either a function or a quoted form. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= (list __) &#39;(:a :b :c))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;:a :b :c
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;5-리스트-conj-lists-conj-https-www-4clojure-com-problem-5&#34;&gt;5.리스트: conj &lt;a href=&#34;https://www.4clojure.com/problem/5&#34;&gt;Lists: conj&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
리스트를 조작할때 conj함수는 하나 이상의 아이템이 앞에 &amp;ldquo;추가된&amp;rdquo; 새로운 리스트를 반환한다.
중요: 두 테스트 케이스는 답이 하나다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;When operating on a list, the conj function will return a new list with one or more items &amp;quot;added&amp;quot; to the front.

Note that there are two test cases, but you are expected to supply only one answer, which will cause all the tests to pass. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= __ (conj &#39;(2 3 4) 1))
(= __ (conj &#39;(3 4) 2 1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;&#39;(1 2 3 4)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;6-벡터소개-intro-to-vectors-https-www-4clojure-com-problem-6&#34;&gt;6.벡터소개 &lt;a href=&#34;https://www.4clojure.com/problem/6&#34;&gt;Intro to Vectors&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
Vector는 다양한 방법으로 생성할 수 있다. 벡터는 리스트와 비교할 수 있다.&lt;/p&gt;

&lt;p&gt;브라켓([])으로 둘러싸여진 __ 부분을 채워라.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Vectors can be constructed several ways. You can compare them with lists.

Note: the brackets [] surrounding the blanks __ are part of the test case.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= [__] (list :a :b :c) (vec &#39;(:a :b :c)) (vector :a :b :c))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;:a :b :c
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;7-벡터-conj-vectors-conj-https-www-4clojure-com-problem-7&#34;&gt;7. 벡터: conj&lt;a href=&#34;https://www.4clojure.com/problem/7&#34;&gt;Vectors: conj&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
Vector를 조작할 때, conj 함수는 마지막에 하나 이상의 아이템이 &amp;ldquo;추가된&amp;rdquo; 새로운 vector를 반환한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;When operating on a Vector, the conj function will return a new vector with one or more items &amp;quot;added&amp;quot; to the end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= __ (conj [1 2 3] 4))
(= __ (conj [1 2] 3 4))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;[1 2 3 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;8-set-소개-intro-to-sets-https-www-4clojure-com-problem-8&#34;&gt;8. Set 소개&lt;a href=&#34;https://www.4clojure.com/problem/8&#34;&gt;Intro to Sets&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
Set은 유일한 값의 집합(collection)이다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Sets are collections of unique values.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= __ (set &#39;(:a :a :b :c :c :c :c :d :d)))
(= __ (clojure.set/union #{:a :b :c} #{:b :c :d}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;#{:a :b :c :d}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;9-sets-conj-sets-conj-https-www-4clojure-com-problem-9&#34;&gt;9 Sets: conj &lt;a href=&#34;https://www.4clojure.com/problem/9&#34;&gt;Sets: conj&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
set을 조작할 때, conj 함수는 한개 이상의 키가 &amp;ldquo;추가된&amp;rdquo; 새로운 set을 반환한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;When operating on a set, the conj function returns a new set with one or more keys &amp;quot;added&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= #{1 2 3 4} (conj #{1 4 3} __))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;2
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;10-map-소개-intro-to-maps-https-www-4clojure-com-problem-10&#34;&gt;10. Map 소개&lt;a href=&#34;https://www.4clojure.com/problem/10&#34;&gt;Intro to Maps&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
Map은 키-값(key-value)쌍을 저장한다. maps와 keywords는 둘다 검색(lookup) 함수를 사용할 수 있다. 쉼표(,)는 맵을 더 읽기 쉽게하지만 필수는 아니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Maps store key-value pairs. Both maps and keywords can be used as lookup functions. Commas can be used to make maps more readable, but they are not required. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;keyword 참고&lt;/em&gt;
user=&amp;gt; (keyword &amp;lsquo;foo)
:foo&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= __ ((hash-map :a 10, :b 20, :c 30) :b))
(= __ (:b {:a 10, :b 20, :c 30}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;20
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;11-mpas-conj-maps-conj-https-www-4clojure-com-problem-11&#34;&gt;11. Mpas: conj &lt;a href=&#34;https://www.4clojure.com/problem/11&#34;&gt;Maps: conj&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
맵을 조작할때, conj 함수는 하나 이상의 키와 값의 쌍이 &amp;ldquo;추가된&amp;rdquo; 새로운 맵을 반환한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;When operating on a map, the conj function returns a new map with one or more key-value pairs &amp;quot;added&amp;quot;. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= {:a 1, :b 2, :c 3} (conj {:a 1} __ [:c 3]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;{:b 2}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;12-시퀀스-소개-intro-to-sequences-https-www-4clojure-com-problem-12&#34;&gt;12.시퀀스 소개&lt;a href=&#34;https://www.4clojure.com/problem/12&#34;&gt;Intro to Sequences&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
모든 클로저의 컬렉션들은 시퀀싱(순서)을 지원한다. first, second, last 함수와 함께 시퀀스를 조작할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;All Clojure collections support sequencing. You can operate on sequences with functions like first, second, and last.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= __ (first &#39;(3 2 1)))

(= __ (second [2 3 4]))

(= __ (last (list 1 2 3)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;3
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;13-시퀀스-rest-sequences-rest-https-www-4clojure-com-problem-13&#34;&gt;13.시퀀스: rest&lt;a href=&#34;https://www.4clojure.com/problem/13&#34;&gt;Sequences: rest&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
rest 함수는 첫번째를 제외한 모든 아이템들의 시퀀스를 반환한다.&lt;/p&gt;

&lt;p&gt;The rest function will return all the items of a sequence except the first.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= __ (rest [10 20 30 40]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;[20 30 40]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;14-함수-소개-intro-to-functions-https-www-4clojure-com-problem-14&#34;&gt;14.함수 소개&lt;a href=&#34;https://www.4clojure.com/problem/14&#34;&gt;Intro to Functions&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
클로저는 함수를 생성하는 다양한 방법이 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Clojure has many different ways to create functions.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= __ ((fn add-five [x] (+ x 5)) 3))

(= __ ((fn [x] (+ x 5)) 3))

(= __ (#(+ % 5) 3))

(= __ ((partial + 5) 3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;8
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;15-double-down-https-www-4clojure-com-problem&#34;&gt;15.&lt;a href=&#34;https://www.4clojure.com/problem/&#34;&gt;Double Down&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
숫자를 2배 만드는 함수를 작성하시오.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Write a function which doubles a number.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= (__ 2) 4)

(= (__ 3) 6)

(= (__ 11) 22)

(= (__ 7) 14)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;* 2
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;16-hello-world-hello-world-https-www-4clojure-com-problem-16&#34;&gt;16.Hello World&lt;a href=&#34;https://www.4clojure.com/problem/16&#34;&gt;Hello World&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
개인화된 인사말을 반환하는 함수를 작성하시오.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Write a function which returns a personalized greeting.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= (__ &amp;quot;Dave&amp;quot;) &amp;quot;Hello, Dave!&amp;quot;)

(= (__ &amp;quot;Jenn&amp;quot;) &amp;quot;Hello, Jenn!&amp;quot;)

(= (__ &amp;quot;Rhea&amp;quot;) &amp;quot;Hello, Rhea!&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;#(str &amp;quot;Hello, &amp;quot; % &amp;quot;!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(fn [name] (str &amp;quot;Hello, &amp;quot; name &amp;quot;!&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(fn helloGreeting [name] (str &amp;quot;Hello, &amp;quot; name &amp;quot;!&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;17-시퀀스-map-sequences-map-https-www-4clojure-com-problem-17&#34;&gt;17.시퀀스: map&lt;a href=&#34;https://www.4clojure.com/problem/17&#34;&gt;Sequences: map&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
map 함수는 두개의 인자를 취합니다(함수(f), 시퀀스(s)). map은 시퀀스(s)의 개별 아이템에 함수(f)를 적용한 결과의 새로운 시퀀스 consisting(구조물?)을 반환한다. 자료구조 map과 map 함수와 헤갈리지 말자.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The map function takes two arguments: a function (f) and a sequence (s). Map returns a new sequence consisting of the result of applying f to each item of s. Do not confuse the map function with the map data structure.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= __ (map #(+ % 5) &#39;(1 2 3)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;&#39;(6 7 8)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;18-시퀀스-filter-sequences-filter-https-www-4clojure-com-problem-18&#34;&gt;18.시퀀스: filter&lt;a href=&#34;https://www.4clojure.com/problem/18&#34;&gt;Sequences: filter&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
filter 함수는 두개의 인자를 취합니다(predicate 함수(f), 시퀀스(s)). filter는 (f item)의 결과가 true인 모든 아이템의 시퀀스 consisting을 반환합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The filter function takes two arguments: a predicate function (f) and a sequence (s). Filter returns a new sequence consisting of all the items of s for which (f item) returns true.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= __ (filter #(&amp;gt; % 5) &#39;(3 4 5 6 7)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;&#39;(6 7)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;19-마지막-요소-last-element-https-www-4clojure-com-problem-19&#34;&gt;19.마지막 요소&lt;a href=&#34;https://www.4clojure.com/problem/19&#34;&gt;Last Element&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 쉬움
주제: seqs 코어 함수 &lt;code&gt;seqs core-functions&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
시퀀스의 마지막 요소를 반환하는 함수를 작성하시오.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Write a function which returns the last element in a sequence.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;last 함수는 사용하지 마세요&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Special Restrictions
last 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= (__ [1 2 3 4 5]) 5)

(= (__ &#39;(5 4 3)) 3)

(= (__ [&amp;quot;b&amp;quot; &amp;quot;c&amp;quot; &amp;quot;d&amp;quot;]) &amp;quot;d&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(comp first reverse) ; &amp;lt;- last가 안되서 찾다가 참조한 답. 아래는 다른 답으로 제출
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;#(nth % (- (count %) 1))
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;20-두번째-요소-penultimate-element-https-www-4clojure-com-problem-20&#34;&gt;20.두번째 요소&lt;a href=&#34;https://www.4clojure.com/problem/20&#34;&gt;Penultimate Element&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 쉬움
주제: seqs&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
시퀀스에서 마지막에서 두번째 요소를 반환하는 함수를 작성하세요&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Write a function which returns the second to last element from a sequence.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= (__ (list 1 2 3 4 5)) 4)

(= (__ [&amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot;]) &amp;quot;b&amp;quot;)

(= (__ [[1 2] [3 4]]) [1 2])



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(comp first rest reverse)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;21-n번째-요소-nth-element-https-www-4clojure-com-problem-21&#34;&gt;21.N번째 요소&lt;a href=&#34;https://www.4clojure.com/problem/21&#34;&gt;Nth Element&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 쉬움
주제: seqs core-functions&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
시퀀스로부터 N번째 요소를 반환하는 함수를 작성하세요.&lt;/p&gt;

&lt;p&gt;Write a function which returns the Nth element from a sequence.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nth 함수는 사용하지 마세요.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Special Restrictions
nth
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= (__ &#39;(4 5 6 7) 2) 6)
(= (__ [:a :b :c] 0) :a)
(= (__ [1 2 3 4] 1) 2)
(= (__ &#39;([1 2] [3 4] [5 6]) 2) [5 6])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(fn [x y] (get (into [] x) y))
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;22-시퀀스-갯수-세기-count-a-sequence-https-www-4clojure-com-problem-22&#34;&gt;22.시퀀스 갯수 세기&lt;a href=&#34;https://www.4clojure.com/problem/22&#34;&gt;Count a Sequence&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 쉬움&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
시퀀스의 요소의 전체 갯수를 반환하는 함수를 작성하세요&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Write a function which returns the total number of elements in a sequence.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;count함수는 사용하지 마세요&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Special Restrictions
count
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= (__ &#39;(1 2 3 3 1)) 5)
(= (__ &amp;quot;Hello World&amp;quot;) 11)
(= (__ [[1 2] [3 4] [5 6]]) 3)
(= (__ &#39;(13)) 1)
(= (__ &#39;(:a :b :c)) 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;#(reduce + (map (fn [_] 1) %))
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;23-시퀀스-뒤집기-reverse-a-sequence-https-www-4clojure-com-problem-23&#34;&gt;23.시퀀스 뒤집기&lt;a href=&#34;https://www.4clojure.com/problem/23&#34;&gt;Reverse a Sequence&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 초급
주제: seqs core-functions&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
시퀀스 reverses 함수를 작성하시오&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Write a function which reverses a sequence.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;reverse, rseq 함수를 사용하지 마세요&lt;/strong&gt;
    Special Restrictions
    reverse
    rseq&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= (__ [1 2 3 4 5]) [5 4 3 2 1])
(= (__ (sorted-set 5 7 2 7)) &#39;(7 5 2))
(= (__ [[1 2][3 4][5 6]]) [[5 6][3 4][1 2]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;#(reduce conj &#39;() %)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;24-모두-더해라-sum-it-all-up-https-www-4clojure-com-problem-24&#34;&gt;24.모두 더해라&lt;a href=&#34;https://www.4clojure.com/problem/24&#34;&gt;Sum It All Up&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 쉬움
주제: seqs&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
숫자로된 시퀀스의 합을 반환하는 함수를 작성하시오.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Write a function which returns the sum of a sequence of numbers.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= (__ [1 2 3]) 6)
(= (__ (list 0 -2 5 5)) 8)
(= (__ #{4 2 1}) 7)
(= (__ &#39;(0 0 -1)) -1)
(= (__ &#39;(1 10 3)) 14)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;#(reduce + %)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;25-홀수를-찾아라-find-the-odd-numbers-https-www-4clojure-com-problem-25&#34;&gt;25.홀수를 찾아라&lt;a href=&#34;https://www.4clojure.com/problem/25&#34;&gt;Find the odd numbers&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;난이도: 쉬움
주제: seqs&lt;/p&gt;

&lt;p&gt;&lt;code&gt;문제&lt;/code&gt;
시퀀스로부터 홀수만 반환하는 함수를 작성하세요&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Write a function which returns only the odd numbers from a sequence.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;문제 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= (__ #{1 2 3 4 5}) &#39;(1 3 5))
(= (__ [4 2 1 6]) &#39;(1))
(= (__ [2 2 4 6]) &#39;())
(= (__ [1 1 1 3]) &#39;(1 1 1 3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;통과한 코드&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;#(filter odd? %)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(10) 와일드카드 Wildcards </title>
      <link>http://durtchrt.github.io/blog/java/generics/11/</link>
      <pubDate>Sat, 12 Nov 2016 18:23:01 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/11/</guid>
      <description>

&lt;h3 id=&#34;상위-제한된-와일드-카드-upper-bounded-wildcards&#34;&gt;상위 제한된 와일드 카드 &lt;code&gt;Upper Bounded Wildcards&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;변수에 완화된 제한을 걸고 싶을때 upper bounded wildcard를 사용한다. 예를들면, List&amp;lt;Integer&amp;gt;, List&amp;lt;Double&amp;gt;, List&amp;lt;Number&amp;gt; 타입들에서 동작하는 메서드를 작성할때 upper bounded wildcard를 사용해서 만들수 있다.
&lt;code&gt;You can use an upper bounded wildcard to relax the restrictions on a variable. For example, say you want to write a method that works on List&amp;lt;Integer&amp;gt;, List&amp;lt;Double&amp;gt;, and List&amp;lt;Number&amp;gt;; you can achieve this by using an upper bounded wildcard.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;uppper-bounded wildcard는 와일드카드 문자 &amp;lsquo;?&amp;lsquo;와 뒤에는 extends 키워드를 사용하고 뒤에는 상위 타입을 써서 정의한다. 클래스의 extends, 인터페이스의 implements처럼 extends 키워드는 이러한 의미로 사용된다.
&lt;code&gt;To declare an upper-bounded wildcard, use the wildcard character (&#39;?&#39;), followed by the extends keyword, followed by its upper bound. Note that, in this context, extends is used in a general sense to mean either &amp;quot;extends&amp;quot; (as in classes) or &amp;quot;implements&amp;quot; (as in interfaces).&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Integer, Double, Float처럼 Number 타입의 서브타입들에서 동작하는 메서드를 작성할 때, List&amp;lt;? extends Number&amp;gt; 요래 작성하면된다. List&amp;lt;Number&amp;gt;는 List&amp;lt;? extends Number&amp;gt;보다 제한적이다. 전자는 Number 타입의 리스트만 가능, 후자는 Number 타입 또는 Number 타입의 서브 타입 리스트도 가능하다.
&lt;code&gt;To write the method that works on lists of Number and the subtypes of Number, such as Integer, Double, and Float, you would specify List&amp;lt;? extends Number&amp;gt;. The term List&amp;lt;Number&amp;gt; is more restrictive than List&amp;lt;? extends Number&amp;gt; because the former matches a list of type Number only, whereas the latter matches a list of type Number or any of its subclasses.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;아래의 process 메서드를 살펴보자 &lt;code&gt;Consider the following process method:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void process(List&amp;lt;? extends Foo&amp;gt; list) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lt;? extends Foo&amp;gt; upper bounded wildcard는 Foo와 Foo의 서브타입과 매치되는 표현이다. (아래의 코드 참조)process 메서드는 Foo타입과 같은 리스트의 요소를 엑세스할수 있다.
&lt;code&gt;The upper bounded wildcard, &amp;lt;? extends Foo&amp;gt;, where Foo is any type, matches Foo and any subtype of Foo. The process method can access the list elements as type Foo:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void process(List&amp;lt;? extends Foo&amp;gt; list) {
    for (Foo elem : list) {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;foreach절은 list의 각각 요소를 순회하며 elem 변수에 할당한다.  elem은 Foo 클래스에 정의되어 있는 메서드를 모두 사용할 수 있다.
&lt;code&gt;In the foreach clause, the elem variable iterates over each element in the list. Any method defined in the Foo class can now be used on elem.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;sumOfList메서드는 리스트 안의 숫자의 합을 리턴한다. &lt;code&gt;The sumOfList method returns the sum of the numbers in a list:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static double sumOfList(List&amp;lt;? extends Number&amp;gt; list) {
    double s = 0.0;
    for (Number n : list)
        s += n.doubleValue();
    return s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래의 코드는 Integer 객체 리스트를 사용하여 &amp;ldquo;sum = 6.0&amp;rdquo;을 출력한다.
&lt;code&gt;The following code, using a list of Integer objects, prints sum = 6.0:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Integer&amp;gt; li = Arrays.asList(1, 2, 3);
System.out.println(&amp;quot;sum = &amp;quot; + sumOfList(li));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Double값을 가진 리스트도 sumOfList 메서드를 역시 사용할 수 있다. 아래의 코드는 &amp;ldquo;sum = 7.0&amp;rdquo;을 출력한다.
&lt;code&gt;A list of Double values can use the same sumOfList method. The following code prints sum = 7.0:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Double&amp;gt; ld = Arrays.asList(1.2, 2.3, 3.5);
System.out.println(&amp;quot;sum = &amp;quot; + sumOfList(ld));
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(10) 와일드카드 Wildcards </title>
      <link>http://durtchrt.github.io/blog/java/generics/10/</link>
      <pubDate>Fri, 11 Nov 2016 18:23:01 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/10/</guid>
      <description>

&lt;h3 id=&#34;와일드카드-wildcards&#34;&gt;와일드카드 &lt;code&gt;Wildcards&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic 코드에서는 unkown 타입을 표현하는 물음표(?)를 와일드 카드라고 부른다. 와일드카드는 다양한 상황에서 쓰인다.(파라메터, 필드, 지역변수 타입 때로는 리턴 타입에도 쓰인다. (though it is better programming practice to be more specific). 와일드카드는 제네릭 메서드 호출, 제네릭 클래스의 인스턴스 생성, 또는 슈퍼타입을 위해 타입인자로는 사용되지 않는다.
&lt;code&gt;In generic code, the question mark (?), called the wildcard, represents an unknown type. The wildcard can be used in a variety of situations: as the type of a parameter, field, or local variable; sometimes as a return type (though it is better programming practice to be more specific). The wildcard is never used as a type argument for a generic method invocation, a generic class instance creation, or a supertype.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이번장에는 와일드카드에 대해 논의한다. 상위제한된 와일드카드/하위제한된 와일드카드, 와일드카드 캡쳐등을 다룬다.
&lt;code&gt;The following sections discuss wildcards in more detail, including upper bounded wildcards, lower bounded wildcards, and wildcard capture.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(13) Java Generics: 하위 제한 와일드카드(Lower Bounded Wildcards)</title>
      <link>http://durtchrt.github.io/blog/java/generics/13/</link>
      <pubDate>Mon, 07 Nov 2016 14:00:42 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/13/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/wildcards.htm://docs.oracle.com/javase/tutorial/java/generics/lowerBounded.html&#34;&gt;원문링크&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;하위-제한-와일드카드-lower-bounded-wildcards&#34;&gt;하위 제한 와일드카드  &lt;code&gt;Lower Bounded Wildcards&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;상위제한와일드카드장은 특정 타입이나 그 특정타입의  서브타입을 알 수 없을때는 &amp;lsquo;extends&amp;rsquo; 키워드를 사용하는 것을 보여줬다. 비슷한 것으로, 하위제한와일드카드는 특정타입이나 그 특정 타입의 슈퍼타입을 제한하고자할때 사용한다.
&lt;code&gt;The Upper Bounded Wildcards section shows that an upper bounded wildcard restricts the unknown type to be a specific type or a subtype of that type and is represented using the extends keyword. In a similar way, a lower bounded wildcard restricts the unknown type to be a specific type or a super type of that type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;하위제한 와일드카드는 와일드카드문자(&amp;lsquo;?&amp;rsquo;) 그 뒤로 super 키워드와 그 뒤로 하위제한 타입이 온다. &amp;lt;? super A&amp;gt;.
&lt;code&gt;A lower bounded wildcard is expressed using the wildcard character (&#39;?&#39;), following by the super keyword, followed by its lower bound: &amp;lt;? super A&amp;gt;.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;중요: 상위제한와일드카드를 사용하거나 하위제한와일드카드를 사용할 수 있지만, 둘을 동시에 사용할 수 없다.&lt;/code&gt;
&lt;code&gt;Note: You can specify an upper bound for a wildcard, or you can specify a lower bound, but you cannot specify both.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;리스트에 Integer 객체를 넣는 코드를 작성할때, List&amp;lt;Integer&amp;gt;, List&amp;lt;Number&amp;gt;, List&amp;lt;Object\&amp;gt;에서만 동작하길 원하는 메서드를 만든다고 가정하자.
&lt;code&gt;Say you want to write a method that puts Integer objects into a list. To maximize flexibility, you would like the method to work on List&amp;lt;Integer&amp;gt;, List&amp;lt;Number&amp;gt;, and List&amp;lt;Object&amp;gt; — anything that can hold Integer values.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Integer타이이나 Integer의 상위타입에서 동작하는 메서드를 작성하려면 List&amp;lt;? super Integer&amp;gt;라고 할 수 있다. List&amp;lt;Integer&amp;gt;는 List&amp;lt;? super Integer&amp;gt;보다 제한적이다. 왜냐하면 전자는 Integer 타입의 리스트만 사용, 후자는 Integer 타입과 Integer의 슈퍼타입에 사용할 수 있기 때문이다.
&lt;code&gt;To write the method that works on lists of Integer and the supertypes of Integer, such as Integer, Number, and Object, you would specify List&amp;lt;? super Integer&amp;gt;. The term List&amp;lt;Integer&amp;gt; is more restrictive than List&amp;lt;? super Integer&amp;gt; because the former matches a list of type Integer only, whereas the latter matches a list of any type that is a supertype of Integer.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;아래의 코드는 1에서 10까지 리스트에 add한다.
&lt;code&gt;The following code adds the numbers 1 through 10 to the end of a list:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void addNumbers(List&amp;lt;? super Integer&amp;gt; list) {
    for (int i = 1; i &amp;lt;= 10; i++) {
        list.add(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;와일드카드 사용절에서는 상위제한와일드카드와 하위제한와일드카드를 각각 언제 사용할지 설명하였다.
&lt;code&gt;The Guidelines for Wildcard Use section provides guidance on when to use upper bounded wildcards and when to use lower bounded wildcards.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(12) Java Generics: 상위 제한된 와일드카드(Upper Bounded Wildcards)</title>
      <link>http://durtchrt.github.io/blog/java/generics/12/</link>
      <pubDate>Mon, 07 Nov 2016 13:00:42 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/12/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/unboundedWildcards.html&#34;&gt;원문링크&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;제한없는-와일드카드-unbounded-wildcards&#34;&gt;제한없는 와일드카드 &lt;code&gt;Unbounded Wildcards&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;제한없는 와일드카드 타입은 와일드카드 문자(&amp;lsquo;?&amp;rsquo;)만 사용한것이다. 예를 들면 List&amp;lt;?&amp;gt;와 같다. List&amp;lt;?&amp;gt;의 ?는 List의 &amp;lsquo;알수없는 타입(unkown type)&amp;lsquo;이라고 부른다. 아래 두개의 시나리오는 제한없는 와일드카드가 유용한 접근법이다.
&lt;code&gt;The unbounded wildcard type is specified using the wildcard character (?), for example, List&amp;lt;?&amp;gt;. This is called a list of unknown type. There are two scenarios where an unbounded wildcard is a useful approach:&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Object 클래스에서 제공하는 기능(메서드)을 사용하도록 메서드를 구현할 때.
&lt;code&gt;- If you are writing a method that can be implemented using functionality provided in the Object class.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;코드가 generic 클래스에서 메서드가 타입매개변수에 의존적이지 않게 작성하고 싶을 때.(예 List.size나 List.clear). 사실, Class&amp;lt;T&amp;gt; 클래스는 범위없는 와일드카드를 자주 사용한다.(Class&amp;lt;T&amp;gt;의 메서드가 T에 의존적으로 동작하지 않게 만들기 위해)
&lt;code&gt;- When the code is using methods in the generic class that don&#39;t depend on the type parameter. For example, List.size or List.clear. In fact, Class&amp;lt;?&amp;gt; is so often used because most of the methods in Class&amp;lt;T&amp;gt; do not depend on T.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;printList 메서드를 살펴보자.
&lt;code&gt;Consider the following method, printList:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void printList(List&amp;lt;Object&amp;gt; list) {
    for (Object elem : list)
        System.out.println(elem + &amp;quot; &amp;quot;); // elem.toString() 자동으로 호출됨.
    System.out.println();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;printList는 List가 가진 객체가 어떤 타입이든간에 상관없이 print하고 싶어한다. 하지만 List 객체는 Object 타입의 객체만 출력할 수 있다. (참조:&lt;a href=&#34;../8&#34;&gt;제네릭스, 상속, 서브타입&lt;/a&gt;) List&amp;lt;Object&amp;gt;는 List&amp;lt;Integer&amp;gt;, List&amp;lt;String&amp;gt;, List&amp;lt;Double&amp;gt;을 출력할 수 없다. 왜냐하면 List&amp;lt;Object&amp;gt; 타입의 stub type(스텁타입 용어 아시는분 공유 부탁요 ㅠㅠ)이 아니다. 아래는 List&amp;lt;?&amp;gt;를 사용해서 generic 메서드인 printList를 작성한 예이다..&lt;/p&gt;

&lt;p&gt;&lt;code&gt;The goal of printList is to print a list of any type, but it fails to achieve that goal — it prints only a list of Object instances; it cannot print List&amp;lt;Integer&amp;gt;, List&amp;lt;String&amp;gt;, List&amp;lt;Double&amp;gt;, and so on, because they are not subtypes of List&amp;lt;Object&amp;gt;. To write a generic printList method, use List&amp;lt;?&amp;gt;:&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(역자 추가 - 위의 예가 설명하는 코드 - 컴파일 에러 발생)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Integer&amp;gt; integerList = Arrays.asList(1,2);
printList(integerList);   // 컴파일 에러
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void printList(List&amp;lt;?&amp;gt; list) {
    for (Object elem: list)
        System.out.print(elem + &amp;quot; &amp;quot;);
    System.out.println();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아무 타입을 A로 지칭했을때, List&amp;lt;?&amp;gt;의 서브타입은 List&amp;lt;A&amp;gt;이 성립이 되기 때문에, printList 메서드가 모든 타입을 대상으로 print할 수 있다.
&lt;code&gt;Because for any concrete type A, List&amp;lt;A&amp;gt; is a subtype of List&amp;lt;?&amp;gt;, you can use printList to print a list of any type:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Integer&amp;gt; li = Arrays.asList(1, 2, 3);
List&amp;lt;String&amp;gt;  ls = Arrays.asList(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;);
printList(li);
printList(ls);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고: Arrays.asList 메서드는 범위없는 와일드카드를 사용해서 구현되었다. Arrays.asList라는 static 팩토리 메서드는 배열을 구체화하여 변경하고(요소들의 공통 타입을 타입추론)  고정된 사이즈의 리스트를 반환한다.
&lt;code&gt;Note: The Arrays.asList method is used in examples throughout this lesson. This static factory method converts the specified array and returns a fixed-size list.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(중요!)List&lt;Object&gt;와 List&amp;lt;?&amp;gt;과 다르다. List&lt;Object&gt;에 Object 타입이나 Object의 서브타입을 insert할 수 있다. 하지만 List&amp;lt;?&amp;gt;에는 null만 insert할 수 있다.(하고자하는 말이 무언지 이해가 안된다;;;) 와일드카드 사용 섹션은은 상황별 어떤 와일드카드를 사용할지 결정에 대한 가이드라인을 제공한다.
&lt;code&gt;It&#39;s important to note that List&amp;lt;Object&amp;gt; and List&amp;lt;?&amp;gt; are not the same. You can insert an Object, or any subtype of Object, into a List&amp;lt;Object&amp;gt;. But you can only insert null into a List&amp;lt;?&amp;gt;. The Guidelines for Wildcard Use section has more information on how to determine what kind of wildcard, if any, should be used in a given situation.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(9) Java Generics: 타입추론(Type Inference)</title>
      <link>http://durtchrt.github.io/blog/java/generics/9/</link>
      <pubDate>Sat, 05 Nov 2016 18:23:01 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/9/</guid>
      <description>

&lt;p&gt;용어&lt;/p&gt;

&lt;p&gt;statement: 문장으로 해석하면 오해의 여지가 있어서 statement 영문 그대로 작성한다. 컴퓨터 프로그래밍에서는 statement를 독립적인 요소의 최소 단위. &lt;a href=&#34;https://en.wikipedia.org/wiki/Statement_(computer_science)&#34;&gt;영문위키&lt;/a&gt;의 중간을 보면 Kinds of statements 파트에 Simple statments, Compound statements 부분의 코드를 보면 느낌이 온다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html&#34;&gt;원문링크&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;타입추론-type-inference&#34;&gt;타입추론 &lt;code&gt;Type Inference&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;타입추론은 메서드를 호출하는 코드에서 타입인자가 정의한대로 제대로 쓰였는지 살펴보는 컴파일러의 능력이다. 타입추론은 인자의 타입을 확인하고 만약 사용가능하다면, 해당 타입을 할당하거나 리턴될 것이다. 결국 타입추론은 모든 인자에 동작해서 가장 구체적인 타입을 찾는 것을 시도한다.(뭔가 말이 어렵다;;)
&lt;code&gt;[Type inference is a Java compiler&#39;s ability to look at each method invocation and corresponding declaration to determine the type argument (or arguments) that make the invocation applicable.] The inference algorithm determines the types of the arguments and, if available, the type that the result is being assigned, or returned. Finally, the inference algorithm tries to find the most specific type that works with all of the arguments.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;~&lt;del&gt;아래의 예는 마지막 지점을 설명한다.&lt;/del&gt;~ 타입추론은 두번째 인자가 전달될 때 pick 메서드는 Serializable로 결정되어집니다.
(역주: pick의 두 인자 a1, a2는 타입인자로 String과 ArrayList를 전달 받는다. 둘의 공통점은 Serializable 인터페이스를 구현한 클래스라는 것이다. 인자들이 같은 타입이 아니면 각각 인자들의 타입에서 공통으로 쓰는 슈퍼 타입으로 추론. 코드레벨로 작성한거라 추론이라하긴 뭐한데&amp;hellip; 일단 진행.)
&lt;code&gt;To illustrate this last point, in the following example, inference determines that the second argument being passed to the pick method is of type Serializable:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static &amp;lt;T&amp;gt; T pick(T a1, T a2) { return a2; }
Serializable s = pick(&amp;quot;d&amp;quot;, new ArrayList&amp;lt;String&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;타입추론과-generic-메서드-type-inference-and-generic-methods&#34;&gt;타입추론과 Generic 메서드 &lt;code&gt;Type Inference and Generic Methods&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Generic 메서드는 꺽쇠안에 타입을 작성하지 않고(빈타입인자) 메서드를 호출하면 타입추론을 보여준다. BoxDemo 예를 보시오. 이 예는 Box 클래스를 필요로합니다.
&lt;code&gt;Generic Methods introduced you to type inference, which enables you to invoke a generic method as you would an ordinary method, without specifying a type between angle brackets. Consider the following example, BoxDemo, which requires the Box class:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BoxDemo {

  public static &amp;lt;U&amp;gt; void addBox(U u, 
      java.util.List&amp;lt;Box&amp;lt;U&amp;gt;&amp;gt; boxes) {
    Box&amp;lt;U&amp;gt; box = new Box&amp;lt;&amp;gt;();
    box.set(u);
    boxes.add(box);
  }

  public static &amp;lt;U&amp;gt; void outputBoxes(java.util.List&amp;lt;Box&amp;lt;U&amp;gt;&amp;gt; boxes) {
    int counter = 0;
    for (Box&amp;lt;U&amp;gt; box: boxes) {
      U boxContents = box.get();
      System.out.println(&amp;quot;Box #&amp;quot; + counter + &amp;quot; contains [&amp;quot; +
             boxContents.toString() + &amp;quot;]&amp;quot;);
      counter++;
    }
  }

  public static void main(String[] args) {
    java.util.ArrayList&amp;lt;Box&amp;lt;Integer&amp;gt;&amp;gt; listOfIntegerBoxes =
      new java.util.ArrayList&amp;lt;&amp;gt;();
    BoxDemo.&amp;lt;Integer&amp;gt;addBox(Integer.valueOf(10), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(30), listOfIntegerBoxes);
    BoxDemo.outputBoxes(listOfIntegerBoxes);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 예제는 아래와 같은 결과를 출력한다.
&lt;code&gt;The following is the output from this example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Box #0 contains [10]
Box #1 contains [20]
Box #2 contains [30]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generic 메서드인 addbox는 U라는 타입매개변수가 선언되어있다. 일반적으로, 자바컴파일러는 generic 메서드 호출하는 코드를 보고 타입파라메터를 추론할 수 있다. 그 결과, 대부분 타입을 꼭 명시하지 않아도 된다. 예를 들어 addBox라는 generic 메서드를 호출할때, 아래 코드처럼 구체적인 타입 매개변수를 줄 수 있다.
&lt;code&gt;The generic method addBox defines one type parameter named U. Generally, a Java compiler can infer the type parameters of a generic method call. Consequently, in most cases, you do not have to specify them. For example, to invoke the generic method addBox, you can specify the type parameter with a type witness as follows:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BoxDemo.&amp;lt;Integer&amp;gt;addBox(Integer.valueOf(10), listOfIntegerBoxes);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 코드 대신 아래 코드처럼 타입 정보를 제공하지 않고 코드를 작성해도, 자바 컴파일러는 타입매개변수가 Integer라고 (메서드의 인자들로부터) 자동으로 추론을 한다.
&lt;code&gt;Alternatively, if you omit the type witness,a Java compiler automatically infers (from the method&#39;s arguments) that the type parameter is Integer:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;타입추론과-generic-객체-type-inference-and-instantiation-of-generic-classes&#34;&gt;타입추론과 generic 객체  &lt;code&gt;Type Inference and Instantiation of Generic Classes&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic 클래스를 생성자를 통해 객체를 생성할 때 타입인자 대신 빈타입파라미터(&amp;lt;&amp;gt;)를 사용할때 자바 컴파일러는 코드 문맥으로부터 타입인자를 유추할 수 있다. 비공식적으로 한쌍의 꺽쇠(&amp;lt;&amp;gt;)는 다이아몬드라고 부른다.
&amp;lsquo;You can replace the type arguments required to invoke the constructor of a generic class with an empty set of type parameters (&amp;lt;&amp;gt;) as long as the compiler can infer the type arguments from the context. This pair of angle brackets is informally called the diamond.&amp;rsquo;&lt;/p&gt;

&lt;p&gt;예를 들어 변수 선언을 보자.
&lt;code&gt;For example, consider the following variable declaration:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; myMap = new HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(위의 예제 처럼)generic 클래스의 생성자에 타입매개변수화한 생성자 대신 (아래 예제 처럼)&amp;lt;&amp;gt;를 사용할 수 있다.
&lt;code&gt;You can substitute the parameterized type of the constructor with an empty set of type parameters (&amp;lt;&amp;gt;):&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; myMap = new HashMap&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generic 클래스를 객체화할 때 타입추론을 시키려면 반드시 다이아몬드 연산자를 사용하십시오. 아래의 예를 보면 컴파일러는 Hash맵을 raw타입으로 인식해서 경고를 한다.(선언문의 Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;을 보고 할당문의 HashMap의 생성자는 타입추론을 하지 않는다. 그냥 raw 타입이 된다. )
&lt;code&gt;Note that to take advantage of type inference during generic class instantiation, you must use the diamond. In the following example, the compiler generates an unchecked conversion warning because the HashMap() constructor refers to the HashMap raw type, not the Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; type:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; myMap = new HashMap(); // unchecked conversion warning
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;타입추론과-generic-타입의-generic-생성자-그리고-non-generic-클래스가-type-inference-and-generic-constructors-of-generic-and-non-generic-classes&#34;&gt;타입추론과 generic 타입의 Generic 생성자 그리고 Non-Generic 클래스가 &lt;code&gt;Type Inference and Generic Constructors of Generic and Non-Generic Classes&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic 클래스와 non-generic 클래스는 둘다 generic(일반 타입매개변수를 선언)이 될 수 있다. 아래 예를 보자
&lt;code&gt;Note that constructors can be generic (in other words, declare their own formal type parameters) in both generic and non-generic classes. Consider the following example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MyClass&amp;lt;X&amp;gt; {
  &amp;lt;T&amp;gt; MyClass(T t) {
    // ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MyClass 클래스의 객체 생성을 살펴보면
&lt;code&gt;Consider the following instantiation of the class MyClass:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new MyClass&amp;lt;Integer&amp;gt;(&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 코드는 MyClass&amp;lt;Integer&amp;gt;라는 매개변수화된 타입의 객체를 생성하는 statement이다. 이 statement는 generic 클래스인 MyClass&amp;lt;X&amp;gt;의 타입매개변수의 형식을 Integer 타입으로 구체화하도록 명시한다. 중요한점은 generic 클래스의 생성자는 T라는 형식 타입매개변수를 포함해야한다. 컴파일러는 generic 클래스의 생성자의 형식 파라메터 T를 String 타입으로 추론한다.(왜냐하면 생성자의 매개변수는 String 타입의 객체이기 때문이다.)
&lt;code&gt;This statement creates an instance of the parameterized type MyClass&amp;lt;Integer&amp;gt;; the statement explicitly specifies the type Integer for the formal type parameter, X, of the generic class MyClass&amp;lt;X&amp;gt;. Note that the constructor for this generic class contains a formal type parameter, T. The compiler infers the type String for the formal type parameter, T, of the constructor of this generic class (because the actual parameter of this constructor is a String object).&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(역자 - 번역하다가 도통 뭔말인지 몰라서 코딩해봄.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Main {
	public static void main(String[] args) {
		MyClass&amp;lt;Integer&amp;gt; a = new MyClass&amp;lt;&amp;gt;(&amp;quot;&amp;quot;);
		System.out.println(a.x.getClass().getSimpleName());
	}
}

class MyClass&amp;lt;X&amp;gt; {
	X x;
	&amp;lt;T&amp;gt; MyClass(T t) {
		this.x = (X) t;
	}
}
// 런타임 에러 발생되는 코드
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(역자)MyClass의 생성자의 T라는 타입매개변수만 적으면 컴파일이 안된다. 생성자 앞에 &amp;lt;T&amp;gt;를 넣어줘야 컴파일이 되는데 요놈을 형식타입매개변수가로 지칭하는 것으로 보인다. 클래스에 적어준 &amp;lt;X&amp;gt;랑은 다름을 주의. 아직은 딱히 어느 상황에 써야할지 잘 모르겠다&amp;hellip;.&lt;/p&gt;

&lt;p&gt;generic 메서드처럼 generic 생성자에서 실제 타입파라메터를 추론하는 능력은 Java SE 7이전 컴파일러에서 릴리즈되었다.(역자??? 이부분이 이해가 안감) 하지만 Java SE 7 이후 컴파일러는 다이아몬드연산자(&amp;lt;&amp;gt;)를 사용해서 generic 클래스를 객체 생성할 때 실제 타입매개변수를 추론할 수 있습니다. 아래의 예를 보세요.
&lt;code&gt;Compilers from releases prior to Java SE 7 are able to infer the actual type parameters of generic constructors, similar to generic methods. However, compilers in Java SE 7 and later can infer the actual type parameters of the generic class being instantiated if you use the diamond (&amp;lt;&amp;gt;). Consider the following example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MyClass&amp;lt;Integer&amp;gt; myObject = new MyClass&amp;lt;&amp;gt;(&amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 예제는 컴파일러가 generic 클래스 MyClass&amp;lt;X&amp;gt;의 형식타입 파라메터 X를 Integer 타입으로 추론한다. 컴파일러는 generic 클래스의 생성자의 형식매개변수 T에 String 타입을 추론한다.
&lt;code&gt;In this example, the compiler infers the type Integer for the formal type parameter, X, of the generic class MyClass&amp;lt;X&amp;gt;. It infers the type String for the formal type parameter, T, of the constructor of this generic class.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;중요: 타입추론 알고리즘은 인자, 대상 타입, 명백히 기대되는 리턴 타입만 사용한다. 추론 알고리즘은 프로그램에서 나중에 결과를 사용하지 않는다. (역자: 내용이 명확히 안들어옴.)
&lt;code&gt;Note: It is important to note that the inference algorithm uses only invocation arguments, target types, and possibly an obvious expected return type to infer types. The inference algorithm does not use results from later in the program.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;target-types&#34;&gt;&lt;code&gt;Target Types&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;자바 컴파일러는 generic 메서드 호출에 타입매개변수를 추론하는 target typing은 장점을 가진다. target type 표현식은 자바 컴파일러가 기대하는 데이터 타입이다. Collection.emptyList 메서드를 살펴보면 아래와 같이 선언되어있다.
&lt;code&gt;The Java compiler takes advantage of target typing to infer the type parameters of a generic method invocation. [The target type of an expression is the data type that the Java compiler expects depending on where the expression appears.] Consider the method Collections.emptyList, which is declared as follows:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; emptyList();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;할당문을 살펴보면:
&lt;code&gt;Consider the following assignment statement:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; listOne = Collections.emptyList();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 statement는 List&lt;String&gt;의 객체를 기대한다. 이 데이터 타입이 target type이다. 왜냐하면 emptyList 메서드는 List&lt;T&gt; 타입의 값을 리턴한다. 컴파일러는 타입인자는 반드시 String 타입의 값일 것이라고 추론한다. 이는 Java SE 7 이상에서 동작한다. 추론 대신에 아래의 예처럼 타입매개변수 T의 타입인자값을 특정 타입값을 명시할 수 있다.
&lt;code&gt;This statement is expecting an instance of List&amp;lt;String&amp;gt;; this data type is the target type. Because the method emptyList returns a value of type List&amp;lt;T&amp;gt;, the compiler infers that the type argument T must be the value String. This works in both Java SE 7 and 8. Alternatively, you could use a type witness and specify the value of T as follows:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; listOne = Collections.&amp;lt;String&amp;gt;emptyList();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;하지만 위의 코드 문맥상 target type이 필요치 않다. 코드문맥상 target type이 필요한 예를 아래 코드를 보며 살펴보자.
&lt;code&gt;However, this is not necessary in this context. It was necessary in other contexts, though. Consider the following method:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void processStringList(List&amp;lt;String&amp;gt; stringList) {
    // process stringList
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빈리스트와 함께 processStringList 메서드를 호출한다고 가정하자. Java SE 7에서는 아래의 코드는 컴파일 되지 않는다.
&lt;code&gt;Suppose you want to invoke the method processStringList with an empty list. In Java SE 7, the following statement does not compile:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;processStringList(Collections.emptyList());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java SE 7 컴파일러는 아래의 에러메세지를 던진다.
&lt;code&gt;The Java SE 7 compiler generates an error message similar to the following:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shelll&#34;&gt;List&amp;lt;Object&amp;gt; cannot be converted to List&amp;lt;String&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;컴파일러는 T의 타입인자가 필요한데 T는 target type을 주지 않으면 Object이다. 결국, Collection.emptyList에 타입인자는 List&lt;Objec&gt; 타입이다. 그러므로 Java SE 7은 반드시 아래의 예처럼 타입인자를 명확히 알려줘야한다.
&lt;code&gt;The compiler requires a value for the type argument T so it starts with the value Object. Consequently, the invocation of Collections.emptyList returns a value of type List&amp;lt;Object&amp;gt;, which is incompatible with the method processStringList. Thus, in Java SE 7, you must specify the value of the value of the type argument as follows:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;processStringList(Collections.&amp;lt;String&amp;gt;emptyList());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java SE 8에서는 더이상 필요치 않다. 이 표기법은 target type은 메서드 인자를 포함해서 확장했다 (아래 예처럼 processStringList 메서드에 인자를 넣는것처럼). 이런경우, processStringList는 List&lt;String&gt; 타입의 인자를 필요로한다. Collections.emptyList 메서드는 List&lt;T&gt; 타입의 값을 리턴한다. 그럼 List&lt;String&gt;의 target type을 사용하면 컴파일러는 T의 타입인자를 String으로 추론하다. 따라서 Java SE 8은 아래의 문장이 컴파일된다.
&lt;code&gt;This is no longer necessary in Java SE 8. The notion of what is a target type has been expanded to include method arguments, such as the argument to the method processStringList. In this case, processStringList requires an argument of type List&amp;lt;String&amp;gt;. The method Collections.emptyList returns a value of List&amp;lt;T&amp;gt;, so using the target type of List&amp;lt;String&amp;gt;, the compiler infers that the type argument T has a value of String. Thus, in Java SE 8, the following statement compiles:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;processStringList(Collections.emptyList());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 많은 정보는 &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&#34;&gt;람다표현식&lt;/a&gt;에서 &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#target-typing&#34;&gt;Target Typing&lt;/a&gt;을 보세요.
&lt;code&gt;See Target Typing in Lambda Expressions for more information.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(8) Java Generics: 제네릭스, 상속, 서브타입 (Generics, Inheritance, and Subtypes)</title>
      <link>http://durtchrt.github.io/blog/java/generics/8/</link>
      <pubDate>Sat, 05 Nov 2016 08:48:42 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/8/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/inheritance.html&#34;&gt;원문링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;용어
메서드 시그니처(method signature): 메서들간에 개성 주는것으로 자바 컴파일러인지 메서드 시그니처를 기준으로 오버로딩을 한다.  자바에서는 메서드명, 파라미터 갯수, 파라미터 타입, 파라미터 순서(자바에서는 리턴타입은 시그니처가 아니다.) - 파라미터명도 시그니처인지는 아리까리하다. 메서드 오버로딩를 생각하면 맞는거 같은데&amp;hellip; 좀더 생각해보고 내용 수정 예정
콘크리트 타입, 구현타입(concrete type): 자바에서는 타입들중 interface, abstract class를 제외하고 남은 class를 concrete 타입으로 이해하면 될 듯.&lt;a href=&#34;http://dreuarchive.cra.org/2002/heise/typeComp.html&#34;&gt;참고링크 - 영문: 번역 예정&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;제네릭스-상속-서브타입-generics-inheritance-and-subtypes&#34;&gt;제네릭스, 상속, 서브타입 &lt;code&gt;Generics, Inheritance, and Subtypes&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;타입간 호환이된다면 특정 타입의 객체를 다른 타입에 할당이 가능합니다. 아래의 코드처럼 Object 타입은 Integer의 슈퍼타입중 하나이기 때문에 Integer 타입인 someInteger의 객체가 Object 타입인 someObject에 할당이 가능합니다.
&lt;code&gt;As you already know, it is possible to assign an object of one type to an object of another type provided that the types are compatible. For example, you can assign an Integer to an Object, since Object is one of Integer&#39;s supertypes:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object someObject = new Object();
Integer someInteger = new Integer(10);
someObject = someInteger;   // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;객체지향 이론에서는 이를 &amp;ldquo;is a&amp;rdquo;(~는 ~이다) 관계라고 부른다. Integer는 Object의 &amp;ldquo;is a&amp;rdquo;이므로 Integer 타입을 Object 타입에 할당이 가능하다. 하지만 Integer는 Number 타입에 &amp;ldquo;is a&amp;rdquo; 관계이다. 그러므로 아래의 코드는 잘 동작한다.
&lt;code&gt;In object-oriented terminology, this is called an &amp;quot;is a&amp;quot; relationship. Since an Integer is a kind of Object, the assignment is allowed. But Integer is also a kind of Number, so the following code is valid as well:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void someMethod(Number n) { /* ... */ }

someMethod(new Integer(10));   // OK
someMethod(new Double(10.1));   // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 룰은 generics도 마찬가지다. generic 타입을 호출할때, 타입인자가 Number 타입과 호환되는 &amp;ldquo;is a&amp;rdquo; 관계라면 Number 타입으로 타입인자를 전달한다.
&lt;code&gt;The same is also true with generics. You can perform a generic type invocation, passing Number as its type argument, and any subsequent invocation of add will be allowed if the argument is compatible with Number:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Number&amp;gt; box = new Box&amp;lt;Number&amp;gt;();
box.add(new Integer(10));   // OK
box.add(new Double(10.1));  // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래의 메서드를 살펴보자
&lt;code&gt;Now consider the following method:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void boxTest(Box&amp;lt;Number&amp;gt; n) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어떤 타입을 인자로 받을수 있을까? 메서드의 시그니처를 보면, Box&lt;Number&gt; 타입의 객체 하나를 인자로 받는 메서드이다. 그럼, Box&amp;lt;Integer&amp;gt;나 Box&amp;lt;Double&amp;gt;을 인자로 넣을수 있을까? 아니다! 왜냐하면 Box&amp;lt;Integer&amp;gt;, Box&amp;lt;Double&amp;gt;는 Box&amp;lt;Number&amp;gt;의 서브타입이 아니기 때문이다. (자바에서는 꺽쇠안에 Number 타입은 컴파일러가 is a관계를 파악하지 못한다. - 공변성, 반공변성쪽 내용 참조하면 좋은데 자바는 이를 지원 못함. 스칼라 언어 참조. 눈이 공부하다보면 팽팽 돔.)
&lt;code&gt;What type of argument does it accept? By looking at its signature, you can see that it accepts a single argument whose type is Box&amp;lt;Number&amp;gt;. But what does that mean? Are you allowed to pass in Box&amp;lt;Integer&amp;gt; or Box&amp;lt;Double&amp;gt;, as you might expect? The answer is &amp;quot;no&amp;quot;, because Box&amp;lt;Integer&amp;gt; and Box&amp;lt;Double&amp;gt; are not subtypes of Box&amp;lt;Number&amp;gt;.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이것은 generics를 공부할때 흔히 겪는 문제이다. 하지만 generic을 공부할때 중요한 컨셉이다.
&lt;code&gt;This is a common misunderstanding when it comes to programming with generics, but it is an important concept to learn.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../8-1.gif&#34; alt=&#34;Box&amp;lt;Integer&amp;gt; is not a subtype of Box&amp;lt;Number&amp;gt; even though Integer is a subtype of Number.&#34; /&gt;
&lt;br&gt;
Number의 서브타입인 Integer를 가진 Box&amp;lt;Integer&amp;gt;는 Box&amp;lt;Number&amp;gt;의 서브타입이 아니다.
&lt;code&gt;Box&amp;lt;Integer&amp;gt; is not a subtype of Box&amp;lt;Number&amp;gt; even though Integer is a subtype of Number.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;중요:  A와 B 두 구현타입을 제공할때(예를 들어 Number와 Integer),A와 B가 &amp;ldquo;is a&amp;rdquo; 관계가 있든 상관없이  MyClass&amp;lt;A&amp;gt;는 MyClass&amp;lt;B&amp;gt;와 더 이상 관계가 형성되지 않는다.
&lt;code&gt;Note: Given two concrete types A and B (for example, Number and Integer), MyClass&amp;lt;A&amp;gt; has no relationship to MyClass&amp;lt;B&amp;gt;, regardless of whether or not A and B are related. The common parent of MyClass&amp;lt;A&amp;gt; and MyClass&amp;lt;B&amp;gt; is Object.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;두 generic 클래스들간에 서브타입&lt;strong&gt;처럼&lt;/strong&gt; 타입매개변수가 관련있다라는 정보를 주려면(컴파일러에게), 와일드카드와 서브타이핑 항목을 보라
&lt;code&gt;For information on how to create a subtype-like relationship between two generic classes when the type parameters are related, see Wildcards and Subtyping.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;제네릭-클래스와-서브타이핑-generic-classes-and-subtyping&#34;&gt;제네릭 클래스와 서브타이핑 &lt;code&gt;Generic Classes and Subtyping&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic 클래스 상속 또는 generic 인터페이스 만들 때, 만드는 타입을 상속(또는 구현) 받은 부모  generic 타입의 서브 generic 타입(자식타입)으로 두 타입간에 관계(is a)를 만들수 있다.
&lt;code&gt;You can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the extends and implements clauses.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Collections 클래스들 사용할 때 예를 들면,  ArrayList&amp;lt;E&amp;gt;는 List&amp;lt;E&amp;gt;를 구현했고 List&amp;lt;E&amp;gt;는 Collection을 상속했다. 그러므로 ArrayList&amp;lt;String&amp;gt;은 List&amp;lt;String&amp;gt;의 서브타입이고 List&amp;lt;String&amp;gt;은 Collection&amp;lt;String&amp;gt;의 서브타입니다. 그럼 &amp;lt;String&amp;gt;이라는 형식인자를 변경하지 않으면 타입간 서브타이핑 관계가 유지된다.
&lt;code&gt;Using the Collections classes as an example, ArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, and List&amp;lt;E&amp;gt; extends Collection&amp;lt;E&amp;gt;. So ArrayList&amp;lt;String&amp;gt; is a subtype of List&amp;lt;String&amp;gt;, which is a subtype of Collection&amp;lt;String&amp;gt;. So long as you do not vary the type argument, the subtyping relationship is preserved between the types.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../8-2.gif&#34; alt=&#34;A sample Collections hierarchy&#34; /&gt;
&lt;br&gt;
콜렉션들간의 계층구조 예&lt;code&gt;sample Collections hierarchy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;PayloadList라는 인터페이스를 정의할 때 P라는 generic 타입을 메서드의 파라메터로 사용한다고했을때, 아래 코드와 같을 것이다.
&lt;code&gt;Now imagine we want to define our own list interface, PayloadList, that associates an optional value of generic type P with each element. Its declaration might look like:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface PayloadList&amp;lt;E,P&amp;gt; extends List&amp;lt;E&amp;gt; {
  void setPayload(int index, P val);
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;List&amp;lt;String&amp;gt;의 서브타입이면서 PayloadList가 타입인자로 전달할수 있는 것은 아래처럼 다양하게 볼수 있다.(일부임.)
&lt;code&gt;The following parameterizations of PayloadList are subtypes of List&amp;lt;String&amp;gt;:&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PayloadList&lt;String,String&gt;&lt;/li&gt;
&lt;li&gt;PayloadList&lt;String,Integer&gt;&lt;/li&gt;
&lt;li&gt;PayloadList&lt;String,Exception&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../8-3.gif&#34; alt=&#34;A sample PayloadList hierarchy&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(7) Java Generics: Generic 메서드와 제한된 타입 매개변수 (Generic Methods and Bounded Type Parameters)</title>
      <link>http://durtchrt.github.io/blog/java/generics/7/</link>
      <pubDate>Sat, 05 Nov 2016 08:24:47 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/7/</guid>
      <description>

&lt;h3 id=&#34;generic-메서드와-제한된-타입-매개변수-generic-methods-and-bounded-type-parameters&#34;&gt;Generic 메서드와 제한된 타입 매개변수 &lt;code&gt;Generic Methods and Bounded Type Parameters&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;제한된 타입 매개변수는 generic 알고리즘들을 구현할때 핵심이된다. 아래의 예는 두번째 인자보다 큰 값이 첫번째 인자인 배열에 몇개가 있는지 세는 메서드이다.
&lt;code&gt;Bounded type parameters are key to the implementation of generic algorithms. Consider the following method that counts the number of elements in an array T[] that are greater than a specified element elem.&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T&amp;gt; int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e &amp;gt; elem)  // compiler error
            ++count;
    return count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;메서드 구현은 간단하지만, &amp;lsquo;&amp;gt;&amp;rsquo; 연산자가 기본형(short, int, double, long, float, byte, char)에만 동작이 허용되기 때문이다. &amp;lsquo;&amp;gt;&amp;rsquo; 연산자는 객체간 비교에는 사용할 수 없습니다. 비교연산자 대신 Comparable&lt;T&gt;  인터페이스를 사용해서 문제를 해결할 수 있습니다.
&lt;code&gt;The implementation of the method is straightforward, but it does not compile because the greater than operator (&amp;gt;) applies only to primitive types such as short, int, double, long, float, byte, and char. You cannot use the &amp;gt; operator to compare objects. To fix the problem, use a type parameter bounded by the Comparable&amp;lt;T&amp;gt; interface:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Comparable&amp;lt;T&amp;gt; {
    public int compareTo(T o);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comparable 인터페이스가 적용된 결과 코드는 아래의 코드처럼 될 것입니다. &lt;code&gt;The resulting code will be:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e.compareTo(elem) &amp;gt; 0)
            ++count;
    return count;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>