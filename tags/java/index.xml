<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ê°œë°œ ì €ì¥ì†Œ</title>
    <link>http://durtchrt.github.io/blog/tags/java/index.xml</link>
    <description>Recent content on ê°œë°œ ì €ì¥ì†Œ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>durtchrt</copyright>
    <atom:link href="http://durtchrt.github.io/blog/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[ë°œë²ˆì—­]The Javaâ„¢ Tutorials - 2-2. Pausing Execution with Sleep</title>
      <link>http://durtchrt.github.io/blog/java/concurrency/5/</link>
      <pubDate>Thu, 24 Nov 2016 15:00:35 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/concurrency/5/</guid>
      <description>

&lt;h2 id=&#34;ì›ë¬¸ë§í¬-http-docs-oracle-com-javase-tutorial-essential-concurrency-sleep-html&#34;&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/concurrency/sleep.html&#34;&gt;ì›ë¬¸ë§í¬&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;sleepìœ¼ë¡œ-ì‹¤í–‰-ì¤‘ì§€í•˜ê¸°&#34;&gt;Sleepìœ¼ë¡œ ì‹¤í–‰ ì¤‘ì§€í•˜ê¸°&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Pausing Execution with Sleep&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Thread.sleepì€ í˜„ì¬ ì‹¤í–‰í•˜ëŠ” ì“°ë ˆë“œë¥¼ ì •í•´ì§„ ì‹œê°„ë§Œí¼ ì‹¤í–‰ì„ ì¤‘ì§€í•œë‹¤. ì»´í“¨í„°ì—ì„œ ë™ì‘í•˜ëŠ” ì–´í”Œë¦¬ì¼€ì´ì…˜ì˜ í”„ë¡œì„¸ì„œì˜ ì‹œê°„ì„ íš¨ìœ¨ì ìœ¼ë¡œ ë§Œë“ ë‹¤. sleep ë©”ì„œë“œëŠ” ì•„ë˜ ì˜ˆì œì²˜ëŸ¼ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë“¤ê°„ì— ë™ì¼í•œ ê°„ê²©(4ì´ˆ)ìœ¼ë¡œ ì‹¤í–‰í•˜ê²Œ í•˜ëŠ”ë° ì‚¬ìš©í•˜ê±°ë‚˜ ë‹¤ìŒ ì„¹ì…˜ì— SimpleThreadsì²˜ëŸ¼ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¥¼ ê¸°ë‹¤ë¦¬ê²Œí•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;Thread.sleep causes the current thread to suspend execution for a specified period. This is an efficient means of making processor time available to the other threads of an application or other applications that might be running on a computer system. The sleep method can also be used for pacing, as shown in the example that follows, and waiting for another thread with duties that are understood to have time requirements, as with the SimpleThreads example in a later section.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ë‘ê°€ì§€ ì˜¤ë²„ë¡œë“œ ë²„ì „ sleep ì œê³µ: í•˜ë‚˜ëŠ” sleep ì‹œê°„ì„ ë°€ë¦¬ì´ˆ(ms)ë¡œ, ë‹¤ë¥¸ í•˜ë‚˜ëŠ” ë‚˜ë…¸ì´ˆ(ns)ë¡œ ëª…ì‹œí–‡ë‹¤. í•˜ì§€ë§Œ sleepë˜ëŠ” ì‹œê°„ì€ ì™„ë²½í•˜ê²ŒëŠ” ë³´ì¥ë˜ì§€ ì•ŠëŠ”ë‹¤. ì™œëƒí•˜ë©´ OSë‹¨ì—ì„œ ì œê³µí•˜ëŠ” ê¸°ëŠ¥ ì œì•½ ë•Œë¬¸ì´ë‹¤. ë˜í•œ sleep ì‹œê°„ì€ ë‚˜ì¤‘ì— ë‚˜ì˜¬ ì„¹ì…˜ì— ë³¼ ìˆ˜ ìˆë“¯ì´ ì¸í„°ëŸ½íŠ¸ì— ì˜í•´ ì¢…ë£Œë ìˆ˜ ìˆìŠµë‹ˆë‹¤.  ì–´ì¨Œë“ , sleepì„ í˜¸ì¶œí•´ì„œ ì„¤ì •í•œ ì‹œê°„ì„ ì™„ë²½íˆ ìŠ¤ë ˆë“œê°€ ì •ì§€í•œë‹¤ê³  í™•ì‹  í•  ìˆ˜ ì—†ë‹¤.
&lt;code&gt;Two overloaded versions of sleep are provided: one that specifies the sleep time to the millisecond and one that specifies the sleep time to the nanosecond. However, these sleep times are not guaranteed to be precise, because they are limited by the facilities provided by the underlying OS. Also, the sleep period can be terminated by interrupts, as we&#39;ll see in a later section. In any case, you cannot assume that invoking sleep will suspend the thread for precisely the time period specified.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;SleepMessage ì˜ˆì œëŠ” 4ì´ˆ ê°„ê²©ìœ¼ë¡œ ë©”ì„¸ì§€ë¥¼ í”„ë¦°íŠ¸í•˜ë ¤ sleep ë©”ì„œë“œë¥¼ ì‚¬ìš©í•œë‹¤.
&lt;code&gt;The SleepMessages example uses sleep to print messages at four-second intervals:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SleepMessages {
    public static void main(String args[])
        throws InterruptedException {
        String importantInfo[] = {
            &amp;quot;Mares eat oats&amp;quot;,
            &amp;quot;Does eat oats&amp;quot;,
            &amp;quot;Little lambs eat ivy&amp;quot;,
            &amp;quot;A kid will eat ivy too&amp;quot;
        };

        for (int i = 0;
             i &amp;lt; importantInfo.length;
             i++) {
            //Pause for 4 seconds
            Thread.sleep(4000);
            //Print a message
            System.out.println(importantInfo[i]);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;main ë©”ì„œë“œëŠ”  InterruptedExceptionì„ throws í•œë‹¤. í˜„ì¬ ì‹¤í–‰ë˜ëŠ” ì“°ë ˆë“œê°€ sleepí•˜ëŠ” ë™ì•ˆ ë‹¤ë¥¸ ì“°ë ˆë“œê°€ ì¸í„°ëŸ½íŠ¸ë¥¼í•˜ë©´ sleep ë©”ì„œë“œê°€ throwsí•˜ëŠ” ì˜ˆì™¸ì…ë‹ˆë‹¤. ì´ ì–´í”Œë¦¬ì¼€ì´ì…˜ì€ ë‹¤ë¥¸ ì“°ë ˆë“œë¥¼ ì¸í„°ëŸ½íŠ¸í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì—  InterruptedExceptionì´ ë°œìƒí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
&lt;code&gt;Notice that main declares that it throws InterruptedException. This is an exception that sleep throws when another thread interrupts the current thread while sleep is active. Since this application has not defined another thread to cause the interrupt, it doesn&#39;t bother to catch InterruptedException.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[ë°œë²ˆì—­]The Javaâ„¢ Tutorials - 2-1. ì“°ë ˆë“œ ì •ì˜ì™€ ì‹œì‘ Defining and Starting a Thread</title>
      <link>http://durtchrt.github.io/blog/java/concurrency/4/</link>
      <pubDate>Thu, 24 Nov 2016 14:00:35 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/concurrency/4/</guid>
      <description>

&lt;h2 id=&#34;ì›ë¬¸ë§í¬-http-docs-oracle-com-javase-tutorial-essential-concurrency-runthread-html&#34;&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html&#34;&gt;ì›ë¬¸ë§í¬&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;ì“°ë ˆë“œ-ì •ì˜ì™€-ì‹œì‘&#34;&gt;ì“°ë ˆë“œ ì •ì˜ì™€ ì‹œì‘&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Defining and Starting a Thread&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì“°ë ˆë“œì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ëŠ” ì‘ìš©í”„ë¡œê·¸ë¨ì€ ë°˜ë“œì‹œ ì“°ë ˆë“œì— run ë©”ì„œë“œ ì½”ë“œë¥¼ ì œê³µí•´ì•¼í•©ë‹ˆë‹¤. ì´ëŠ” ë‘ê°€ì§€ ë°©ë²•ì´ ìˆìŠµë‹ˆë‹¤.
&lt;code&gt;An application that creates an instance of Thread must provide the code that will run in that thread. There are two ways to do this:&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Runnable ê°ì²´ ì œê³µ&lt;/code&gt; Runnable ì¸í„°í˜ì´ìŠ¤ëŠ” ì“°ë ˆë“œì—ì„œ ì‹¤í–‰í•˜ëŠ” ì½”ë“œë¥¼ í¬í•¨í•˜ëŠ” ë‹¨ì¼ ë©”ì„œë“œ runì„ ì •ì˜í•©ë‹ˆë‹¤. ì´ Runnable ê°ì²´ëŠ” ì“°ë ˆë“œ ìƒì„±ìì— ì¸ìë¡œ ì „ë‹¬ë©ë‹ˆë‹¤. HelloRunnable ì˜ˆì œ ì°¸ì¡°
&lt;code&gt;Provide a Runnable object. The Runnable interface defines a single method, run, meant to contain the code executed in the thread. The Runnable object is passed to the Thread constructor, as in the HelloRunnable example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloRunnable implements Runnable {

public void run() {
    System.out.println(&amp;quot;Hello from a thread!&amp;quot;);
}

public static void main(String args[]) {
    (new Thread(new HelloRunnable())).start();
}

}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ì„œë¸Œí´ë˜ìŠ¤ ì“°ë ˆë“œ&lt;/code&gt; ì“°ë ˆë“œ í´ë˜ìŠ¤ëŠ” ìŠ¤ìŠ¤ë¡œ Runnable ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•¨ì—ë„ ë¶ˆêµ¬í•˜ê³  run ë©”ì„œë“œëŠ” (main ë©”ì„œë“œì•ˆì—) ì—†ìŠµë‹ˆë‹¤ ì–´í”Œë¦¬ì¼€ì´ì…˜ì€ HelloThread ì˜ˆì œì²˜ëŸ¼ ìì‹ ì˜ run ë©”ì„œë“œ êµ¬í˜„ì²´ë¥¼ ì œê³µí•˜ì—¬ Threadì˜ ì„œë¸Œí´ë˜ìŠ¤í™” í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.(Threadì˜ ì„œë¸Œ í´ë˜ìŠ¤ì´ë¯€ë¡œ Threadë¡œ ë™ì‘ ê°€ëŠ¥í•´ì§.)
&lt;code&gt;Subclass Thread. The Thread class itself implements Runnable, though its run method does nothing. An application can subclass Thread, providing its own implementation of run, as in the HelloThread example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloThread extends Thread {

public void run() {
    System.out.println(&amp;quot;Hello from a thread!&amp;quot;);
}

public static void main(String args[]) {
    (new HelloThread()).start();
}

}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ë‘ ì˜ˆì œëŠ” ìƒˆ ìŠ¤ë ˆë“œë¥¼ ì‹œì‘í•˜ê¸°ìœ„í•´ Thread.startë¥¼ í˜¸ì¶œí•œë‹¤.
&lt;code&gt;Notice that both examples invoke Thread.start in order to start the new thread.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ë‘ ìš©ë¡€ì¤‘ ì–´ëŠê²ƒì„ ì‚¬ìš©í•˜ê² ìŠµë‹ˆê¹Œ? ì²«ë²ˆì§¸ ìš©ë¡€ Runnable ê°ì²´ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë” ì¼ë°˜ì ì´ë‹¤ ì™œëƒí•˜ë©´ Runnable ê°ì²´ëŠ” Threadê°€ì•„ë‹Œ ë‹¤ë¥¸ í´ë˜ìŠ¤ë¥¼ ì„œë¸Œí´ë˜ìŠ¤í™” í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‘ë²ˆì§¸ ìš©ë¡€ëŠ” ê°„ë‹¨í•œ ì‘ìš©í”„ë¡œê·¸ë¨ì—ì„œ ì‚¬ìš©í•˜ê¸° ì‰½ì§€ë§Œ íƒœìŠ¤í¬ í´ë˜ìŠ¤ê°€ Threadì˜ í•˜ìœ„ í´ë˜ìŠ¤ì—¬í•˜ëŠ” ì œí•œì´ ìˆìŠµë‹ˆë‹¤. ì´ ìˆ˜ì—…ì—ì„œëŠ” ì‹¤í–‰í•˜ëŠ” íƒœìŠ¤í¬ì¸ Thread ê°ì²´ë¡œë¶€í„° Runnable íƒœìŠ¤í¬ë¥¼ ë¶„ë¦¬í•˜ëŠ” ê²ƒì— ì´ˆì ì„ ë‘ê³ ìˆìŠµë‹ˆë‹¤. ì´ ë°©ë²•ì€ ë” ìœ ì—°í•˜ê³  ë‚˜ì¤‘ì— ë‹¤ë¥¼ ê³ ìˆ˜ì¤€ ì“°ë ˆë“œ ê´€ë¦¬ APIì— ì ìš©í•  ìˆ˜ ìˆë‹¤.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Which of these idioms should you use? The first idiom, which employs a Runnable object, is more general, because the Runnable object can subclass a class other than Thread. The second idiom is easier to use in simple applications, but is limited by the fact that your task class must be a descendant of Thread. This lesson focuses on the first approach, which separates the Runnable task from the Thread object that executes the task. Not only is this approach more flexible, but it is applicable to the high-level thread management APIs covered later.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì“°ë ˆë“œ í´ë˜ìŠ¤ëŠ” ì“°ë ˆë“œ ê´€ë¦¬ë¥¼ ìœ„í•´ ì“¸ë§Œí•œ ë©”ì„œë“œë“¤ì„ ì •ì˜í–ˆë‹¤. ì´ëŠ” ì“°ë ˆë“œì—ëŒ€í•œ ì •ë³´ë‚˜ ì“°ë ˆë“œì˜ ìƒíƒœì— ì˜í–¥ì— ëŒ€í•œ ì •ì  ë©”ì„œë“¤ë¥¼ ì œê³µí•œë‹¤.(???? - the thread invoking the method.) ë‹¤ë¥¸ ë©”ì„œë“œë“¤ì€ ë‹¤ë¥¸ ì“°ë ˆë“œë¡œë¶€í„° í˜¸ì¶œë©ë‹ˆë‹¤.(ì“°ë ˆë“œì™€ ì“°ë ˆë“œ ê°ì²´ë¥¼ ê´€ë¦¬í•˜ëŠ”ë° ê´€ë ¨ëœ) ìš°ë¦¬ëŠ” ì´ëŸ¬í•œ ë©”ì„œë“œë“¤ì„ ë‹¤ìŒ ì„¸ì…˜ì—ì„œ ê²€í† í•  ê²ƒì´ë‹¤.
&lt;code&gt;The Thread class defines a number of methods useful for thread management. These include static methods, which provide information about, or affect the status of, the thread invoking the method. The other methods are invoked from other threads involved in managing the thread and Thread object. We&#39;ll examine some of these methods in the following sections.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[ë°œë²ˆì—­]The Javaâ„¢ Tutorials - 2. Thread Objects</title>
      <link>http://durtchrt.github.io/blog/java/concurrency/3/</link>
      <pubDate>Thu, 24 Nov 2016 13:00:35 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/concurrency/3/</guid>
      <description>

&lt;h2 id=&#34;ì›ë¬¸ë§í¬-http-docs-oracle-com-javase-tutorial-essential-concurrency-threads-html&#34;&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/concurrency/threads.html&#34;&gt;ì›ë¬¸ë§í¬&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;ì“°ë ˆë“œ-ê°ì²´&#34;&gt;ì“°ë ˆë“œ ê°ì²´&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Thread Objects&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì“°ë ˆë“œë§ˆë‹¤ í´ë˜ìŠ¤ ì“°ë ˆë“œì˜ ì¸ìŠ¤í„´ìŠ¤ì™€ ì—°ê´€ë˜ì–´ìˆë‹¤. ë³‘í–‰ ì–´í”Œë¦¬ì¼€ì´ì…˜ì„ ë§Œë“œëŠ” ì“°ë ˆë“œ ê°ì²´ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” ë‘ê°€ì§€ ì „ëµì´ ìˆë‹¤.
&lt;code&gt;Each thread is associated with an instance of the class Thread. There are two basic strategies for using Thread objects to create a concurrent application.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì§ì ‘ì ìœ¼ë¡œ ì“°ë ˆë“œ ìƒì„±ê³¼ ê´€ë¦¬ë¥¼í•˜ë ¤ë©´, ì–´í”Œë¦¬ì¼€ì´ì…˜ì´ ë¹„ë™ê¸° íƒœìŠ¤í¬ë¥¼ ì‹œì‘ë ¤ëŠ” í•„ìš”í• ë•Œë§ˆë‹¤ ì“°ë ˆë“œë¥¼ ì¸ìŠ¤í„´ìŠ¤í™”í•©ë‹ˆë‹¤. ë‚˜ë¨¸ì§€ ì–´í”Œë¦¬ì¼€ì´ì…˜ìœ¼ë¡œë¶€í„° ì¶”ìƒ ìŠ¤ë ˆë“œë¥¼ ê´€ë ¤í•˜ë ¤ë©´, ì–´í”Œë¦¬ì¼€ì´ì…˜ì˜ íƒœìŠ¤í¬ë¥¼ executorì— ì „ë‹¬í•˜ì‹œìš”. ì´ ì„¹ì…˜ì—ì„œëŠ” ì“°ë ˆë“œ ê°ì²´ì˜ ì‚¬ìš©ë²•ì„ ì„¤ëª…í•©ë‹ˆë‹¤.  ExcutorëŠ” ê³ ìˆ˜ì¤€ ë³‘í–‰ ê°ì²´ì™€ í•¨ê»˜ ë…¼ì˜í•©ë‹ˆë‹¤.
&lt;code&gt;To directly control thread creation and management, simply instantiate Thread each time the application needs to initiate an asynchronous task. 
To abstract thread management from the rest of your application, pass the application&#39;s tasks to an executor.
This section documents the use of Thread objects. Executors are discussed with other high-level concurrency objects.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[ë°œë²ˆì—­]The Javaâ„¢ Tutorials - 1. Processes and Threads </title>
      <link>http://durtchrt.github.io/blog/java/concurrency/2/</link>
      <pubDate>Thu, 24 Nov 2016 12:00:35 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/concurrency/2/</guid>
      <description>

&lt;p&gt;##&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html&#34;&gt;ì›ë¬¸ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;í”„ë¡œì„¸ìŠ¤ì™€-ì“°ë ˆë“œ&#34;&gt;í”„ë¡œì„¸ìŠ¤ì™€ ì“°ë ˆë“œ&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Processes and Threads&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ë³‘í–‰ í”„ë¡œê·¸ë˜ë°ì—ì„œëŠ” ì‹¤í–‰ì˜ ë‘ê°œì˜ ê¸°ë³¸ ê°œë…ì´ ìˆë‹¤(í”„ë¡œì„¸ìŠ¤, ì“°ë ˆë“œ). ìë°” í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì—ì„œëŠ” ë³‘í–‰ í”„ë¡œê·¸ë˜ë°ì€ ê±°ì˜ ëŒ€ë¶€ë¶„ ì“°ë ˆë“œì™€ ê´€ë ¨ìˆë‹¤. í•˜ì§€ë§Œ í”„ë¡œì„¸ìŠ¤ ì—­ì‹œ ì¤‘ìš”í•˜ë‹¤.
&lt;code&gt;In concurrent programming, there are two basic units of execution: processes and threads. In the Java programming language, concurrent programming is mostly concerned with threads. However, processes are also important.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì»´í“¨í„° ì‹œìŠ¤í…œì€ ì¼ë°˜ì ìœ¼ë¡œ ë§ì€ í™œë™ì ì¸ í”„ë¡œì„¸ìŠ¤ì™€ ì“°ë ˆë“œë¥¼ ê°€ì§€ê³  ìˆë‹¤. ì‹±ê¸€ ì½”ì—ì„œëŠ” í•˜ë‚˜ë§Œ ë™ì‘í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ í•œìˆœê°„ì—ëŠ” í•œ ìŠ¤ë ˆë“œë§Œ ë™ì‘í•  ìˆ˜ ìˆë‹¤. (;;;;) ì‹±ê¸€ì½”ì–´ëŠ” íƒ€ì„ìŠ¬ë¼ì´ì‹±ì´ë¼ê³  ë¶ˆë¦¬ëŠ” OS ê¸°ëŠ¥ì„ í†µí•´ í”„ë¡œì„¸ìŠ¤ì™€ ìŠ¤ë ˆë“œë“¤ê°„ì— ê³µìœ í•œë‹¤.(Processing time for ???)
&lt;code&gt;A computer system normally has many active processes and threads. This is true even in systems that only have a single execution core, and thus only have one thread actually executing at any given moment. Processing time for a single core is shared among processes and threads through an OS feature called time slicing.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì»´í“¨í„° ì‹œìŠ¤í…œì€ ë©€í‹° í”„ë¡œì„¸ì„œ ë˜ëŠ”  ë©€í‹° ì½”ì–´ë¥¼ ê°€ì§€ëŠ”ê±´ ì ì  ë” í”í•´ì§€ê³  ìˆë‹¤. ì´ê±´ ì‹œìŠ¤í…œì˜  í”„ë¡œì„¸ìŠ¤ì™€ ìŠ¤ë ˆë“œì˜ ë³‘í–‰ ì‹¤í–‰ ëŠ¥ë ¥ì„ í›Œë¥­í•˜ê²Œ ë†’ì—¬ì£¼ì˜€ë‹¤. í•˜ì§€ë§Œ ë³‘í–‰ì„±ì€ ë©€í‹°í”„ë¡œì„¸ì„œ ë˜ëŠ” ë©€í‹°ì½”ì–´ê°€ ì•„ë‹ˆë”ë¼ë„ ì‹±ê¸€ì½”ì–´ ì‹œìŠ¤í…œì—ì„œë„ ê°€ëŠ¥í•˜ë‹¤.
&lt;code&gt;It&#39;s becoming more and more common for computer systems to have multiple processors or processors with multiple execution cores. This greatly enhances a system&#39;s capacity for concurrent execution of processes and threads â€” but concurrency is possible even on simple systems, without multiple processors or execution cores.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;í”„ë¡œì„¸ìŠ¤&#34;&gt;í”„ë¡œì„¸ìŠ¤&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Processes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;í”„ë¡œì„¸ìŠ¤ëŠ” ë…ë¦½ ì‹¤í–‰í™˜ê²½ì„ ê°€ì¡ŒìŠµë‹ˆë‹¤. í”„ë¡œì„¸ìŠ¤ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ì™„ë²½í•˜ê³ , ì™¸ë¶€ì— ë…¸ì¶œì•ˆë˜ëŠ”  ëŸ°íƒ€ì„ ìì›ì˜ ì§‘í•©ì„ ì œê³µí•©ë‹ˆë‹¤.(ë§ì´ ì–´ë µë„¤;;); ê°œë³„ì ìœ¼ë¡œ ê°ê°ì˜ í”„ë¡œì„¸ìŠ¤ë“¤ì€ ìì‹ ë§Œì˜ ë©”ëª¨ë¦¬ ê³µê°„ì„ ê°€ì§‘ë‹ˆë‹¤.
&lt;code&gt;A process has a self-contained execution environment. A process generally has a complete, private set of basic run-time resources; in particular, each process has its own memory space.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;í”„ë¡œì„¸ìŠ¤ëŠ” í”„ë¡œê·¸ë¨ ë˜ëŠ” ì–´í”Œë¦¬ì¼€ì´ì…˜ê³¼ ìœ ì˜ì–´ë¡œ ì¢…ì¢… ì¸ì§€í•œë‹¤. í•˜ì§€ë§Œ ì‚¬ìš©ìê°€ ë‹¨ì¼ ì–´í”Œë¦¬ì¼€ì´ì…˜ì²˜ëŸ¼ ë³´ì´ëŠ”ê²ƒì€ ì‚¬ì‹¤ í˜‘ë ¥ì ì¸ í”„ë¡œì„¸ìŠ¤ì¼ìˆ˜ ìˆìŠµë‹ˆë‹¤. í”„ë¡œìŠ¤ìŠ¤ê°„ì— í†µì‹ ì´ ì˜ë ë ¤ë©´, OSëŠ” íŒŒì´í”„, ì†Œì¼“ ê°™ì€ IPC(Inter Process Communication)ì„ ì§€ì›í•œë‹¤. IPCëŠ” ë‹¨ìˆœíˆ ë™ì¼ ì‹œìŠ¤í…œë‚´ì—ì„œ í”„ë¡ì„¸ìŠ¤ê°„ì˜ í†µì‹ ë¿ë§Œ ì•„ë‹ˆë¼ ë‹¤ë¥¸ ì‹œìŠ¤í…œì˜ í”„ë¡œì„¸ìŠ¤ë“¤ê°„ì—ë„ ì‚¬ìš©ë©ë‹ˆë‹¤.(ë­”ê°€ ì–´ë ¤ì›€;;)
&lt;code&gt;Processes are often seen as synonymous with programs or applications. However, what the user sees as a single application may in fact be a set of cooperating processes. To facilitate communication between processes, most operating systems support Inter Process Communication (IPC) resources, such as pipes and sockets. IPC is used not just for communication between processes on the same system, but processes on different systems.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ê±°ì˜ ëª¨ë“  ìë°” ê°€ìƒë¨¸ì‹ ì€ ì‹±ê¸€ í”„ë¡œì„¸ìŠ¤ë¡œ êµ¬í˜„ëœë‹¤. ìë°” ì–´í”Œë¦¬ì¼€ì´ì…˜ì€ ProcessBuilder ê°ì²´ë¥¼ ì‚¬ìš©í•´ì„œ ì¶”ê°€ í”„ë¡œì„¸ìŠ¤ë“¤ì„ ë§Œë“¤ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë©€í‹°í”„ë¡œì„¸ìŠ¤ ì–´í”Œë¦¬ì¼€ì´ì…˜ì€ ì´ ìˆ˜ì—…ì˜ ë²”ìœ„ë¥¼ ë„˜ê¸°ë¯€ë¡œ ì—†ìŠµë‹ˆë‹¤.
&lt;code&gt;Most implementations of the Java virtual machine run as a single process. A Java application can create additional processes using a ProcessBuilder object. Multiprocess applications are beyond the scope of this lesson.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì“°ë ˆë“œ&#34;&gt;ì“°ë ˆë“œ&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Threads&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì“°ë ˆë“œëŠ” ë•Œë•Œë¡œ ê°€ë²¼ìš´ í”„ë¡œì„¸ìŠ¤(lightwight processes)ë¼ê³  ë¶ˆë¦°ë‹¤. í”„ë¡œì„¸ìŠ¤ì™€ ì“°ë ˆë“œëŠ” ì‹¤í–‰í™˜ê²½ì„ ì œê³µí•˜ì§€ë§Œ ìƒˆë¡œìš´ í”„ë¡œì„¸ìŠ¤ë¥¼ ìƒì„±í•˜ëŠ” ê²ƒë³´ë‹¤ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ëŠ”ê²Œ ìì› ì‚¬ìš©ì´ ì ë‹¤.
&lt;code&gt;Threads are sometimes called lightweight processes. Both processes and threads provide an execution environment, but creating a new thread requires fewer resources than creating a new process.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì“°ë ˆë“œëŠ” í”„ë¡œì„¸ìŠ¤ ì•ˆì— ì¡´ì¬í•œë‹¤.(ëª¨ë“  í”„ë¡œì„¸ìŠ¤ëŠ” ìµœì†Œí•œ í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë¥¼ ê°€ì§„ë‹¤.) ìŠ¤ë ˆë“œëŠ” í”„ë¡œì„¸ìŠ¤ì˜ ë©”ëª¨ë¦¬, ì—´ë¦° íŒŒì¼ë“±ì„ í¬í•¨í•˜ì—¬ ìì›ì„ ê³µìœ í•œë‹¤. ì´ê±´ íš¨ê³¼ì ì´ì§€ë§Œ ì ì¬ì ìœ¼ë¡œ ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤.(communication??)
&lt;code&gt;Threads exist within a process â€” every process has at least one. Threads share the process&#39;s resources, including memory and open files. This makes for efficient, but potentially problematic, communication.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ë©€í‹°ì“°ë ˆë“œ ë™ì‘ì€ ìë°” í”Œë«í¼ì˜ í•„ìˆ˜ì ì¸ íŠ¹ì§•ì´ë‹¤. ëª¨ë“  ì–´í”Œë¦¬ì¼€ì´ì…˜ì€ ìµœì†Œí•œ í•˜ë‚˜ì˜ (ë˜ëŠ” ì—¬ëŸ¬ê°œ )ìŠ¤ë ˆë“œë¥¼ ê°€ì§„ë‹¤.ë©”ëª¨ë¦¬ ê´€ë¦¬ì™€ ì‹œê·¸ë„ í•¸ë“¤ë§ê³¼ ê°™ì€ ê²ƒê³¼ ê°™ì´ &amp;ldquo;ì‹œìŠ¤í…œ&amp;rdquo; ìŠ¤ë ˆë“œë¥¼ ì…€ ìˆ˜ ìˆìŠµë‹ˆë‹¤(???). ê·¸ëŸ¬ë‚˜ ì–´í”Œë¦¬ì¼€ì´ì…˜ í”„ë¡œê·¸ë˜ë¨¸ì˜ ê´€ì ì—ì„œ ë³´ë©´ main ì“°ë ˆë“œë¼ê³  ë¶ˆë¦¬ëŠ” í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë¡œë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤. ì´ ìŠ¤ë ˆë“œëŠ” ì¶”ê°€ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ëŠ” ëŠ¥ë ¥ì„ ê°€ì¡Œë‹¤. ë‹¤ìŒ ì„¹ì…˜ì—ì„œ ì„¤ëª…í•˜ê² ë‹¤.
&lt;code&gt;Multithreaded execution is an essential feature of the Java platform. Every application has at least one thread â€” or several, if you count &amp;quot;system&amp;quot; threads that do things like memory management and signal handling. But from the application programmer&#39;s point of view, you start with just one thread, called the main thread. This thread has the ability to create additional threads, as we&#39;ll demonstrate in the next section.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[ë°œë²ˆì—­]The Javaâ„¢ Tutorials - 0. Concurrency</title>
      <link>http://durtchrt.github.io/blog/java/concurrency/1/</link>
      <pubDate>Thu, 24 Nov 2016 12:00:34 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/concurrency/1/</guid>
      <description>

&lt;p&gt;##&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/concurrency/index.html&#34;&gt;ì›ë¬¸ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lesson-concurrency&#34;&gt;Lesson: Concurrency&lt;/h1&gt;

&lt;p&gt;ì»´í“¨í„°ëŠ” ì‚¬ìš©ìì—ê²Œ ë™ì¼ì‹œê°„ì— í•œê°€ì§€ ì´ìƒì˜ ì¼ì„ í•  ìˆ˜ ìˆë„ë¡ ì‹œìŠ¤í…œì´ ë³´ì¥ì´ ë˜ì•¼í•œë‹¤. ì»´í“¨í„° ì‚¬ìš©ìëŠ” ì›Œë“œí”„ë¡œì„¸ì„œ ì‘ì—…ì„ í•  ë•Œ ë‹¤ë¥¸ ì–´í”Œë¦¬ì¼€ì´ì…˜ì´ íŒŒì¼ ë‹¤ìš´ë¡œë“œ, ìŠ¤íŠ¸ë¦¬ë° ì˜¤ë””ì˜¤, í”„ë¦°í„° í ê´€ë¦¬ë“±ì„ ë™ì‹œì— í•˜ëŠ”ê²Œ ë‹¹ì—°í•˜ì‚¬ ìƒê°í•œë‹¤. ì‹¬ì§€ì–´ í•˜ë‚˜ì˜ ì–´í”Œë ˆì¼€ì´ì…˜ì´ í•œë²ˆì— í•œê°€ì§€ ì´ìƒì˜ ë™ì‘í•˜ëŠ” ê²ƒì„ ì¢…ì¢… ê¸°ëŒ€í•œë‹¤. ì˜ˆë¥¼ë“¤ë©´ ìŠ¤íŠ¸ë¦¬ë° ì˜¤ë””ì˜¤ ì–´í”Œë ˆì¼€ì´ì…˜ì€ ë°˜ë“œì‹œ ë™ì‹œì— ë„¤íŠ¸ì›Œí¬ë¡œë¶€í„° ë””ì§€í„¸ ì˜¤ë””ì˜¤ ì½ê¸°, ì••ì¶•ì„ í’€ê¸°, ì¬ìƒ ê´€ë¦¬, ë””ìŠ¤í”Œë ˆì´ ì—…ë°ì´íŠ¸ë¥¼ ìˆ˜í–‰í•œë‹¤. ì‹¬ì§€ì–´ ì›Œë“œí”„ë¡œì„¸ì„œë„ ë””ìŠ¤í”Œë ˆì´ ì—…ë°ì´íŠ¸ë‚˜ í…ìŠ¤íŠ¸ë¥¼ ë‹¤ì‹œ í¬ë§·íŒ…í•˜ëŠ”ê²ƒì´ ì–¼ë§ˆë‚˜ ë°”ìœì§€ ìƒê´€ì—†ì´ í‚¤ë³´ë“œì˜ ì‘ë‹µ, ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ë“¤ì˜ ì‘ë‹µì„ ëŒ€ê¸°í•´ì•¼í•œë‹¤. ê·¸ëŸ¬í•œ ê²ƒì„ í•  ìˆ˜ ìˆëŠ” ì†Œí”„íŠ¸ì›¨ì–´ë¥¼ ë³‘í–‰ì„±(ë™ì‹œì„±) ì†Œí”„íŠ¸ì›¨ì–´ë¼ê³  ì•Œë ¤ì ¸ìˆë‹¤.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Computer users take it for granted that their systems can do more than one thing at a time. They assume that they can continue to work in a word processor, while other applications download files, manage the print queue, and stream audio. Even a single application is often expected to do more than one thing at a time. For example, that streaming audio application must simultaneously read the digital audio off the network, decompress it, manage playback, and update its display. Even the word processor should always be ready to respond to keyboard and mouse events, no matter how busy it is reformatting text or updating the display. Software that can do such things is known as concurrent software.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ìë°” í”Œë«í¼ì€ ë³‘í–‰ í”„ë¡œê·¸ë˜ë°ì„ ì§€ì›í•˜ë„ë¡ (ë°‘ë°”ë‹¥ë¶€í„° ëê¹Œì§€) ì„¤ê³„ ë˜ì—ˆë‹¤. ìë°” í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì™€ ìë°” í´ë˜ìŠ¤ ë¼ì´ë¸ŒëŸ¬ë¦¬ë“¤ë¡œ ê¸°ë³¸ ë³‘í–‰ì„±ì„ ì§€ì›í•œë‹¤. ìë°” í”Œë«í¼ 5.0 ë²„ì „ë¶€í„°ëŠ” ê³ ìˆ˜ì¤€ì˜ concurrency APIë„ í¬í•¨ë˜ì—ˆë‹¤. ì´ë²ˆ ìë°” í”Œë«í¼ì˜ ìˆ˜ì—…ì€ ê¸°ë³¸ ë³‘í–‰ ì§€ì›ê³¼ ëª‡ê°€ì§€ java.util.concurrent íŒ¨í‚¤ì§€ì˜ ìˆ˜ì¤€ APIì˜ ìš”ì•½ì„ ì†Œê°œí•œë‹¤.
&lt;code&gt;The Java platform is designed from the ground up to support concurrent programming, with basic concurrency support in the Java programming language and the Java class libraries. Since version 5.0, the Java platform has also included high-level concurrency APIs. This lesson introduces the platform&#39;s basic concurrency support and summarizes some of the high-level APIs in the java.util.concurrent packages.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(10) ì™€ì¼ë“œì¹´ë“œ Wildcards </title>
      <link>http://durtchrt.github.io/blog/java/generics/11/</link>
      <pubDate>Sat, 12 Nov 2016 18:23:01 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/11/</guid>
      <description>

&lt;h3 id=&#34;ìƒìœ„-ì œí•œëœ-ì™€ì¼ë“œ-ì¹´ë“œ-upper-bounded-wildcards&#34;&gt;ìƒìœ„ ì œí•œëœ ì™€ì¼ë“œ ì¹´ë“œ &lt;code&gt;Upper Bounded Wildcards&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ë³€ìˆ˜ì— ì™„í™”ëœ ì œí•œì„ ê±¸ê³  ì‹¶ì„ë•Œ upper bounded wildcardë¥¼ ì‚¬ìš©í•œë‹¤. ì˜ˆë¥¼ë“¤ë©´, List&amp;lt;Integer&amp;gt;, List&amp;lt;Double&amp;gt;, List&amp;lt;Number&amp;gt; íƒ€ì…ë“¤ì—ì„œ ë™ì‘í•˜ëŠ” ë©”ì„œë“œë¥¼ ì‘ì„±í• ë•Œ upper bounded wildcardë¥¼ ì‚¬ìš©í•´ì„œ ë§Œë“¤ìˆ˜ ìˆë‹¤.
&lt;code&gt;You can use an upper bounded wildcard to relax the restrictions on a variable. For example, say you want to write a method that works on List&amp;lt;Integer&amp;gt;, List&amp;lt;Double&amp;gt;, and List&amp;lt;Number&amp;gt;; you can achieve this by using an upper bounded wildcard.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;uppper-bounded wildcardëŠ” ì™€ì¼ë“œì¹´ë“œ ë¬¸ì &amp;lsquo;?&amp;lsquo;ì™€ ë’¤ì—ëŠ” extends í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ê³  ë’¤ì—ëŠ” ìƒìœ„ íƒ€ì…ì„ ì¨ì„œ ì •ì˜í•œë‹¤. í´ë˜ìŠ¤ì˜ extends, ì¸í„°í˜ì´ìŠ¤ì˜ implementsì²˜ëŸ¼ extends í‚¤ì›Œë“œëŠ” ì´ëŸ¬í•œ ì˜ë¯¸ë¡œ ì‚¬ìš©ëœë‹¤.
&lt;code&gt;To declare an upper-bounded wildcard, use the wildcard character (&#39;?&#39;), followed by the extends keyword, followed by its upper bound. Note that, in this context, extends is used in a general sense to mean either &amp;quot;extends&amp;quot; (as in classes) or &amp;quot;implements&amp;quot; (as in interfaces).&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Integer, Double, Floatì²˜ëŸ¼ Number íƒ€ì…ì˜ ì„œë¸Œíƒ€ì…ë“¤ì—ì„œ ë™ì‘í•˜ëŠ” ë©”ì„œë“œë¥¼ ì‘ì„±í•  ë•Œ, List&amp;lt;? extends Number&amp;gt; ìš”ë˜ ì‘ì„±í•˜ë©´ëœë‹¤. List&amp;lt;Number&amp;gt;ëŠ” List&amp;lt;? extends Number&amp;gt;ë³´ë‹¤ ì œí•œì ì´ë‹¤. ì „ìëŠ” Number íƒ€ì…ì˜ ë¦¬ìŠ¤íŠ¸ë§Œ ê°€ëŠ¥, í›„ìëŠ” Number íƒ€ì… ë˜ëŠ” Number íƒ€ì…ì˜ ì„œë¸Œ íƒ€ì… ë¦¬ìŠ¤íŠ¸ë„ ê°€ëŠ¥í•˜ë‹¤.
&lt;code&gt;To write the method that works on lists of Number and the subtypes of Number, such as Integer, Double, and Float, you would specify List&amp;lt;? extends Number&amp;gt;. The term List&amp;lt;Number&amp;gt; is more restrictive than List&amp;lt;? extends Number&amp;gt; because the former matches a list of type Number only, whereas the latter matches a list of type Number or any of its subclasses.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì•„ë˜ì˜ process ë©”ì„œë“œë¥¼ ì‚´í´ë³´ì &lt;code&gt;Consider the following process method:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void process(List&amp;lt;? extends Foo&amp;gt; list) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lt;? extends Foo&amp;gt; upper bounded wildcardëŠ” Fooì™€ Fooì˜ ì„œë¸Œíƒ€ì…ê³¼ ë§¤ì¹˜ë˜ëŠ” í‘œí˜„ì´ë‹¤. (ì•„ë˜ì˜ ì½”ë“œ ì°¸ì¡°)process ë©”ì„œë“œëŠ” Fooíƒ€ì…ê³¼ ê°™ì€ ë¦¬ìŠ¤íŠ¸ì˜ ìš”ì†Œë¥¼ ì—‘ì„¸ìŠ¤í• ìˆ˜ ìˆë‹¤.
&lt;code&gt;The upper bounded wildcard, &amp;lt;? extends Foo&amp;gt;, where Foo is any type, matches Foo and any subtype of Foo. The process method can access the list elements as type Foo:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void process(List&amp;lt;? extends Foo&amp;gt; list) {
    for (Foo elem : list) {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;foreachì ˆì€ listì˜ ê°ê° ìš”ì†Œë¥¼ ìˆœíšŒí•˜ë©° elem ë³€ìˆ˜ì— í• ë‹¹í•œë‹¤.  elemì€ Foo í´ë˜ìŠ¤ì— ì •ì˜ë˜ì–´ ìˆëŠ” ë©”ì„œë“œë¥¼ ëª¨ë‘ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;In the foreach clause, the elem variable iterates over each element in the list. Any method defined in the Foo class can now be used on elem.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;sumOfListë©”ì„œë“œëŠ” ë¦¬ìŠ¤íŠ¸ ì•ˆì˜ ìˆ«ìì˜ í•©ì„ ë¦¬í„´í•œë‹¤. &lt;code&gt;The sumOfList method returns the sum of the numbers in a list:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static double sumOfList(List&amp;lt;? extends Number&amp;gt; list) {
    double s = 0.0;
    for (Number n : list)
        s += n.doubleValue();
    return s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì•„ë˜ì˜ ì½”ë“œëŠ” Integer ê°ì²´ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ &amp;ldquo;sum = 6.0&amp;rdquo;ì„ ì¶œë ¥í•œë‹¤.
&lt;code&gt;The following code, using a list of Integer objects, prints sum = 6.0:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Integer&amp;gt; li = Arrays.asList(1, 2, 3);
System.out.println(&amp;quot;sum = &amp;quot; + sumOfList(li));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Doubleê°’ì„ ê°€ì§„ ë¦¬ìŠ¤íŠ¸ë„ sumOfList ë©”ì„œë“œë¥¼ ì—­ì‹œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ì•„ë˜ì˜ ì½”ë“œëŠ” &amp;ldquo;sum = 7.0&amp;rdquo;ì„ ì¶œë ¥í•œë‹¤.
&lt;code&gt;A list of Double values can use the same sumOfList method. The following code prints sum = 7.0:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Double&amp;gt; ld = Arrays.asList(1.2, 2.3, 3.5);
System.out.println(&amp;quot;sum = &amp;quot; + sumOfList(ld));
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(10) ì™€ì¼ë“œì¹´ë“œ Wildcards </title>
      <link>http://durtchrt.github.io/blog/java/generics/10/</link>
      <pubDate>Fri, 11 Nov 2016 18:23:01 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/10/</guid>
      <description>

&lt;h3 id=&#34;ì™€ì¼ë“œì¹´ë“œ-wildcards&#34;&gt;ì™€ì¼ë“œì¹´ë“œ &lt;code&gt;Wildcards&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic ì½”ë“œì—ì„œëŠ” unkown íƒ€ì…ì„ í‘œí˜„í•˜ëŠ” ë¬¼ìŒí‘œ(?)ë¥¼ ì™€ì¼ë“œ ì¹´ë“œë¼ê³  ë¶€ë¥¸ë‹¤. ì™€ì¼ë“œì¹´ë“œëŠ” ë‹¤ì–‘í•œ ìƒí™©ì—ì„œ ì“°ì¸ë‹¤.(íŒŒë¼ë©”í„°, í•„ë“œ, ì§€ì—­ë³€ìˆ˜ íƒ€ì… ë•Œë¡œëŠ” ë¦¬í„´ íƒ€ì…ì—ë„ ì“°ì¸ë‹¤. (though it is better programming practice to be more specific). ì™€ì¼ë“œì¹´ë“œëŠ” ì œë„¤ë¦­ ë©”ì„œë“œ í˜¸ì¶œ, ì œë„¤ë¦­ í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±, ë˜ëŠ” ìŠˆí¼íƒ€ì…ì„ ìœ„í•´ íƒ€ì…ì¸ìë¡œëŠ” ì‚¬ìš©ë˜ì§€ ì•ŠëŠ”ë‹¤.
&lt;code&gt;In generic code, the question mark (?), called the wildcard, represents an unknown type. The wildcard can be used in a variety of situations: as the type of a parameter, field, or local variable; sometimes as a return type (though it is better programming practice to be more specific). The wildcard is never used as a type argument for a generic method invocation, a generic class instance creation, or a supertype.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì´ë²ˆì¥ì—ëŠ” ì™€ì¼ë“œì¹´ë“œì— ëŒ€í•´ ë…¼ì˜í•œë‹¤. ìƒìœ„ì œí•œëœ ì™€ì¼ë“œì¹´ë“œ/í•˜ìœ„ì œí•œëœ ì™€ì¼ë“œì¹´ë“œ, ì™€ì¼ë“œì¹´ë“œ ìº¡ì³ë“±ì„ ë‹¤ë£¬ë‹¤.
&lt;code&gt;The following sections discuss wildcards in more detail, including upper bounded wildcards, lower bounded wildcards, and wildcard capture.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(13) Java Generics: í•˜ìœ„ ì œí•œ ì™€ì¼ë“œì¹´ë“œ(Lower Bounded Wildcards)</title>
      <link>http://durtchrt.github.io/blog/java/generics/13/</link>
      <pubDate>Mon, 07 Nov 2016 14:00:42 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/13/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/wildcards.htm://docs.oracle.com/javase/tutorial/java/generics/lowerBounded.html&#34;&gt;ì›ë¬¸ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;í•˜ìœ„-ì œí•œ-ì™€ì¼ë“œì¹´ë“œ-lower-bounded-wildcards&#34;&gt;í•˜ìœ„ ì œí•œ ì™€ì¼ë“œì¹´ë“œ  &lt;code&gt;Lower Bounded Wildcards&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ìƒìœ„ì œí•œì™€ì¼ë“œì¹´ë“œì¥ì€ íŠ¹ì • íƒ€ì…ì´ë‚˜ ê·¸ íŠ¹ì •íƒ€ì…ì˜  ì„œë¸Œíƒ€ì…ì„ ì•Œ ìˆ˜ ì—†ì„ë•ŒëŠ” &amp;lsquo;extends&amp;rsquo; í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ë³´ì—¬ì¤¬ë‹¤. ë¹„ìŠ·í•œ ê²ƒìœ¼ë¡œ, í•˜ìœ„ì œí•œì™€ì¼ë“œì¹´ë“œëŠ” íŠ¹ì •íƒ€ì…ì´ë‚˜ ê·¸ íŠ¹ì • íƒ€ì…ì˜ ìŠˆí¼íƒ€ì…ì„ ì œí•œí•˜ê³ ìí• ë•Œ ì‚¬ìš©í•œë‹¤.
&lt;code&gt;The Upper Bounded Wildcards section shows that an upper bounded wildcard restricts the unknown type to be a specific type or a subtype of that type and is represented using the extends keyword. In a similar way, a lower bounded wildcard restricts the unknown type to be a specific type or a super type of that type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;í•˜ìœ„ì œí•œ ì™€ì¼ë“œì¹´ë“œëŠ” ì™€ì¼ë“œì¹´ë“œë¬¸ì(&amp;lsquo;?&amp;rsquo;) ê·¸ ë’¤ë¡œ super í‚¤ì›Œë“œì™€ ê·¸ ë’¤ë¡œ í•˜ìœ„ì œí•œ íƒ€ì…ì´ ì˜¨ë‹¤. &amp;lt;? super A&amp;gt;.
&lt;code&gt;A lower bounded wildcard is expressed using the wildcard character (&#39;?&#39;), following by the super keyword, followed by its lower bound: &amp;lt;? super A&amp;gt;.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ì¤‘ìš”: ìƒìœ„ì œí•œì™€ì¼ë“œì¹´ë“œë¥¼ ì‚¬ìš©í•˜ê±°ë‚˜ í•˜ìœ„ì œí•œì™€ì¼ë“œì¹´ë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆì§€ë§Œ, ë‘˜ì„ ë™ì‹œì— ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.&lt;/code&gt;
&lt;code&gt;Note: You can specify an upper bound for a wildcard, or you can specify a lower bound, but you cannot specify both.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ë¦¬ìŠ¤íŠ¸ì— Integer ê°ì²´ë¥¼ ë„£ëŠ” ì½”ë“œë¥¼ ì‘ì„±í• ë•Œ, List&amp;lt;Integer&amp;gt;, List&amp;lt;Number&amp;gt;, List&amp;lt;Object\&amp;gt;ì—ì„œë§Œ ë™ì‘í•˜ê¸¸ ì›í•˜ëŠ” ë©”ì„œë“œë¥¼ ë§Œë“ ë‹¤ê³  ê°€ì •í•˜ì.
&lt;code&gt;Say you want to write a method that puts Integer objects into a list. To maximize flexibility, you would like the method to work on List&amp;lt;Integer&amp;gt;, List&amp;lt;Number&amp;gt;, and List&amp;lt;Object&amp;gt; â€” anything that can hold Integer values.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Integeríƒ€ì´ì´ë‚˜ Integerì˜ ìƒìœ„íƒ€ì…ì—ì„œ ë™ì‘í•˜ëŠ” ë©”ì„œë“œë¥¼ ì‘ì„±í•˜ë ¤ë©´ List&amp;lt;? super Integer&amp;gt;ë¼ê³  í•  ìˆ˜ ìˆë‹¤. List&amp;lt;Integer&amp;gt;ëŠ” List&amp;lt;? super Integer&amp;gt;ë³´ë‹¤ ì œí•œì ì´ë‹¤. ì™œëƒí•˜ë©´ ì „ìëŠ” Integer íƒ€ì…ì˜ ë¦¬ìŠ¤íŠ¸ë§Œ ì‚¬ìš©, í›„ìëŠ” Integer íƒ€ì…ê³¼ Integerì˜ ìŠˆí¼íƒ€ì…ì— ì‚¬ìš©í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.
&lt;code&gt;To write the method that works on lists of Integer and the supertypes of Integer, such as Integer, Number, and Object, you would specify List&amp;lt;? super Integer&amp;gt;. The term List&amp;lt;Integer&amp;gt; is more restrictive than List&amp;lt;? super Integer&amp;gt; because the former matches a list of type Integer only, whereas the latter matches a list of any type that is a supertype of Integer.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì•„ë˜ì˜ ì½”ë“œëŠ” 1ì—ì„œ 10ê¹Œì§€ ë¦¬ìŠ¤íŠ¸ì— addí•œë‹¤.
&lt;code&gt;The following code adds the numbers 1 through 10 to the end of a list:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void addNumbers(List&amp;lt;? super Integer&amp;gt; list) {
    for (int i = 1; i &amp;lt;= 10; i++) {
        list.add(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì™€ì¼ë“œì¹´ë“œ ì‚¬ìš©ì ˆì—ì„œëŠ” ìƒìœ„ì œí•œì™€ì¼ë“œì¹´ë“œì™€ í•˜ìœ„ì œí•œì™€ì¼ë“œì¹´ë“œë¥¼ ê°ê° ì–¸ì œ ì‚¬ìš©í• ì§€ ì„¤ëª…í•˜ì˜€ë‹¤.
&lt;code&gt;The Guidelines for Wildcard Use section provides guidance on when to use upper bounded wildcards and when to use lower bounded wildcards.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(12) Java Generics: ìƒìœ„ ì œí•œëœ ì™€ì¼ë“œì¹´ë“œ(Upper Bounded Wildcards)</title>
      <link>http://durtchrt.github.io/blog/java/generics/12/</link>
      <pubDate>Mon, 07 Nov 2016 13:00:42 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/12/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/unboundedWildcards.html&#34;&gt;ì›ë¬¸ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì œí•œì—†ëŠ”-ì™€ì¼ë“œì¹´ë“œ-unbounded-wildcards&#34;&gt;ì œí•œì—†ëŠ” ì™€ì¼ë“œì¹´ë“œ &lt;code&gt;Unbounded Wildcards&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ì œí•œì—†ëŠ” ì™€ì¼ë“œì¹´ë“œ íƒ€ì…ì€ ì™€ì¼ë“œì¹´ë“œ ë¬¸ì(&amp;lsquo;?&amp;rsquo;)ë§Œ ì‚¬ìš©í•œê²ƒì´ë‹¤. ì˜ˆë¥¼ ë“¤ë©´ List&amp;lt;?&amp;gt;ì™€ ê°™ë‹¤. List&amp;lt;?&amp;gt;ì˜ ?ëŠ” Listì˜ &amp;lsquo;ì•Œìˆ˜ì—†ëŠ” íƒ€ì…(unkown type)&amp;lsquo;ì´ë¼ê³  ë¶€ë¥¸ë‹¤. ì•„ë˜ ë‘ê°œì˜ ì‹œë‚˜ë¦¬ì˜¤ëŠ” ì œí•œì—†ëŠ” ì™€ì¼ë“œì¹´ë“œê°€ ìœ ìš©í•œ ì ‘ê·¼ë²•ì´ë‹¤.
&lt;code&gt;The unbounded wildcard type is specified using the wildcard character (?), for example, List&amp;lt;?&amp;gt;. This is called a list of unknown type. There are two scenarios where an unbounded wildcard is a useful approach:&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Object í´ë˜ìŠ¤ì—ì„œ ì œê³µí•˜ëŠ” ê¸°ëŠ¥(ë©”ì„œë“œ)ì„ ì‚¬ìš©í•˜ë„ë¡ ë©”ì„œë“œë¥¼ êµ¬í˜„í•  ë•Œ.
&lt;code&gt;- If you are writing a method that can be implemented using functionality provided in the Object class.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ì½”ë“œê°€ generic í´ë˜ìŠ¤ì—ì„œ ë©”ì„œë“œê°€ íƒ€ì…ë§¤ê°œë³€ìˆ˜ì— ì˜ì¡´ì ì´ì§€ ì•Šê²Œ ì‘ì„±í•˜ê³  ì‹¶ì„ ë•Œ.(ì˜ˆ List.sizeë‚˜ List.clear). ì‚¬ì‹¤, Class&amp;lt;T&amp;gt; í´ë˜ìŠ¤ëŠ” ë²”ìœ„ì—†ëŠ” ì™€ì¼ë“œì¹´ë“œë¥¼ ìì£¼ ì‚¬ìš©í•œë‹¤.(Class&amp;lt;T&amp;gt;ì˜ ë©”ì„œë“œê°€ Tì— ì˜ì¡´ì ìœ¼ë¡œ ë™ì‘í•˜ì§€ ì•Šê²Œ ë§Œë“¤ê¸° ìœ„í•´)
&lt;code&gt;- When the code is using methods in the generic class that don&#39;t depend on the type parameter. For example, List.size or List.clear. In fact, Class&amp;lt;?&amp;gt; is so often used because most of the methods in Class&amp;lt;T&amp;gt; do not depend on T.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;printList ë©”ì„œë“œë¥¼ ì‚´í´ë³´ì.
&lt;code&gt;Consider the following method, printList:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void printList(List&amp;lt;Object&amp;gt; list) {
    for (Object elem : list)
        System.out.println(elem + &amp;quot; &amp;quot;); // elem.toString() ìë™ìœ¼ë¡œ í˜¸ì¶œë¨.
    System.out.println();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;printListëŠ” Listê°€ ê°€ì§„ ê°ì²´ê°€ ì–´ë–¤ íƒ€ì…ì´ë“ ê°„ì— ìƒê´€ì—†ì´ printí•˜ê³  ì‹¶ì–´í•œë‹¤. í•˜ì§€ë§Œ List ê°ì²´ëŠ” Object íƒ€ì…ì˜ ê°ì²´ë§Œ ì¶œë ¥í•  ìˆ˜ ìˆë‹¤. (ì°¸ì¡°:&lt;a href=&#34;../8&#34;&gt;ì œë„¤ë¦­ìŠ¤, ìƒì†, ì„œë¸Œíƒ€ì…&lt;/a&gt;) List&amp;lt;Object&amp;gt;ëŠ” List&amp;lt;Integer&amp;gt;, List&amp;lt;String&amp;gt;, List&amp;lt;Double&amp;gt;ì„ ì¶œë ¥í•  ìˆ˜ ì—†ë‹¤. ì™œëƒí•˜ë©´ List&amp;lt;Object&amp;gt; íƒ€ì…ì˜ stub type(ìŠ¤í…íƒ€ì… ìš©ì–´ ì•„ì‹œëŠ”ë¶„ ê³µìœ  ë¶€íƒìš” ã… ã… )ì´ ì•„ë‹ˆë‹¤. ì•„ë˜ëŠ” List&amp;lt;?&amp;gt;ë¥¼ ì‚¬ìš©í•´ì„œ generic ë©”ì„œë“œì¸ printListë¥¼ ì‘ì„±í•œ ì˜ˆì´ë‹¤..&lt;/p&gt;

&lt;p&gt;&lt;code&gt;The goal of printList is to print a list of any type, but it fails to achieve that goal â€” it prints only a list of Object instances; it cannot print List&amp;lt;Integer&amp;gt;, List&amp;lt;String&amp;gt;, List&amp;lt;Double&amp;gt;, and so on, because they are not subtypes of List&amp;lt;Object&amp;gt;. To write a generic printList method, use List&amp;lt;?&amp;gt;:&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(ì—­ì ì¶”ê°€ - ìœ„ì˜ ì˜ˆê°€ ì„¤ëª…í•˜ëŠ” ì½”ë“œ - ì»´íŒŒì¼ ì—ëŸ¬ ë°œìƒ)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Integer&amp;gt; integerList = Arrays.asList(1,2);
printList(integerList);   // ì»´íŒŒì¼ ì—ëŸ¬
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void printList(List&amp;lt;?&amp;gt; list) {
    for (Object elem: list)
        System.out.print(elem + &amp;quot; &amp;quot;);
    System.out.println();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì•„ë¬´ íƒ€ì…ì„ Aë¡œ ì§€ì¹­í–ˆì„ë•Œ, List&amp;lt;?&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ì€ List&amp;lt;A&amp;gt;ì´ ì„±ë¦½ì´ ë˜ê¸° ë•Œë¬¸ì—, printList ë©”ì„œë“œê°€ ëª¨ë“  íƒ€ì…ì„ ëŒ€ìƒìœ¼ë¡œ printí•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;Because for any concrete type A, List&amp;lt;A&amp;gt; is a subtype of List&amp;lt;?&amp;gt;, you can use printList to print a list of any type:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Integer&amp;gt; li = Arrays.asList(1, 2, 3);
List&amp;lt;String&amp;gt;  ls = Arrays.asList(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;);
printList(li);
printList(ls);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì°¸ê³ : Arrays.asList ë©”ì„œë“œëŠ” ë²”ìœ„ì—†ëŠ” ì™€ì¼ë“œì¹´ë“œë¥¼ ì‚¬ìš©í•´ì„œ êµ¬í˜„ë˜ì—ˆë‹¤. Arrays.asListë¼ëŠ” static íŒ©í† ë¦¬ ë©”ì„œë“œëŠ” ë°°ì—´ì„ êµ¬ì²´í™”í•˜ì—¬ ë³€ê²½í•˜ê³ (ìš”ì†Œë“¤ì˜ ê³µí†µ íƒ€ì…ì„ íƒ€ì…ì¶”ë¡ )  ê³ ì •ëœ ì‚¬ì´ì¦ˆì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•œë‹¤.
&lt;code&gt;Note: The Arrays.asList method is used in examples throughout this lesson. This static factory method converts the specified array and returns a fixed-size list.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(ì¤‘ìš”!)List&lt;Object&gt;ì™€ List&amp;lt;?&amp;gt;ê³¼ ë‹¤ë¥´ë‹¤. List&lt;Object&gt;ì— Object íƒ€ì…ì´ë‚˜ Objectì˜ ì„œë¸Œíƒ€ì…ì„ insertí•  ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ List&amp;lt;?&amp;gt;ì—ëŠ” nullë§Œ insertí•  ìˆ˜ ìˆë‹¤.(í•˜ê³ ìí•˜ëŠ” ë§ì´ ë¬´ì–¸ì§€ ì´í•´ê°€ ì•ˆëœë‹¤;;;) ì™€ì¼ë“œì¹´ë“œ ì‚¬ìš© ì„¹ì…˜ì€ì€ ìƒí™©ë³„ ì–´ë–¤ ì™€ì¼ë“œì¹´ë“œë¥¼ ì‚¬ìš©í• ì§€ ê²°ì •ì— ëŒ€í•œ ê°€ì´ë“œë¼ì¸ì„ ì œê³µí•œë‹¤.
&lt;code&gt;It&#39;s important to note that List&amp;lt;Object&amp;gt; and List&amp;lt;?&amp;gt; are not the same. You can insert an Object, or any subtype of Object, into a List&amp;lt;Object&amp;gt;. But you can only insert null into a List&amp;lt;?&amp;gt;. The Guidelines for Wildcard Use section has more information on how to determine what kind of wildcard, if any, should be used in a given situation.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(9) Java Generics: íƒ€ì…ì¶”ë¡ (Type Inference)</title>
      <link>http://durtchrt.github.io/blog/java/generics/9/</link>
      <pubDate>Sat, 05 Nov 2016 18:23:01 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/9/</guid>
      <description>

&lt;p&gt;ìš©ì–´&lt;/p&gt;

&lt;p&gt;statement: ë¬¸ì¥ìœ¼ë¡œ í•´ì„í•˜ë©´ ì˜¤í•´ì˜ ì—¬ì§€ê°€ ìˆì–´ì„œ statement ì˜ë¬¸ ê·¸ëŒ€ë¡œ ì‘ì„±í•œë‹¤. ì»´í“¨í„° í”„ë¡œê·¸ë˜ë°ì—ì„œëŠ” statementë¥¼ ë…ë¦½ì ì¸ ìš”ì†Œì˜ ìµœì†Œ ë‹¨ìœ„. &lt;a href=&#34;https://en.wikipedia.org/wiki/Statement_(computer_science)&#34;&gt;ì˜ë¬¸ìœ„í‚¤&lt;/a&gt;ì˜ ì¤‘ê°„ì„ ë³´ë©´ Kinds of statements íŒŒíŠ¸ì— Simple statments, Compound statements ë¶€ë¶„ì˜ ì½”ë“œë¥¼ ë³´ë©´ ëŠë‚Œì´ ì˜¨ë‹¤.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html&#34;&gt;ì›ë¬¸ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;íƒ€ì…ì¶”ë¡ -type-inference&#34;&gt;íƒ€ì…ì¶”ë¡  &lt;code&gt;Type Inference&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;íƒ€ì…ì¶”ë¡ ì€ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ì½”ë“œì—ì„œ íƒ€ì…ì¸ìê°€ ì •ì˜í•œëŒ€ë¡œ ì œëŒ€ë¡œ ì“°ì˜€ëŠ”ì§€ ì‚´í´ë³´ëŠ” ì»´íŒŒì¼ëŸ¬ì˜ ëŠ¥ë ¥ì´ë‹¤. íƒ€ì…ì¶”ë¡ ì€ ì¸ìì˜ íƒ€ì…ì„ í™•ì¸í•˜ê³  ë§Œì•½ ì‚¬ìš©ê°€ëŠ¥í•˜ë‹¤ë©´, í•´ë‹¹ íƒ€ì…ì„ í• ë‹¹í•˜ê±°ë‚˜ ë¦¬í„´ë  ê²ƒì´ë‹¤. ê²°êµ­ íƒ€ì…ì¶”ë¡ ì€ ëª¨ë“  ì¸ìì— ë™ì‘í•´ì„œ ê°€ì¥ êµ¬ì²´ì ì¸ íƒ€ì…ì„ ì°¾ëŠ” ê²ƒì„ ì‹œë„í•œë‹¤.(ë­”ê°€ ë§ì´ ì–´ë µë‹¤;;)
&lt;code&gt;[Type inference is a Java compiler&#39;s ability to look at each method invocation and corresponding declaration to determine the type argument (or arguments) that make the invocation applicable.] The inference algorithm determines the types of the arguments and, if available, the type that the result is being assigned, or returned. Finally, the inference algorithm tries to find the most specific type that works with all of the arguments.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;~&lt;del&gt;ì•„ë˜ì˜ ì˜ˆëŠ” ë§ˆì§€ë§‰ ì§€ì ì„ ì„¤ëª…í•œë‹¤.&lt;/del&gt;~ íƒ€ì…ì¶”ë¡ ì€ ë‘ë²ˆì§¸ ì¸ìê°€ ì „ë‹¬ë  ë•Œ pick ë©”ì„œë“œëŠ” Serializableë¡œ ê²°ì •ë˜ì–´ì§‘ë‹ˆë‹¤.
(ì—­ì£¼: pickì˜ ë‘ ì¸ì a1, a2ëŠ” íƒ€ì…ì¸ìë¡œ Stringê³¼ ArrayListë¥¼ ì „ë‹¬ ë°›ëŠ”ë‹¤. ë‘˜ì˜ ê³µí†µì ì€ Serializable ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ í´ë˜ìŠ¤ë¼ëŠ” ê²ƒì´ë‹¤. ì¸ìë“¤ì´ ê°™ì€ íƒ€ì…ì´ ì•„ë‹ˆë©´ ê°ê° ì¸ìë“¤ì˜ íƒ€ì…ì—ì„œ ê³µí†µìœ¼ë¡œ ì“°ëŠ” ìŠˆí¼ íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ . ì½”ë“œë ˆë²¨ë¡œ ì‘ì„±í•œê±°ë¼ ì¶”ë¡ ì´ë¼í•˜ê¸´ ë­í•œë°&amp;hellip; ì¼ë‹¨ ì§„í–‰.)
&lt;code&gt;To illustrate this last point, in the following example, inference determines that the second argument being passed to the pick method is of type Serializable:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static &amp;lt;T&amp;gt; T pick(T a1, T a2) { return a2; }
Serializable s = pick(&amp;quot;d&amp;quot;, new ArrayList&amp;lt;String&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;íƒ€ì…ì¶”ë¡ ê³¼-generic-ë©”ì„œë“œ-type-inference-and-generic-methods&#34;&gt;íƒ€ì…ì¶”ë¡ ê³¼ Generic ë©”ì„œë“œ &lt;code&gt;Type Inference and Generic Methods&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Generic ë©”ì„œë“œëŠ” êº½ì‡ ì•ˆì— íƒ€ì…ì„ ì‘ì„±í•˜ì§€ ì•Šê³ (ë¹ˆíƒ€ì…ì¸ì) ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë©´ íƒ€ì…ì¶”ë¡ ì„ ë³´ì—¬ì¤€ë‹¤. BoxDemo ì˜ˆë¥¼ ë³´ì‹œì˜¤. ì´ ì˜ˆëŠ” Box í´ë˜ìŠ¤ë¥¼ í•„ìš”ë¡œí•©ë‹ˆë‹¤.
&lt;code&gt;Generic Methods introduced you to type inference, which enables you to invoke a generic method as you would an ordinary method, without specifying a type between angle brackets. Consider the following example, BoxDemo, which requires the Box class:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BoxDemo {

  public static &amp;lt;U&amp;gt; void addBox(U u, 
      java.util.List&amp;lt;Box&amp;lt;U&amp;gt;&amp;gt; boxes) {
    Box&amp;lt;U&amp;gt; box = new Box&amp;lt;&amp;gt;();
    box.set(u);
    boxes.add(box);
  }

  public static &amp;lt;U&amp;gt; void outputBoxes(java.util.List&amp;lt;Box&amp;lt;U&amp;gt;&amp;gt; boxes) {
    int counter = 0;
    for (Box&amp;lt;U&amp;gt; box: boxes) {
      U boxContents = box.get();
      System.out.println(&amp;quot;Box #&amp;quot; + counter + &amp;quot; contains [&amp;quot; +
             boxContents.toString() + &amp;quot;]&amp;quot;);
      counter++;
    }
  }

  public static void main(String[] args) {
    java.util.ArrayList&amp;lt;Box&amp;lt;Integer&amp;gt;&amp;gt; listOfIntegerBoxes =
      new java.util.ArrayList&amp;lt;&amp;gt;();
    BoxDemo.&amp;lt;Integer&amp;gt;addBox(Integer.valueOf(10), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(30), listOfIntegerBoxes);
    BoxDemo.outputBoxes(listOfIntegerBoxes);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ì˜ˆì œëŠ” ì•„ë˜ì™€ ê°™ì€ ê²°ê³¼ë¥¼ ì¶œë ¥í•œë‹¤.
&lt;code&gt;The following is the output from this example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Box #0 contains [10]
Box #1 contains [20]
Box #2 contains [30]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generic ë©”ì„œë“œì¸ addboxëŠ” Uë¼ëŠ” íƒ€ì…ë§¤ê°œë³€ìˆ˜ê°€ ì„ ì–¸ë˜ì–´ìˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ, ìë°”ì»´íŒŒì¼ëŸ¬ëŠ” generic ë©”ì„œë“œ í˜¸ì¶œí•˜ëŠ” ì½”ë“œë¥¼ ë³´ê³  íƒ€ì…íŒŒë¼ë©”í„°ë¥¼ ì¶”ë¡ í•  ìˆ˜ ìˆë‹¤. ê·¸ ê²°ê³¼, ëŒ€ë¶€ë¶„ íƒ€ì…ì„ ê¼­ ëª…ì‹œí•˜ì§€ ì•Šì•„ë„ ëœë‹¤. ì˜ˆë¥¼ ë“¤ì–´ addBoxë¼ëŠ” generic ë©”ì„œë“œë¥¼ í˜¸ì¶œí• ë•Œ, ì•„ë˜ ì½”ë“œì²˜ëŸ¼ êµ¬ì²´ì ì¸ íƒ€ì… ë§¤ê°œë³€ìˆ˜ë¥¼ ì¤„ ìˆ˜ ìˆë‹¤.
&lt;code&gt;The generic method addBox defines one type parameter named U. Generally, a Java compiler can infer the type parameters of a generic method call. Consequently, in most cases, you do not have to specify them. For example, to invoke the generic method addBox, you can specify the type parameter with a type witness as follows:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BoxDemo.&amp;lt;Integer&amp;gt;addBox(Integer.valueOf(10), listOfIntegerBoxes);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ì½”ë“œ ëŒ€ì‹  ì•„ë˜ ì½”ë“œì²˜ëŸ¼ íƒ€ì… ì •ë³´ë¥¼ ì œê³µí•˜ì§€ ì•Šê³  ì½”ë“œë¥¼ ì‘ì„±í•´ë„, ìë°” ì»´íŒŒì¼ëŸ¬ëŠ” íƒ€ì…ë§¤ê°œë³€ìˆ˜ê°€ Integerë¼ê³  (ë©”ì„œë“œì˜ ì¸ìë“¤ë¡œë¶€í„°) ìë™ìœ¼ë¡œ ì¶”ë¡ ì„ í•œë‹¤.
&lt;code&gt;Alternatively, if you omit the type witness,a Java compiler automatically infers (from the method&#39;s arguments) that the type parameter is Integer:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;íƒ€ì…ì¶”ë¡ ê³¼-generic-ê°ì²´-type-inference-and-instantiation-of-generic-classes&#34;&gt;íƒ€ì…ì¶”ë¡ ê³¼ generic ê°ì²´  &lt;code&gt;Type Inference and Instantiation of Generic Classes&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic í´ë˜ìŠ¤ë¥¼ ìƒì„±ìë¥¼ í†µí•´ ê°ì²´ë¥¼ ìƒì„±í•  ë•Œ íƒ€ì…ì¸ì ëŒ€ì‹  ë¹ˆíƒ€ì…íŒŒë¼ë¯¸í„°(&amp;lt;&amp;gt;)ë¥¼ ì‚¬ìš©í• ë•Œ ìë°” ì»´íŒŒì¼ëŸ¬ëŠ” ì½”ë“œ ë¬¸ë§¥ìœ¼ë¡œë¶€í„° íƒ€ì…ì¸ìë¥¼ ìœ ì¶”í•  ìˆ˜ ìˆë‹¤. ë¹„ê³µì‹ì ìœ¼ë¡œ í•œìŒì˜ êº½ì‡ (&amp;lt;&amp;gt;)ëŠ” ë‹¤ì´ì•„ëª¬ë“œë¼ê³  ë¶€ë¥¸ë‹¤.
&amp;lsquo;You can replace the type arguments required to invoke the constructor of a generic class with an empty set of type parameters (&amp;lt;&amp;gt;) as long as the compiler can infer the type arguments from the context. This pair of angle brackets is informally called the diamond.&amp;rsquo;&lt;/p&gt;

&lt;p&gt;ì˜ˆë¥¼ ë“¤ì–´ ë³€ìˆ˜ ì„ ì–¸ì„ ë³´ì.
&lt;code&gt;For example, consider the following variable declaration:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; myMap = new HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(ìœ„ì˜ ì˜ˆì œ ì²˜ëŸ¼)generic í´ë˜ìŠ¤ì˜ ìƒì„±ìì— íƒ€ì…ë§¤ê°œë³€ìˆ˜í™”í•œ ìƒì„±ì ëŒ€ì‹  (ì•„ë˜ ì˜ˆì œ ì²˜ëŸ¼)&amp;lt;&amp;gt;ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;You can substitute the parameterized type of the constructor with an empty set of type parameters (&amp;lt;&amp;gt;):&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; myMap = new HashMap&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generic í´ë˜ìŠ¤ë¥¼ ê°ì²´í™”í•  ë•Œ íƒ€ì…ì¶”ë¡ ì„ ì‹œí‚¤ë ¤ë©´ ë°˜ë“œì‹œ ë‹¤ì´ì•„ëª¬ë“œ ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤. ì•„ë˜ì˜ ì˜ˆë¥¼ ë³´ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” Hashë§µì„ rawíƒ€ì…ìœ¼ë¡œ ì¸ì‹í•´ì„œ ê²½ê³ ë¥¼ í•œë‹¤.(ì„ ì–¸ë¬¸ì˜ Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;ì„ ë³´ê³  í• ë‹¹ë¬¸ì˜ HashMapì˜ ìƒì„±ìëŠ” íƒ€ì…ì¶”ë¡ ì„ í•˜ì§€ ì•ŠëŠ”ë‹¤. ê·¸ëƒ¥ raw íƒ€ì…ì´ ëœë‹¤. )
&lt;code&gt;Note that to take advantage of type inference during generic class instantiation, you must use the diamond. In the following example, the compiler generates an unchecked conversion warning because the HashMap() constructor refers to the HashMap raw type, not the Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; type:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; myMap = new HashMap(); // unchecked conversion warning
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;íƒ€ì…ì¶”ë¡ ê³¼-generic-íƒ€ì…ì˜-generic-ìƒì„±ì-ê·¸ë¦¬ê³ -non-generic-í´ë˜ìŠ¤ê°€-type-inference-and-generic-constructors-of-generic-and-non-generic-classes&#34;&gt;íƒ€ì…ì¶”ë¡ ê³¼ generic íƒ€ì…ì˜ Generic ìƒì„±ì ê·¸ë¦¬ê³  Non-Generic í´ë˜ìŠ¤ê°€ &lt;code&gt;Type Inference and Generic Constructors of Generic and Non-Generic Classes&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic í´ë˜ìŠ¤ì™€ non-generic í´ë˜ìŠ¤ëŠ” ë‘˜ë‹¤ generic(ì¼ë°˜ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ì„ ì–¸)ì´ ë  ìˆ˜ ìˆë‹¤. ì•„ë˜ ì˜ˆë¥¼ ë³´ì
&lt;code&gt;Note that constructors can be generic (in other words, declare their own formal type parameters) in both generic and non-generic classes. Consider the following example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MyClass&amp;lt;X&amp;gt; {
  &amp;lt;T&amp;gt; MyClass(T t) {
    // ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MyClass í´ë˜ìŠ¤ì˜ ê°ì²´ ìƒì„±ì„ ì‚´í´ë³´ë©´
&lt;code&gt;Consider the following instantiation of the class MyClass:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new MyClass&amp;lt;Integer&amp;gt;(&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ì½”ë“œëŠ” MyClass&amp;lt;Integer&amp;gt;ë¼ëŠ” ë§¤ê°œë³€ìˆ˜í™”ëœ íƒ€ì…ì˜ ê°ì²´ë¥¼ ìƒì„±í•˜ëŠ” statementì´ë‹¤. ì´ statementëŠ” generic í´ë˜ìŠ¤ì¸ MyClass&amp;lt;X&amp;gt;ì˜ íƒ€ì…ë§¤ê°œë³€ìˆ˜ì˜ í˜•ì‹ì„ Integer íƒ€ì…ìœ¼ë¡œ êµ¬ì²´í™”í•˜ë„ë¡ ëª…ì‹œí•œë‹¤. ì¤‘ìš”í•œì ì€ generic í´ë˜ìŠ¤ì˜ ìƒì„±ìëŠ” Të¼ëŠ” í˜•ì‹ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ í¬í•¨í•´ì•¼í•œë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” generic í´ë˜ìŠ¤ì˜ ìƒì„±ìì˜ í˜•ì‹ íŒŒë¼ë©”í„° Të¥¼ String íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ í•œë‹¤.(ì™œëƒí•˜ë©´ ìƒì„±ìì˜ ë§¤ê°œë³€ìˆ˜ëŠ” String íƒ€ì…ì˜ ê°ì²´ì´ê¸° ë•Œë¬¸ì´ë‹¤.)
&lt;code&gt;This statement creates an instance of the parameterized type MyClass&amp;lt;Integer&amp;gt;; the statement explicitly specifies the type Integer for the formal type parameter, X, of the generic class MyClass&amp;lt;X&amp;gt;. Note that the constructor for this generic class contains a formal type parameter, T. The compiler infers the type String for the formal type parameter, T, of the constructor of this generic class (because the actual parameter of this constructor is a String object).&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(ì—­ì - ë²ˆì—­í•˜ë‹¤ê°€ ë„í†µ ë­”ë§ì¸ì§€ ëª°ë¼ì„œ ì½”ë”©í•´ë´„.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Main {
	public static void main(String[] args) {
		MyClass&amp;lt;Integer&amp;gt; a = new MyClass&amp;lt;&amp;gt;(&amp;quot;&amp;quot;);
		System.out.println(a.x.getClass().getSimpleName());
	}
}

class MyClass&amp;lt;X&amp;gt; {
	X x;
	&amp;lt;T&amp;gt; MyClass(T t) {
		this.x = (X) t;
	}
}
// ëŸ°íƒ€ì„ ì—ëŸ¬ ë°œìƒë˜ëŠ” ì½”ë“œ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(ì—­ì)MyClassì˜ ìƒì„±ìì˜ Të¼ëŠ” íƒ€ì…ë§¤ê°œë³€ìˆ˜ë§Œ ì ìœ¼ë©´ ì»´íŒŒì¼ì´ ì•ˆëœë‹¤. ìƒì„±ì ì•ì— &amp;lt;T&amp;gt;ë¥¼ ë„£ì–´ì¤˜ì•¼ ì»´íŒŒì¼ì´ ë˜ëŠ”ë° ìš”ë†ˆì„ í˜•ì‹íƒ€ì…ë§¤ê°œë³€ìˆ˜ê°€ë¡œ ì§€ì¹­í•˜ëŠ” ê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤. í´ë˜ìŠ¤ì— ì ì–´ì¤€ &amp;lt;X&amp;gt;ë‘ì€ ë‹¤ë¦„ì„ ì£¼ì˜. ì•„ì§ì€ ë”±íˆ ì–´ëŠ ìƒí™©ì— ì¨ì•¼í• ì§€ ì˜ ëª¨ë¥´ê² ë‹¤&amp;hellip;.&lt;/p&gt;

&lt;p&gt;generic ë©”ì„œë“œì²˜ëŸ¼ generic ìƒì„±ìì—ì„œ ì‹¤ì œ íƒ€ì…íŒŒë¼ë©”í„°ë¥¼ ì¶”ë¡ í•˜ëŠ” ëŠ¥ë ¥ì€ Java SE 7ì´ì „ ì»´íŒŒì¼ëŸ¬ì—ì„œ ë¦´ë¦¬ì¦ˆë˜ì—ˆë‹¤.(ì—­ì??? ì´ë¶€ë¶„ì´ ì´í•´ê°€ ì•ˆê°) í•˜ì§€ë§Œ Java SE 7 ì´í›„ ì»´íŒŒì¼ëŸ¬ëŠ” ë‹¤ì´ì•„ëª¬ë“œì—°ì‚°ì(&amp;lt;&amp;gt;)ë¥¼ ì‚¬ìš©í•´ì„œ generic í´ë˜ìŠ¤ë¥¼ ê°ì²´ ìƒì„±í•  ë•Œ ì‹¤ì œ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ì¶”ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì•„ë˜ì˜ ì˜ˆë¥¼ ë³´ì„¸ìš”.
&lt;code&gt;Compilers from releases prior to Java SE 7 are able to infer the actual type parameters of generic constructors, similar to generic methods. However, compilers in Java SE 7 and later can infer the actual type parameters of the generic class being instantiated if you use the diamond (&amp;lt;&amp;gt;). Consider the following example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MyClass&amp;lt;Integer&amp;gt; myObject = new MyClass&amp;lt;&amp;gt;(&amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ì˜ˆì œëŠ” ì»´íŒŒì¼ëŸ¬ê°€ generic í´ë˜ìŠ¤ MyClass&amp;lt;X&amp;gt;ì˜ í˜•ì‹íƒ€ì… íŒŒë¼ë©”í„° Xë¥¼ Integer íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ í•œë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” generic í´ë˜ìŠ¤ì˜ ìƒì„±ìì˜ í˜•ì‹ë§¤ê°œë³€ìˆ˜ Tì— String íƒ€ì…ì„ ì¶”ë¡ í•œë‹¤.
&lt;code&gt;In this example, the compiler infers the type Integer for the formal type parameter, X, of the generic class MyClass&amp;lt;X&amp;gt;. It infers the type String for the formal type parameter, T, of the constructor of this generic class.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì¤‘ìš”: íƒ€ì…ì¶”ë¡  ì•Œê³ ë¦¬ì¦˜ì€ ì¸ì, ëŒ€ìƒ íƒ€ì…, ëª…ë°±íˆ ê¸°ëŒ€ë˜ëŠ” ë¦¬í„´ íƒ€ì…ë§Œ ì‚¬ìš©í•œë‹¤. ì¶”ë¡  ì•Œê³ ë¦¬ì¦˜ì€ í”„ë¡œê·¸ë¨ì—ì„œ ë‚˜ì¤‘ì— ê²°ê³¼ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤. (ì—­ì: ë‚´ìš©ì´ ëª…í™•íˆ ì•ˆë“¤ì–´ì˜´.)
&lt;code&gt;Note: It is important to note that the inference algorithm uses only invocation arguments, target types, and possibly an obvious expected return type to infer types. The inference algorithm does not use results from later in the program.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;target-types&#34;&gt;&lt;code&gt;Target Types&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ìë°” ì»´íŒŒì¼ëŸ¬ëŠ” generic ë©”ì„œë“œ í˜¸ì¶œì— íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ì¶”ë¡ í•˜ëŠ” target typingì€ ì¥ì ì„ ê°€ì§„ë‹¤. target type í‘œí˜„ì‹ì€ ìë°” ì»´íŒŒì¼ëŸ¬ê°€ ê¸°ëŒ€í•˜ëŠ” ë°ì´í„° íƒ€ì…ì´ë‹¤. Collection.emptyList ë©”ì„œë“œë¥¼ ì‚´í´ë³´ë©´ ì•„ë˜ì™€ ê°™ì´ ì„ ì–¸ë˜ì–´ìˆë‹¤.
&lt;code&gt;The Java compiler takes advantage of target typing to infer the type parameters of a generic method invocation. [The target type of an expression is the data type that the Java compiler expects depending on where the expression appears.] Consider the method Collections.emptyList, which is declared as follows:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; emptyList();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;í• ë‹¹ë¬¸ì„ ì‚´í´ë³´ë©´:
&lt;code&gt;Consider the following assignment statement:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; listOne = Collections.emptyList();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì´ statementëŠ” List&lt;String&gt;ì˜ ê°ì²´ë¥¼ ê¸°ëŒ€í•œë‹¤. ì´ ë°ì´í„° íƒ€ì…ì´ target typeì´ë‹¤. ì™œëƒí•˜ë©´ emptyList ë©”ì„œë“œëŠ” List&lt;T&gt; íƒ€ì…ì˜ ê°’ì„ ë¦¬í„´í•œë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” íƒ€ì…ì¸ìëŠ” ë°˜ë“œì‹œ String íƒ€ì…ì˜ ê°’ì¼ ê²ƒì´ë¼ê³  ì¶”ë¡ í•œë‹¤. ì´ëŠ” Java SE 7 ì´ìƒì—ì„œ ë™ì‘í•œë‹¤. ì¶”ë¡  ëŒ€ì‹ ì— ì•„ë˜ì˜ ì˜ˆì²˜ëŸ¼ íƒ€ì…ë§¤ê°œë³€ìˆ˜ Tì˜ íƒ€ì…ì¸ìê°’ì„ íŠ¹ì • íƒ€ì…ê°’ì„ ëª…ì‹œí•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;This statement is expecting an instance of List&amp;lt;String&amp;gt;; this data type is the target type. Because the method emptyList returns a value of type List&amp;lt;T&amp;gt;, the compiler infers that the type argument T must be the value String. This works in both Java SE 7 and 8. Alternatively, you could use a type witness and specify the value of T as follows:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; listOne = Collections.&amp;lt;String&amp;gt;emptyList();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;í•˜ì§€ë§Œ ìœ„ì˜ ì½”ë“œ ë¬¸ë§¥ìƒ target typeì´ í•„ìš”ì¹˜ ì•Šë‹¤. ì½”ë“œë¬¸ë§¥ìƒ target typeì´ í•„ìš”í•œ ì˜ˆë¥¼ ì•„ë˜ ì½”ë“œë¥¼ ë³´ë©° ì‚´í´ë³´ì.
&lt;code&gt;However, this is not necessary in this context. It was necessary in other contexts, though. Consider the following method:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void processStringList(List&amp;lt;String&amp;gt; stringList) {
    // process stringList
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë¹ˆë¦¬ìŠ¤íŠ¸ì™€ í•¨ê»˜ processStringList ë©”ì„œë“œë¥¼ í˜¸ì¶œí•œë‹¤ê³  ê°€ì •í•˜ì. Java SE 7ì—ì„œëŠ” ì•„ë˜ì˜ ì½”ë“œëŠ” ì»´íŒŒì¼ ë˜ì§€ ì•ŠëŠ”ë‹¤.
&lt;code&gt;Suppose you want to invoke the method processStringList with an empty list. In Java SE 7, the following statement does not compile:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;processStringList(Collections.emptyList());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java SE 7 ì»´íŒŒì¼ëŸ¬ëŠ” ì•„ë˜ì˜ ì—ëŸ¬ë©”ì„¸ì§€ë¥¼ ë˜ì§„ë‹¤.
&lt;code&gt;The Java SE 7 compiler generates an error message similar to the following:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shelll&#34;&gt;List&amp;lt;Object&amp;gt; cannot be converted to List&amp;lt;String&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì»´íŒŒì¼ëŸ¬ëŠ” Tì˜ íƒ€ì…ì¸ìê°€ í•„ìš”í•œë° TëŠ” target typeì„ ì£¼ì§€ ì•Šìœ¼ë©´ Objectì´ë‹¤. ê²°êµ­, Collection.emptyListì— íƒ€ì…ì¸ìëŠ” List&lt;Objec&gt; íƒ€ì…ì´ë‹¤. ê·¸ëŸ¬ë¯€ë¡œ Java SE 7ì€ ë°˜ë“œì‹œ ì•„ë˜ì˜ ì˜ˆì²˜ëŸ¼ íƒ€ì…ì¸ìë¥¼ ëª…í™•íˆ ì•Œë ¤ì¤˜ì•¼í•œë‹¤.
&lt;code&gt;The compiler requires a value for the type argument T so it starts with the value Object. Consequently, the invocation of Collections.emptyList returns a value of type List&amp;lt;Object&amp;gt;, which is incompatible with the method processStringList. Thus, in Java SE 7, you must specify the value of the value of the type argument as follows:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;processStringList(Collections.&amp;lt;String&amp;gt;emptyList());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java SE 8ì—ì„œëŠ” ë”ì´ìƒ í•„ìš”ì¹˜ ì•Šë‹¤. ì´ í‘œê¸°ë²•ì€ target typeì€ ë©”ì„œë“œ ì¸ìë¥¼ í¬í•¨í•´ì„œ í™•ì¥í–ˆë‹¤ (ì•„ë˜ ì˜ˆì²˜ëŸ¼ processStringList ë©”ì„œë“œì— ì¸ìë¥¼ ë„£ëŠ”ê²ƒì²˜ëŸ¼). ì´ëŸ°ê²½ìš°, processStringListëŠ” List&lt;String&gt; íƒ€ì…ì˜ ì¸ìë¥¼ í•„ìš”ë¡œí•œë‹¤. Collections.emptyList ë©”ì„œë“œëŠ” List&lt;T&gt; íƒ€ì…ì˜ ê°’ì„ ë¦¬í„´í•œë‹¤. ê·¸ëŸ¼ List&lt;String&gt;ì˜ target typeì„ ì‚¬ìš©í•˜ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” Tì˜ íƒ€ì…ì¸ìë¥¼ Stringìœ¼ë¡œ ì¶”ë¡ í•˜ë‹¤. ë”°ë¼ì„œ Java SE 8ì€ ì•„ë˜ì˜ ë¬¸ì¥ì´ ì»´íŒŒì¼ëœë‹¤.
&lt;code&gt;This is no longer necessary in Java SE 8. The notion of what is a target type has been expanded to include method arguments, such as the argument to the method processStringList. In this case, processStringList requires an argument of type List&amp;lt;String&amp;gt;. The method Collections.emptyList returns a value of List&amp;lt;T&amp;gt;, so using the target type of List&amp;lt;String&amp;gt;, the compiler infers that the type argument T has a value of String. Thus, in Java SE 8, the following statement compiles:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;processStringList(Collections.emptyList());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë” ë§ì€ ì •ë³´ëŠ” &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&#34;&gt;ëŒë‹¤í‘œí˜„ì‹&lt;/a&gt;ì—ì„œ &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#target-typing&#34;&gt;Target Typing&lt;/a&gt;ì„ ë³´ì„¸ìš”.
&lt;code&gt;See Target Typing in Lambda Expressions for more information.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(8) Java Generics: ì œë„¤ë¦­ìŠ¤, ìƒì†, ì„œë¸Œíƒ€ì… (Generics, Inheritance, and Subtypes)</title>
      <link>http://durtchrt.github.io/blog/java/generics/8/</link>
      <pubDate>Sat, 05 Nov 2016 08:48:42 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/8/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/inheritance.html&#34;&gt;ì›ë¬¸ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ìš©ì–´
ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜(method signature): ë©”ì„œë“¤ê°„ì— ê°œì„± ì£¼ëŠ”ê²ƒìœ¼ë¡œ ìë°” ì»´íŒŒì¼ëŸ¬ì¸ì§€ ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë²„ë¡œë”©ì„ í•œë‹¤.  ìë°”ì—ì„œëŠ” ë©”ì„œë“œëª…, íŒŒë¼ë¯¸í„° ê°¯ìˆ˜, íŒŒë¼ë¯¸í„° íƒ€ì…, íŒŒë¼ë¯¸í„° ìˆœì„œ(ìë°”ì—ì„œëŠ” ë¦¬í„´íƒ€ì…ì€ ì‹œê·¸ë‹ˆì²˜ê°€ ì•„ë‹ˆë‹¤.) - íŒŒë¼ë¯¸í„°ëª…ë„ ì‹œê·¸ë‹ˆì²˜ì¸ì§€ëŠ” ì•„ë¦¬ê¹Œë¦¬í•˜ë‹¤. ë©”ì„œë“œ ì˜¤ë²„ë¡œë”©ë¥¼ ìƒê°í•˜ë©´ ë§ëŠ”ê±° ê°™ì€ë°&amp;hellip; ì¢€ë” ìƒê°í•´ë³´ê³  ë‚´ìš© ìˆ˜ì • ì˜ˆì •
ì½˜í¬ë¦¬íŠ¸ íƒ€ì…, êµ¬í˜„íƒ€ì…(concrete type): ìë°”ì—ì„œëŠ” íƒ€ì…ë“¤ì¤‘ interface, abstract classë¥¼ ì œì™¸í•˜ê³  ë‚¨ì€ classë¥¼ concrete íƒ€ì…ìœ¼ë¡œ ì´í•´í•˜ë©´ ë  ë“¯.&lt;a href=&#34;http://dreuarchive.cra.org/2002/heise/typeComp.html&#34;&gt;ì°¸ê³ ë§í¬ - ì˜ë¬¸: ë²ˆì—­ ì˜ˆì •&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì œë„¤ë¦­ìŠ¤-ìƒì†-ì„œë¸Œíƒ€ì…-generics-inheritance-and-subtypes&#34;&gt;ì œë„¤ë¦­ìŠ¤, ìƒì†, ì„œë¸Œíƒ€ì… &lt;code&gt;Generics, Inheritance, and Subtypes&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;íƒ€ì…ê°„ í˜¸í™˜ì´ëœë‹¤ë©´ íŠ¹ì • íƒ€ì…ì˜ ê°ì²´ë¥¼ ë‹¤ë¥¸ íƒ€ì…ì— í• ë‹¹ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. ì•„ë˜ì˜ ì½”ë“œì²˜ëŸ¼ Object íƒ€ì…ì€ Integerì˜ ìŠˆí¼íƒ€ì…ì¤‘ í•˜ë‚˜ì´ê¸° ë•Œë¬¸ì— Integer íƒ€ì…ì¸ someIntegerì˜ ê°ì²´ê°€ Object íƒ€ì…ì¸ someObjectì— í• ë‹¹ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.
&lt;code&gt;As you already know, it is possible to assign an object of one type to an object of another type provided that the types are compatible. For example, you can assign an Integer to an Object, since Object is one of Integer&#39;s supertypes:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object someObject = new Object();
Integer someInteger = new Integer(10);
someObject = someInteger;   // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê°ì²´ì§€í–¥ ì´ë¡ ì—ì„œëŠ” ì´ë¥¼ &amp;ldquo;is a&amp;rdquo;(~ëŠ” ~ì´ë‹¤) ê´€ê³„ë¼ê³  ë¶€ë¥¸ë‹¤. IntegerëŠ” Objectì˜ &amp;ldquo;is a&amp;rdquo;ì´ë¯€ë¡œ Integer íƒ€ì…ì„ Object íƒ€ì…ì— í• ë‹¹ì´ ê°€ëŠ¥í•˜ë‹¤. í•˜ì§€ë§Œ IntegerëŠ” Number íƒ€ì…ì— &amp;ldquo;is a&amp;rdquo; ê´€ê³„ì´ë‹¤. ê·¸ëŸ¬ë¯€ë¡œ ì•„ë˜ì˜ ì½”ë“œëŠ” ì˜ ë™ì‘í•œë‹¤.
&lt;code&gt;In object-oriented terminology, this is called an &amp;quot;is a&amp;quot; relationship. Since an Integer is a kind of Object, the assignment is allowed. But Integer is also a kind of Number, so the following code is valid as well:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void someMethod(Number n) { /* ... */ }

someMethod(new Integer(10));   // OK
someMethod(new Double(10.1));   // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ë£°ì€ genericsë„ ë§ˆì°¬ê°€ì§€ë‹¤. generic íƒ€ì…ì„ í˜¸ì¶œí• ë•Œ, íƒ€ì…ì¸ìê°€ Number íƒ€ì…ê³¼ í˜¸í™˜ë˜ëŠ” &amp;ldquo;is a&amp;rdquo; ê´€ê³„ë¼ë©´ Number íƒ€ì…ìœ¼ë¡œ íƒ€ì…ì¸ìë¥¼ ì „ë‹¬í•œë‹¤.
&lt;code&gt;The same is also true with generics. You can perform a generic type invocation, passing Number as its type argument, and any subsequent invocation of add will be allowed if the argument is compatible with Number:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Number&amp;gt; box = new Box&amp;lt;Number&amp;gt;();
box.add(new Integer(10));   // OK
box.add(new Double(10.1));  // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì•„ë˜ì˜ ë©”ì„œë“œë¥¼ ì‚´í´ë³´ì
&lt;code&gt;Now consider the following method:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void boxTest(Box&amp;lt;Number&amp;gt; n) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì–´ë–¤ íƒ€ì…ì„ ì¸ìë¡œ ë°›ì„ìˆ˜ ìˆì„ê¹Œ? ë©”ì„œë“œì˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ë³´ë©´, Box&lt;Number&gt; íƒ€ì…ì˜ ê°ì²´ í•˜ë‚˜ë¥¼ ì¸ìë¡œ ë°›ëŠ” ë©”ì„œë“œì´ë‹¤. ê·¸ëŸ¼, Box&amp;lt;Integer&amp;gt;ë‚˜ Box&amp;lt;Double&amp;gt;ì„ ì¸ìë¡œ ë„£ì„ìˆ˜ ìˆì„ê¹Œ? ì•„ë‹ˆë‹¤! ì™œëƒí•˜ë©´ Box&amp;lt;Integer&amp;gt;, Box&amp;lt;Double&amp;gt;ëŠ” Box&amp;lt;Number&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ì´ ì•„ë‹ˆê¸° ë•Œë¬¸ì´ë‹¤. (ìë°”ì—ì„œëŠ” êº½ì‡ ì•ˆì— Number íƒ€ì…ì€ ì»´íŒŒì¼ëŸ¬ê°€ is aê´€ê³„ë¥¼ íŒŒì•…í•˜ì§€ ëª»í•œë‹¤. - ê³µë³€ì„±, ë°˜ê³µë³€ì„±ìª½ ë‚´ìš© ì°¸ì¡°í•˜ë©´ ì¢‹ì€ë° ìë°”ëŠ” ì´ë¥¼ ì§€ì› ëª»í•¨. ìŠ¤ì¹¼ë¼ ì–¸ì–´ ì°¸ì¡°. ëˆˆì´ ê³µë¶€í•˜ë‹¤ë³´ë©´ íŒ½íŒ½ ë”.)
&lt;code&gt;What type of argument does it accept? By looking at its signature, you can see that it accepts a single argument whose type is Box&amp;lt;Number&amp;gt;. But what does that mean? Are you allowed to pass in Box&amp;lt;Integer&amp;gt; or Box&amp;lt;Double&amp;gt;, as you might expect? The answer is &amp;quot;no&amp;quot;, because Box&amp;lt;Integer&amp;gt; and Box&amp;lt;Double&amp;gt; are not subtypes of Box&amp;lt;Number&amp;gt;.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì´ê²ƒì€ genericsë¥¼ ê³µë¶€í• ë•Œ í”íˆ ê²ªëŠ” ë¬¸ì œì´ë‹¤. í•˜ì§€ë§Œ genericì„ ê³µë¶€í• ë•Œ ì¤‘ìš”í•œ ì»¨ì…‰ì´ë‹¤.
&lt;code&gt;This is a common misunderstanding when it comes to programming with generics, but it is an important concept to learn.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../8-1.gif&#34; alt=&#34;Box&amp;lt;Integer&amp;gt; is not a subtype of Box&amp;lt;Number&amp;gt; even though Integer is a subtype of Number.&#34; /&gt;
&lt;br&gt;
Numberì˜ ì„œë¸Œíƒ€ì…ì¸ Integerë¥¼ ê°€ì§„ Box&amp;lt;Integer&amp;gt;ëŠ” Box&amp;lt;Number&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ì´ ì•„ë‹ˆë‹¤.
&lt;code&gt;Box&amp;lt;Integer&amp;gt; is not a subtype of Box&amp;lt;Number&amp;gt; even though Integer is a subtype of Number.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì¤‘ìš”:  Aì™€ B ë‘ êµ¬í˜„íƒ€ì…ì„ ì œê³µí• ë•Œ(ì˜ˆë¥¼ ë“¤ì–´ Numberì™€ Integer),Aì™€ Bê°€ &amp;ldquo;is a&amp;rdquo; ê´€ê³„ê°€ ìˆë“  ìƒê´€ì—†ì´  MyClass&amp;lt;A&amp;gt;ëŠ” MyClass&amp;lt;B&amp;gt;ì™€ ë” ì´ìƒ ê´€ê³„ê°€ í˜•ì„±ë˜ì§€ ì•ŠëŠ”ë‹¤.
&lt;code&gt;Note: Given two concrete types A and B (for example, Number and Integer), MyClass&amp;lt;A&amp;gt; has no relationship to MyClass&amp;lt;B&amp;gt;, regardless of whether or not A and B are related. The common parent of MyClass&amp;lt;A&amp;gt; and MyClass&amp;lt;B&amp;gt; is Object.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ë‘ generic í´ë˜ìŠ¤ë“¤ê°„ì— ì„œë¸Œíƒ€ì…&lt;strong&gt;ì²˜ëŸ¼&lt;/strong&gt; íƒ€ì…ë§¤ê°œë³€ìˆ˜ê°€ ê´€ë ¨ìˆë‹¤ë¼ëŠ” ì •ë³´ë¥¼ ì£¼ë ¤ë©´(ì»´íŒŒì¼ëŸ¬ì—ê²Œ), ì™€ì¼ë“œì¹´ë“œì™€ ì„œë¸Œíƒ€ì´í•‘ í•­ëª©ì„ ë³´ë¼
&lt;code&gt;For information on how to create a subtype-like relationship between two generic classes when the type parameters are related, see Wildcards and Subtyping.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì œë„¤ë¦­-í´ë˜ìŠ¤ì™€-ì„œë¸Œíƒ€ì´í•‘-generic-classes-and-subtyping&#34;&gt;ì œë„¤ë¦­ í´ë˜ìŠ¤ì™€ ì„œë¸Œíƒ€ì´í•‘ &lt;code&gt;Generic Classes and Subtyping&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic í´ë˜ìŠ¤ ìƒì† ë˜ëŠ” generic ì¸í„°í˜ì´ìŠ¤ ë§Œë“¤ ë•Œ, ë§Œë“œëŠ” íƒ€ì…ì„ ìƒì†(ë˜ëŠ” êµ¬í˜„) ë°›ì€ ë¶€ëª¨  generic íƒ€ì…ì˜ ì„œë¸Œ generic íƒ€ì…(ìì‹íƒ€ì…)ìœ¼ë¡œ ë‘ íƒ€ì…ê°„ì— ê´€ê³„(is a)ë¥¼ ë§Œë“¤ìˆ˜ ìˆë‹¤.
&lt;code&gt;You can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the extends and implements clauses.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Collections í´ë˜ìŠ¤ë“¤ ì‚¬ìš©í•  ë•Œ ì˜ˆë¥¼ ë“¤ë©´,  ArrayList&amp;lt;E&amp;gt;ëŠ” List&amp;lt;E&amp;gt;ë¥¼ êµ¬í˜„í–ˆê³  List&amp;lt;E&amp;gt;ëŠ” Collectionì„ ìƒì†í–ˆë‹¤. ê·¸ëŸ¬ë¯€ë¡œ ArrayList&amp;lt;String&amp;gt;ì€ List&amp;lt;String&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ì´ê³  List&amp;lt;String&amp;gt;ì€ Collection&amp;lt;String&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ë‹ˆë‹¤. ê·¸ëŸ¼ &amp;lt;String&amp;gt;ì´ë¼ëŠ” í˜•ì‹ì¸ìë¥¼ ë³€ê²½í•˜ì§€ ì•Šìœ¼ë©´ íƒ€ì…ê°„ ì„œë¸Œíƒ€ì´í•‘ ê´€ê³„ê°€ ìœ ì§€ëœë‹¤.
&lt;code&gt;Using the Collections classes as an example, ArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, and List&amp;lt;E&amp;gt; extends Collection&amp;lt;E&amp;gt;. So ArrayList&amp;lt;String&amp;gt; is a subtype of List&amp;lt;String&amp;gt;, which is a subtype of Collection&amp;lt;String&amp;gt;. So long as you do not vary the type argument, the subtyping relationship is preserved between the types.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../8-2.gif&#34; alt=&#34;A sample Collections hierarchy&#34; /&gt;
&lt;br&gt;
ì½œë ‰ì…˜ë“¤ê°„ì˜ ê³„ì¸µêµ¬ì¡° ì˜ˆ&lt;code&gt;sample Collections hierarchy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;PayloadListë¼ëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•  ë•Œ Pë¼ëŠ” generic íƒ€ì…ì„ ë©”ì„œë“œì˜ íŒŒë¼ë©”í„°ë¡œ ì‚¬ìš©í•œë‹¤ê³ í–ˆì„ë•Œ, ì•„ë˜ ì½”ë“œì™€ ê°™ì„ ê²ƒì´ë‹¤.
&lt;code&gt;Now imagine we want to define our own list interface, PayloadList, that associates an optional value of generic type P with each element. Its declaration might look like:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface PayloadList&amp;lt;E,P&amp;gt; extends List&amp;lt;E&amp;gt; {
  void setPayload(int index, P val);
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;List&amp;lt;String&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ì´ë©´ì„œ PayloadListê°€ íƒ€ì…ì¸ìë¡œ ì „ë‹¬í• ìˆ˜ ìˆëŠ” ê²ƒì€ ì•„ë˜ì²˜ëŸ¼ ë‹¤ì–‘í•˜ê²Œ ë³¼ìˆ˜ ìˆë‹¤.(ì¼ë¶€ì„.)
&lt;code&gt;The following parameterizations of PayloadList are subtypes of List&amp;lt;String&amp;gt;:&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PayloadList&lt;String,String&gt;&lt;/li&gt;
&lt;li&gt;PayloadList&lt;String,Integer&gt;&lt;/li&gt;
&lt;li&gt;PayloadList&lt;String,Exception&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../8-3.gif&#34; alt=&#34;A sample PayloadList hierarchy&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(7) Java Generics: Generic ë©”ì„œë“œì™€ ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ (Generic Methods and Bounded Type Parameters)</title>
      <link>http://durtchrt.github.io/blog/java/generics/7/</link>
      <pubDate>Sat, 05 Nov 2016 08:24:47 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/7/</guid>
      <description>

&lt;h3 id=&#34;generic-ë©”ì„œë“œì™€-ì œí•œëœ-íƒ€ì…-ë§¤ê°œë³€ìˆ˜-generic-methods-and-bounded-type-parameters&#34;&gt;Generic ë©”ì„œë“œì™€ ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ &lt;code&gt;Generic Methods and Bounded Type Parameters&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” generic ì•Œê³ ë¦¬ì¦˜ë“¤ì„ êµ¬í˜„í• ë•Œ í•µì‹¬ì´ëœë‹¤. ì•„ë˜ì˜ ì˜ˆëŠ” ë‘ë²ˆì§¸ ì¸ìë³´ë‹¤ í° ê°’ì´ ì²«ë²ˆì§¸ ì¸ìì¸ ë°°ì—´ì— ëª‡ê°œê°€ ìˆëŠ”ì§€ ì„¸ëŠ” ë©”ì„œë“œì´ë‹¤.
&lt;code&gt;Bounded type parameters are key to the implementation of generic algorithms. Consider the following method that counts the number of elements in an array T[] that are greater than a specified element elem.&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T&amp;gt; int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e &amp;gt; elem)  // compiler error
            ++count;
    return count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë©”ì„œë“œ êµ¬í˜„ì€ ê°„ë‹¨í•˜ì§€ë§Œ, &amp;lsquo;&amp;gt;&amp;rsquo; ì—°ì‚°ìê°€ ê¸°ë³¸í˜•(short, int, double, long, float, byte, char)ì—ë§Œ ë™ì‘ì´ í—ˆìš©ë˜ê¸° ë•Œë¬¸ì´ë‹¤. &amp;lsquo;&amp;gt;&amp;rsquo; ì—°ì‚°ìëŠ” ê°ì²´ê°„ ë¹„êµì—ëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¹„êµì—°ì‚°ì ëŒ€ì‹  Comparable&lt;T&gt;  ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•´ì„œ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
&lt;code&gt;The implementation of the method is straightforward, but it does not compile because the greater than operator (&amp;gt;) applies only to primitive types such as short, int, double, long, float, byte, and char. You cannot use the &amp;gt; operator to compare objects. To fix the problem, use a type parameter bounded by the Comparable&amp;lt;T&amp;gt; interface:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Comparable&amp;lt;T&amp;gt; {
    public int compareTo(T o);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comparable ì¸í„°í˜ì´ìŠ¤ê°€ ì ìš©ëœ ê²°ê³¼ ì½”ë“œëŠ” ì•„ë˜ì˜ ì½”ë“œì²˜ëŸ¼ ë  ê²ƒì…ë‹ˆë‹¤. &lt;code&gt;The resulting code will be:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e.compareTo(elem) &amp;gt; 0)
            ++count;
    return count;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(6) Java Generics: ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ (Bounded Type Parameters)</title>
      <link>http://durtchrt.github.io/blog/java/generics/6/</link>
      <pubDate>Fri, 04 Nov 2016 18:03:27 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/6/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/bounded.html&#34;&gt;ì›ë¬¸ ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì œí•œëœ-íƒ€ì…-ë§¤ê°œë³€ìˆ˜-bounded-type-parameters&#34;&gt;ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ &lt;code&gt;Bounded Type Parameters&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ë§¤ê°œë³€ìˆ˜í™”ëœ íƒ€ì…ì— íƒ€ì…ì¸ìë¥¼ ë„£ì„ë•Œ íƒ€ì… ì œí•œì„ ê±¸ê³  ì‹¶ì„ ë•Œê°€ ìˆì„ ê²ƒì´ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, Number íƒ€ì… ë˜ëŠ” Number íƒ€ì…ì˜ ìì‹ í´ë˜ìŠ¤ì˜ ê°ì²´ë§Œ í—ˆìš©í•˜ëŠ” ìˆ«ì ì²˜ë¦¬ë¥¼ ìœ„í•œ ë©”ì„œë“œë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤. ì´ê²ƒì´ ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ë‹¤
&lt;code&gt;There may be times when you want to restrict the types that can be used as type arguments in a parameterized type. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. This is what bounded type parameters are for.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì œí•œëœ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ëŠ” ë°©ë²•ì€, íƒ€ì…ë§¤ê°œë³€ìˆ˜ì˜ ì´ë¦„ ë’¤ì—  extends í‚¤ì›Œë“œë¥¼ ë†“ê³  ì œí•œì‹œí‚¬ íƒ€ì…ì„ ì‘ì„±í•˜ë©´ ëœë‹¤. ì•„ë˜ì˜ ì—ì—ì„œëŠ” Number íƒ€ì…ìœ¼ë¡œ í•˜ì˜€ë‹¤. ì£¼ì˜í• ì ì€, ì—¬ê¸°ì„œ ì‚¬ìš©í•œ extendsëŠ” í´ë˜ìŠ¤ì•ˆì˜ &amp;ldquo;extends&amp;rdquo; ë˜ëŠ” ì¸í„°í˜ì´ìŠ¤ì˜ &amp;ldquo;implements&amp;rdquo; ì²˜ëŸ¼ êµ¬í˜„í•œë‹¤ëŠ” ì˜ë¯¸ëŠ” ì•„ë‹ˆë‹¤.
&lt;code&gt;To declare a bounded type parameter, list the type parameter&#39;s name, followed by the extends keyword, followed by its upper bound, which in this example is Number. Note that, in this context, extends is used in a general sense to mean either &amp;quot;extends&amp;quot; (as in classes) or &amp;quot;implements&amp;quot; (as in interfaces).&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Box&amp;lt;T&amp;gt; {

    private T t;

    public void set(T t) {
        this.t = t;
    }

    public T get() {
        return t;
    }

    public &amp;lt;U extends Number&amp;gt; void inspect(U u){
        System.out.println(&amp;quot;T: &amp;quot; + t.getClass().getName());
        System.out.println(&amp;quot;U: &amp;quot; + u.getClass().getName());
    }

    public static void main(String[] args) {
        Box&amp;lt;Integer&amp;gt; integerBox = new Box&amp;lt;Integer&amp;gt;();
        integerBox.set(new Integer(10));
        integerBox.inspect(&amp;quot;some text&amp;quot;); // error: this is still String!
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generic Box í´ë˜ìŠ¤ëŠ” ì œí•œëœ íƒ€ì… íŒŒë¼ë©”í„°ë¥¼ ê°€ì§„ ë©”ì„œë“œì¸ inspectë¥¼ í¬í•¨í•˜ë„ë¡ ê¸°ì¡´ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì˜€ë‹¤. inspect ë©”ì„œë“œ í˜¸ì¶œì‹œì— String íƒ€ì…ì„ ì¸ìë¡œ ë°›ì•˜ê¸° ë•Œë¬¸ì— ì»´íŒŒì¼ì´ ì‹¤íŒ¨í•  ê²ƒì´ë‹¤.
&lt;code&gt;By modifying our generic method to include this bounded type parameter, compilation will now fail, since our invocation of inspect still includes a String:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Box.java:21: &amp;lt;U&amp;gt;inspect(U) in Box&amp;lt;java.lang.Integer&amp;gt; cannot
  be applied to (java.lang.String)
                        integerBox.inspect(&amp;quot;10&amp;quot;);
                                  ^
1 error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê²°ë¡ ì€ generic íƒ€ì…ì„ ê°ì²´ë¡œ ë§Œë“¤ë•Œ ì œí•œì„ ê±¸ìˆ˜ ìˆë‹¤. ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” ì •ì˜ëœ ì œí•œëœ ë²”ìœ„ ë‚´ì—ì„œ ë©”ì„œë“œë¥¼ í˜¸ì¶œ í•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;In addition to limiting the types you can use to instantiate a generic type, bounded type parameters allow you to invoke methods defined in the bounds:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class NaturalNumber&amp;lt;T extends Integer&amp;gt; {

    private T n;

    public NaturalNumber(T n)  { this.n = n; }

    public boolean isEven() {
        return n.intValue() % 2 == 0;
    }

    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;isEven ë©”ì„œë“œëŠ” ë³€ìˆ˜ nì— íƒ€ì…ì¸ìë¡œ ì „ë‹¬ëœ Integer íƒ€ì…ì— ì •ì˜ëœ intValue ë©”ì„œë“œë¥¼ í˜¸ì¶œí•œë‹¤.
&lt;code&gt;The isEven method invokes the intValue method defined in the Integer class through n.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì—¬ëŸ¬ë²ˆ-ì œí•œí•˜ê¸°-multiple-bounds&#34;&gt;ì—¬ëŸ¬ë²ˆ ì œí•œí•˜ê¸° &lt;code&gt;Multiple Bounds&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ì´ì „ê¹Œì§€ ì˜ˆì œëŠ” í•˜ë‚˜ë§Œ ì œí•œí•œ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•œ ê²ƒë§Œ ì„¤ëª…í–ˆì§€ë§Œ, íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” ì—¬ëŸ¬ê°œë¥¼ ì œí•œí•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;The preceding example illustrates the use of a type parameter with a single bound, but a type parameter can have multiple bounds:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;T extends B1 &amp;amp; B2 &amp;amp; B3&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì—¬ëŸ¬ê°œì˜ ì œí•œë“¤ë¡œ êµ¬ì„±ëœ íƒ€ì…ë§¤ê°œë³€ìˆ˜ëŠ” ì œí•œí•˜ë ¤ ë‚˜ì—´í•œ ëª¨ë“  íƒ€ì…ë“¤ì˜ ì„œë¸Œíƒ€ì…ì´ë‹¤.(êµ³ì´ classë¼ê³  ì•ˆí•˜ê³  íƒ€ì…ì´ë€ ìš©ì–´ë¥¼ ì“°ëŠ”ê±´ interfaceë¥¼ í¬í•¨í•˜ëŠ” ë‹¨ì–´ê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì´ë‹¤. í´ë˜ìŠ¤ëŠ” íƒ€ì…ì˜ ë¶€ë¶„) ì œí•œëœ íƒ€ì…ì¤‘ í•˜ë‚˜ê°€ classë¼ë©´, classëŠ” ì—´ê±°ë˜ëŠ” íƒ€ì…ë“¤ì¤‘ ì²˜ìŒì— ì‘ì„±í•´ì•¼í•œë‹¤. ì˜ˆë¥¼ ë“¤ë©´:
&lt;code&gt;A type variable with multiple bounds is a subtype of all the types listed in the bound. If one of the bounds is a class, it must be specified first. For example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Class A { /* ... */ }
interface B { /* ... */ }
interface C { /* ... */ }

class D &amp;lt;T extends A &amp;amp; B &amp;amp; C&amp;gt; { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë§Œì•½ Aë¼ëŠ” ì œí•œ classê°€ ë‹¤ë¥¸ ì œí•œ í´ë˜ìŠ¤ë“¤ì¤‘ ì²˜ìŒì— ìœ„ì¹˜í•˜ì§€ ì•Šìœ¼ë©´, ì»´íŒŒì¼íƒ€ì„ ì—ëŸ¬ë¥¼ ë°œìƒëœë‹¤.
&lt;code&gt;If bound A is not specified first, you get a compile-time error:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class D &amp;lt;T extends B &amp;amp; A &amp;amp; C&amp;gt; { /* ... */ }  // compile-time error
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(5) Java Generics: ì œë„¤ë¦­ ë©”ì„œë“œ</title>
      <link>http://durtchrt.github.io/blog/java/generics/5/</link>
      <pubDate>Fri, 04 Nov 2016 13:43:44 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/5/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/methods.html&#34;&gt;ì›ë¬¸ ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;generic-ë©”ì„œë“œ-generic-methods&#34;&gt;Generic ë©”ì„œë“œ &lt;code&gt;Generic Methods&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Generic ë©”ì„œë“œëŠ” ìì‹œì˜ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ê°€ì§„ ë©”ì„œë“œì´ë‹¤. generic íƒ€ì…ì„ ì„ ì–¸í•˜ëŠ” ê²ƒê³¼ ë¹„ìŠ·í•˜ì§€ë§Œ íƒ€ì…ë§¤ê°œë³€ìˆ˜ì˜ ìŠ¤ì½”í”„ëŠ” ë©”ì„œë“œë¡œ ì œí•œëœë‹¤. ì¼ë°˜ ë©”ì„œë“œ, ì •ì  ë©”ì„œë“œ generic í´ë˜ìŠ¤ì˜ ìƒì„±ìëŠ” ì´ ë£°ì„ ë™ì¼í•˜ê²Œ ì ìš©ëœë‹¤.
&lt;code&gt;Generic methods are methods that introduce their own type parameters. This is similar to declaring a generic type, but the type parameter&#39;s scope is limited to the method where it is declared. Static and non-static generic methods are allowed, as well as generic class constructors.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;generic ë©”ì„œë“œ ë¬¸ë²•ì€ return íƒ€ì… ì „ì— êº½ì‡  ì‚¬ì´ì— íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ í‘œê¸°í•œë‹¤. static generic ë©”ì„œë“œë¥¼ ìœ„í•´ íƒ€ì…ë§¤ê°œë³€ìˆ˜ëŠ” ë°˜ë“œì‹œ ë©”ì„œë“œì˜ return íƒ€ì… ì´ì „ì— ìœ„ì¹˜í•´ì•¼í•œë‹¤.
&lt;code&gt;The syntax for a generic method includes a type parameter, inside angle brackets, and appears before the method&#39;s return type. For static generic methods, the type parameter section must appear before the method&#39;s return type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Util í´ë˜ìŠ¤ëŠ” ë‘ Pair ê°ì²´ë¥¼ ë¹„êµí•˜ëŠ” generic ë©”ì„œë“œë¥¼ í¬í•¨í•˜ê³  ìˆìŠµë‹ˆë‹¤.
&lt;code&gt;The Util class includes a generic method, compare, which compares two Pair objects:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Util {
    public static &amp;lt;K, V&amp;gt; boolean compare(Pair&amp;lt;K, V&amp;gt; p1, Pair&amp;lt;K, V&amp;gt; p2) {
        return p1.getKey().equals(p2.getKey()) &amp;amp;&amp;amp;
               p1.getValue().equals(p2.getValue());
    }
}

public class Pair&amp;lt;K, V&amp;gt; {

    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public void setKey(K key) { this.key = key; }
    public void setValue(V value) { this.value = value; }
    public K getKey()   { return key; }
    public V getValue() { return value; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì´ ë©”ì„œë“œë¥¼(static &lt;K, V&gt; boolean compare)ë¥¼ í˜¸ì¶œí•œ ë¬¸ì¥ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.
&lt;code&gt;The complete syntax for invoking this method would be:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Pair&amp;lt;Integer, String&amp;gt; p1 = new Pair&amp;lt;&amp;gt;(1, &amp;quot;apple&amp;quot;);
Pair&amp;lt;Integer, String&amp;gt; p2 = new Pair&amp;lt;&amp;gt;(2, &amp;quot;pear&amp;quot;);
boolean same = Util.&amp;lt;Integer, String&amp;gt;compare(p1, p2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Util.&lt;strong&gt;&amp;lt;Integer, String&amp;gt;&lt;/strong&gt;compare(p1, p2)&lt;br&gt;
ê°•ì¡°í•œ ì˜ì—­ì²˜ëŸ¼ íƒ€ì…ì„ ëª…ì‹œí•˜ì˜€ë‹¤. íƒ€ì…ì¸ìëŠ” ì»´íŒŒì¼ëŸ¬ê°€ íƒ€ì… ì¶”ë¡ í• ë•Œ í•„ìš”í•œ ì •ë³´ê°€ ëœë‹¤.
&lt;code&gt;The type has been explicitly provided, as shown in bold. Generally, this can be left out and the compiler will infer the type that is needed:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Pair&amp;lt;Integer, String&amp;gt; p1 = new Pair&amp;lt;&amp;gt;(1, &amp;quot;apple&amp;quot;);
Pair&amp;lt;Integer, String&amp;gt; p2 = new Pair&amp;lt;&amp;gt;(2, &amp;quot;pear&amp;quot;);
boolean same = Util.compare(p1, p2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ì½”ë“œëŠ” íƒ€ì… ì¶”ë¡ ì„ ë‚˜íƒ€ë‚¸ê²ƒì´ë‹¤. êº½ì‡ ì— íƒ€ì… ëª…ì‹œí•˜ì§€ ì•Šê³  generic ë©”ì„œë“œê°€ ì•„ë‹Œ ì¼ë°˜ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•´ë„ íƒ€ì… ì¶”ë¡ ì´ ì´ë£¨ì–´ì§„ë‹¤. ì´ ì£¼ì œëŠ” ë’¤ì— ë‚˜ì˜¤ëŠ” íƒ€ì… ì¶”ë¡  ì„¹ì…˜ì—ì„œ ë” ë…¼ì˜í•œë‹¤.
&lt;code&gt;This feature, known as type inference, allows you to invoke a generic method as an ordinary method, without specifying a type between angle brackets. This topic is further discussed in the following section, Type Inference.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(4) Java Generics: ì›ì²œ(Raw) íƒ€ì…ë“¤</title>
      <link>http://durtchrt.github.io/blog/java/generics/4/</link>
      <pubDate>Tue, 01 Nov 2016 16:05:56 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/4/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&#34;&gt;ì›ë¬¸ ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì›ì²œ-íƒ€ì…ë“¤-raw-types&#34;&gt;ì›ì²œ íƒ€ì…ë“¤ &lt;code&gt;Raw Types&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Raw íƒ€ì…ì€ generic í´ë˜ìŠ¤ í˜¹ì€ ì¸í„°í˜ì´ìŠ¤ì— íƒ€ì…ì¸ìê°€ ì—†ëŠ” ê²ƒ. ì˜ˆë¥¼ë“¤ì–´ generic Box í´ë˜ìŠ¤ë¥¼ ë³´ì
&lt;code&gt;A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Box&amp;lt;T&amp;gt; {
    public void set(T t) { /* ... */ }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì•„ë˜ ì½”ë“œë¥¼ ë³´ë©´ Box&lt;T&gt;ì˜ ë§¤ê°œë³€ìˆ˜í™”ëœ íƒ€ì…ì„ ë§Œë“œë©´ì„œ, íƒ€ì…ë§¤ê°œë³€ìˆ˜ Tì— í•´ë‹¹í•˜ëŠ” Integerë¥¼ íƒ€ì…ì¸ìë¡œ ì œê³µí•˜ì˜€ë‹¤.
&lt;code&gt;To create a parameterized type of Box&amp;lt;T&amp;gt;, you supply an actual type argument for the formal type parameter T:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Integer&amp;gt; intBox = new Box&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;íƒ€ì…ì¸ìê°€ ìƒëµëœ ê²½ìš° Box&lt;T&gt;ì˜ Raw íƒ€ì…ì„ ë§Œë“¤ìˆ˜ ìˆë‹¤.
&lt;code&gt;If the actual type argument is omitted, you create a raw type of Box&amp;lt;T&amp;gt;:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box rawBox = new Box();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê²°êµ­, BoxëŠ” generic íƒ€ì… Box&lt;T&gt;ì˜ raw íƒ€ì…ì´ë‹¤. í•˜ì§€ë§Œ, generic í´ë˜ìŠ¤ ë˜ëŠ” ì¸í„°í˜ì´ìŠ¤ê°€ ì•„ë‹Œê²½ìš°ëŠ” raw íƒ€ì…ì´ ë  ìˆ˜ ì—†ë‹¤.()
&lt;code&gt;Therefore, Box is the raw type of the generic type Box&amp;lt;T&amp;gt;. However, a non-generic class or interface type is not a raw type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Raw íƒ€ì…ì€ JDK 5.0 ì´ì „ ìë°” API í´ë˜ìŠ¤ë“¤ì€ ì œë„¤ë¦­ì„ ì§€ì›í•˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì—(ì˜ˆë¥¼ ë“¤ì–´ Collections í´ë˜ìŠ¤) ë ˆê±°ì‹œ ì½”ë“œì—ì„œ ë‚˜íƒ€ë‚œë‹¤. raw íƒ€ì…ì„ ì‚¬ìš©í•  ë•ŒëŠ” ë°˜ë“œì‹œ generics ì´ì „ ë°©ë²•(íƒ€ì… ìºìŠ¤íŒ…)ì„ í•˜ì‹œì˜¤. í•˜ìœ„í˜¸í™˜ì„±ì„ ìœ„í•´, íƒ€ì…ë§¤ê°œë³€ìˆ˜ëŠ” rawíƒ€ì…ì„ í—ˆìš©í•˜ì˜€ë‹¤.
&lt;code&gt;Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior â€” a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;String&amp;gt; stringBox = new Box&amp;lt;&amp;gt;();
Box rawBox = stringBox;               // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;í•˜ì§€ë§Œ íƒ€ì…ë§¤ê°œë³€ìˆ˜ì— raw íƒ€ì…ì„ í• ë‹¹í•˜ë©´ (ì»´íŒŒì¼ëŸ¬ë¡œë¶€í„°) ê²½ê³ ë¥¼ ë°›ìŠµë‹ˆë‹¤.
&lt;code&gt;But if you assign a raw type to a parameterized type, you get a warning:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box rawBox = new Box();           // rawBox is a raw type of Box&amp;lt;T&amp;gt;
Box&amp;lt;Integer&amp;gt; intBox = rawBox;     // warning: unchecked conversion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë˜í•œ generic íƒ€ì…ì— ì •ì˜ëœ generic ë©”ì„œë“œë¥¼ í˜¸ì¶œí• ë•Œì—ë„ raw íƒ€ì…ì„ ì‚¬ìš©í•˜ë©´ ê²½ê³ ë¥¼ ë°›ìŠµë‹ˆë‹¤.
&lt;code&gt;You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;String&amp;gt; stringBox = new Box&amp;lt;&amp;gt;();
Box rawBox = stringBox;
rawBox.set(8);  // warning: unchecked invocation to set(T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê²½ê³ ëŠ” raw íƒ€ì…ë“¤ì´ generic íƒ€ì…ì²´í¬ë¥¼ í• ìˆ˜ ì—†ë‹¤ëŠ” ê²ƒì„ ë³´ì—¬ì¤ë‹ˆë‹¤. (ì»´íŒŒì¼ íƒ€ì„ì— ì²´í¬ë  ìˆ˜ ìˆëŠ”) ë¶ˆì•ˆí•œ ì½”ë“œê°€ ëŸ°íƒ€ì„ì— ë¶™ì¡íˆê²Œ (ì»´íŒŒì¼ íƒ€ì„ ì²´í‚¹ì„ ëŸ°íƒ€ì„ìœ¼ë¡œ) ë”œë ˆì´ ì‹œí‚¤ëŠ” ê²ƒì´ë¯€ë¡œ raw íƒ€ì… ì‚¬ìš©ì€ í”¼í•˜ëŠ”ê²ƒì´ ì¢‹ì„ ê²ƒì´ë‹¤.&lt;br /&gt;
&lt;code&gt;The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;íƒ€ì…ì†Œê±° ì„¹ì…˜ì—ì„œëŠ” ìë°” ì»´íŒŒì¼ëŸ¬ê°€ raw íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì— ëŒ€í•œ ë” ìì„¸í•œ ì„¤ëª…ì´ ìˆë‹¤.
&lt;code&gt;The Type Erasure section has more information on how the Java compiler uses raw types.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;unchecked-error-messages&#34;&gt;Unchecked Error Messages&lt;/h3&gt;

&lt;p&gt;ì´ì „ì— ë§í–‡ë“¯, generic ì½”ë“œì™€ ë ˆê±°ì‹œ ì½”ë“œë¥¼ ì„ê²Œ ë˜ë©´, ì•„ë˜ì™€ ê°™ì€ ê²½ê³  ë©”ì„¸ì§€ë¥¼ ë§ˆì£¼ì¹  ê²ƒì´ë‹¤.
&lt;code&gt;As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Note: Example.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;This can happen when using an older API that operates on raw types, as shown in the following example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WarningDemo {
    public static void main(String[] args){
        Box&amp;lt;Integer&amp;gt; bi;
        bi = createBox();
    }

    static Box createBox(){
        return new Box();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;unchecked(ì²´í¬ë˜ì§€ ì•ŠìŒ)&amp;ldquo;ëŠ” íƒ€ì… ì•ˆì •ì„±ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ í•„ìš”í•œ íƒ€ì…ì²´í¬ ì •ë³´ê°€ ì¶©ë¶„ì¹˜ ì•Šë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤. &amp;ldquo;unchecked&amp;rdquo; ê²½ê³ ëŠ” ì»´íŒŒì¼ëŸ¬ì—ê²Œ ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤.&amp;ldquo;unchecked&amp;rdquo; ê²½ê³ ë¥¼ ë³´ê³  ì‹¶ë‹¤ë©´ -Xlint:uncheckedì˜µì…˜ì„ ì£¼ê³  ë‹¤ì‹œ ì»´íŒŒì¼í•˜ë©´ ëª¨ë“  &amp;ldquo;unchecked&amp;rdquo; ê²½ê³ ë¥¼ ë³¼ ìˆ˜ ìˆë‹¤.
&lt;code&gt;The term &amp;quot;unchecked&amp;quot; means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The &amp;quot;unchecked&amp;quot; warning is disabled, by default, though the compiler gives a hint. To see all &amp;quot;unchecked&amp;quot; warnings, recompile with -Xlint:unchecked.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;-Xlint:unchecked ì˜µì…˜ê³¼ í•¨ê»˜ ì˜ˆì œë¥¼ ë‹¤ì‹œ ì»´íŒŒì¼í•´ë³´ë©´ ì•„ë˜ì— ë³´ì´ëŠ” ë‚´ìš©ì´ ë‚˜íƒ€ë‚  ê²ƒì´ë‹¤.
&lt;code&gt;Recompiling the previous example with -Xlint:unchecked reveals the following additional information:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;WarningDemo.java:4: warning: [unchecked] unchecked conversion
found   : Box
required: Box&amp;lt;java.lang.Integer&amp;gt;
        bi = createBox();
                      ^
1 warning
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì»´íŒŒì¼ ì˜µì…˜ì— -Xlint:-unchecked í”Œë˜ê·¸ë¥¼ ì‚¬ìš©í•˜ë©´ unchecked ê²½ê³ ë¥¼ ì—†ì•¨ ìˆ˜ ìˆë‹¤. @SupporessWarnings(&amp;ldquo;unchecked&amp;rdquo;) ì–´ë…¸í…Œì´ì…˜ì€ unchecked ê²½ê³ ê°€ ë‚˜íƒ€ë‚˜ì§€ ì•Šê²Œ í•  ìˆ˜ ìˆë‹¤. @SupressWarnings ë¬¸ë²•ì´ ìƒì†Œí•˜ë©´ Annotations ì„¹ì…˜ì„ ë³´ì‹œì˜¤. &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/annotations/index.html&#34;&gt;ë§í¬&lt;/a&gt;
&lt;code&gt;To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The @SuppressWarnings(&amp;quot;unchecked&amp;quot;) annotation suppresses unchecked warnings. If you are unfamiliar with the @SuppressWarnings syntax, see Annotations.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ì—­ì ì²¨ë¶€&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ javac WarningDemo.java 

Note: WarningDemo.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
    
$ javac -Xlint:unchecked WarningDemo.java

WarningDemo.java:7: warning: [unchecked] unchecked conversion
        bi = createBox();
                      ^
required: Box&amp;lt;Integer&amp;gt;
found:    Box
1 warning
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>