<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ê°œë°œ ì €ì¥ì†Œ</title>
    <link>http://durtchrt.github.io/blog/tags/generics/index.xml</link>
    <description>Recent content on ê°œë°œ ì €ì¥ì†Œ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>durtchrt</copyright>
    <atom:link href="http://durtchrt.github.io/blog/tags/generics/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(10) ì™€ì¼ë“œì¹´ë“œ Wildcards </title>
      <link>http://durtchrt.github.io/blog/java/generics/11/</link>
      <pubDate>Sat, 12 Nov 2016 18:23:01 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/11/</guid>
      <description>

&lt;h3 id=&#34;ìƒìœ„-ì œí•œëœ-ì™€ì¼ë“œ-ì¹´ë“œ-upper-bounded-wildcards&#34;&gt;ìƒìœ„ ì œí•œëœ ì™€ì¼ë“œ ì¹´ë“œ &lt;code&gt;Upper Bounded Wildcards&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ë³€ìˆ˜ì— ì™„í™”ëœ ì œí•œì„ ê±¸ê³  ì‹¶ì„ë•Œ upper bounded wildcardë¥¼ ì‚¬ìš©í•œë‹¤. ì˜ˆë¥¼ë“¤ë©´, List&amp;lt;Integer&amp;gt;, List&amp;lt;Double&amp;gt;, List&amp;lt;Number&amp;gt; íƒ€ì…ë“¤ì—ì„œ ë™ì‘í•˜ëŠ” ë©”ì„œë“œë¥¼ ì‘ì„±í• ë•Œ upper bounded wildcardë¥¼ ì‚¬ìš©í•´ì„œ ë§Œë“¤ìˆ˜ ìˆë‹¤.
&lt;code&gt;You can use an upper bounded wildcard to relax the restrictions on a variable. For example, say you want to write a method that works on List&amp;lt;Integer&amp;gt;, List&amp;lt;Double&amp;gt;, and List&amp;lt;Number&amp;gt;; you can achieve this by using an upper bounded wildcard.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;uppper-bounded wildcardëŠ” ì™€ì¼ë“œì¹´ë“œ ë¬¸ì &amp;lsquo;?&amp;lsquo;ì™€ ë’¤ì—ëŠ” extends í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ê³  ë’¤ì—ëŠ” ìƒìœ„ íƒ€ì…ì„ ì¨ì„œ ì •ì˜í•œë‹¤. í´ë˜ìŠ¤ì˜ extends, ì¸í„°í˜ì´ìŠ¤ì˜ implementsì²˜ëŸ¼ extends í‚¤ì›Œë“œëŠ” ì´ëŸ¬í•œ ì˜ë¯¸ë¡œ ì‚¬ìš©ëœë‹¤.
&lt;code&gt;To declare an upper-bounded wildcard, use the wildcard character (&#39;?&#39;), followed by the extends keyword, followed by its upper bound. Note that, in this context, extends is used in a general sense to mean either &amp;quot;extends&amp;quot; (as in classes) or &amp;quot;implements&amp;quot; (as in interfaces).&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Integer, Double, Floatì²˜ëŸ¼ Number íƒ€ì…ì˜ ì„œë¸Œíƒ€ì…ë“¤ì—ì„œ ë™ì‘í•˜ëŠ” ë©”ì„œë“œë¥¼ ì‘ì„±í•  ë•Œ, List&amp;lt;? extends Number&amp;gt; ìš”ë˜ ì‘ì„±í•˜ë©´ëœë‹¤. List&amp;lt;Number&amp;gt;ëŠ” List&amp;lt;? extends Number&amp;gt;ë³´ë‹¤ ì œí•œì ì´ë‹¤. ì „ìëŠ” Number íƒ€ì…ì˜ ë¦¬ìŠ¤íŠ¸ë§Œ ê°€ëŠ¥, í›„ìëŠ” Number íƒ€ì… ë˜ëŠ” Number íƒ€ì…ì˜ ì„œë¸Œ íƒ€ì… ë¦¬ìŠ¤íŠ¸ë„ ê°€ëŠ¥í•˜ë‹¤.
&lt;code&gt;To write the method that works on lists of Number and the subtypes of Number, such as Integer, Double, and Float, you would specify List&amp;lt;? extends Number&amp;gt;. The term List&amp;lt;Number&amp;gt; is more restrictive than List&amp;lt;? extends Number&amp;gt; because the former matches a list of type Number only, whereas the latter matches a list of type Number or any of its subclasses.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì•„ë˜ì˜ process ë©”ì„œë“œë¥¼ ì‚´í´ë³´ì &lt;code&gt;Consider the following process method:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void process(List&amp;lt;? extends Foo&amp;gt; list) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lt;? extends Foo&amp;gt; upper bounded wildcardëŠ” Fooì™€ Fooì˜ ì„œë¸Œíƒ€ì…ê³¼ ë§¤ì¹˜ë˜ëŠ” í‘œí˜„ì´ë‹¤. (ì•„ë˜ì˜ ì½”ë“œ ì°¸ì¡°)process ë©”ì„œë“œëŠ” Fooíƒ€ì…ê³¼ ê°™ì€ ë¦¬ìŠ¤íŠ¸ì˜ ìš”ì†Œë¥¼ ì—‘ì„¸ìŠ¤í• ìˆ˜ ìˆë‹¤.
&lt;code&gt;The upper bounded wildcard, &amp;lt;? extends Foo&amp;gt;, where Foo is any type, matches Foo and any subtype of Foo. The process method can access the list elements as type Foo:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void process(List&amp;lt;? extends Foo&amp;gt; list) {
    for (Foo elem : list) {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;foreachì ˆì€ listì˜ ê°ê° ìš”ì†Œë¥¼ ìˆœíšŒí•˜ë©° elem ë³€ìˆ˜ì— í• ë‹¹í•œë‹¤.  elemì€ Foo í´ë˜ìŠ¤ì— ì •ì˜ë˜ì–´ ìˆëŠ” ë©”ì„œë“œë¥¼ ëª¨ë‘ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;In the foreach clause, the elem variable iterates over each element in the list. Any method defined in the Foo class can now be used on elem.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;sumOfListë©”ì„œë“œëŠ” ë¦¬ìŠ¤íŠ¸ ì•ˆì˜ ìˆ«ìì˜ í•©ì„ ë¦¬í„´í•œë‹¤. &lt;code&gt;The sumOfList method returns the sum of the numbers in a list:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static double sumOfList(List&amp;lt;? extends Number&amp;gt; list) {
    double s = 0.0;
    for (Number n : list)
        s += n.doubleValue();
    return s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì•„ë˜ì˜ ì½”ë“œëŠ” Integer ê°ì²´ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ &amp;ldquo;sum = 6.0&amp;rdquo;ì„ ì¶œë ¥í•œë‹¤.
&lt;code&gt;The following code, using a list of Integer objects, prints sum = 6.0:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Integer&amp;gt; li = Arrays.asList(1, 2, 3);
System.out.println(&amp;quot;sum = &amp;quot; + sumOfList(li));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Doubleê°’ì„ ê°€ì§„ ë¦¬ìŠ¤íŠ¸ë„ sumOfList ë©”ì„œë“œë¥¼ ì—­ì‹œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ì•„ë˜ì˜ ì½”ë“œëŠ” &amp;ldquo;sum = 7.0&amp;rdquo;ì„ ì¶œë ¥í•œë‹¤.
&lt;code&gt;A list of Double values can use the same sumOfList method. The following code prints sum = 7.0:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Double&amp;gt; ld = Arrays.asList(1.2, 2.3, 3.5);
System.out.println(&amp;quot;sum = &amp;quot; + sumOfList(ld));
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(10) ì™€ì¼ë“œì¹´ë“œ Wildcards </title>
      <link>http://durtchrt.github.io/blog/java/generics/10/</link>
      <pubDate>Fri, 11 Nov 2016 18:23:01 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/10/</guid>
      <description>

&lt;h3 id=&#34;ì™€ì¼ë“œì¹´ë“œ-wildcards&#34;&gt;ì™€ì¼ë“œì¹´ë“œ &lt;code&gt;Wildcards&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic ì½”ë“œì—ì„œëŠ” unkown íƒ€ì…ì„ í‘œí˜„í•˜ëŠ” ë¬¼ìŒí‘œ(?)ë¥¼ ì™€ì¼ë“œ ì¹´ë“œë¼ê³  ë¶€ë¥¸ë‹¤. ì™€ì¼ë“œì¹´ë“œëŠ” ë‹¤ì–‘í•œ ìƒí™©ì—ì„œ ì“°ì¸ë‹¤.(íŒŒë¼ë©”í„°, í•„ë“œ, ì§€ì—­ë³€ìˆ˜ íƒ€ì… ë•Œë¡œëŠ” ë¦¬í„´ íƒ€ì…ì—ë„ ì“°ì¸ë‹¤. (though it is better programming practice to be more specific). ì™€ì¼ë“œì¹´ë“œëŠ” ì œë„¤ë¦­ ë©”ì„œë“œ í˜¸ì¶œ, ì œë„¤ë¦­ í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±, ë˜ëŠ” ìŠˆí¼íƒ€ì…ì„ ìœ„í•´ íƒ€ì…ì¸ìë¡œëŠ” ì‚¬ìš©ë˜ì§€ ì•ŠëŠ”ë‹¤.
&lt;code&gt;In generic code, the question mark (?), called the wildcard, represents an unknown type. The wildcard can be used in a variety of situations: as the type of a parameter, field, or local variable; sometimes as a return type (though it is better programming practice to be more specific). The wildcard is never used as a type argument for a generic method invocation, a generic class instance creation, or a supertype.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì´ë²ˆì¥ì—ëŠ” ì™€ì¼ë“œì¹´ë“œì— ëŒ€í•´ ë…¼ì˜í•œë‹¤. ìƒìœ„ì œí•œëœ ì™€ì¼ë“œì¹´ë“œ/í•˜ìœ„ì œí•œëœ ì™€ì¼ë“œì¹´ë“œ, ì™€ì¼ë“œì¹´ë“œ ìº¡ì³ë“±ì„ ë‹¤ë£¬ë‹¤.
&lt;code&gt;The following sections discuss wildcards in more detail, including upper bounded wildcards, lower bounded wildcards, and wildcard capture.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(13) Java Generics: í•˜ìœ„ ì œí•œ ì™€ì¼ë“œì¹´ë“œ(Lower Bounded Wildcards)</title>
      <link>http://durtchrt.github.io/blog/java/generics/13/</link>
      <pubDate>Mon, 07 Nov 2016 14:00:42 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/13/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/wildcards.htm://docs.oracle.com/javase/tutorial/java/generics/lowerBounded.html&#34;&gt;ì›ë¬¸ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;í•˜ìœ„-ì œí•œ-ì™€ì¼ë“œì¹´ë“œ-lower-bounded-wildcards&#34;&gt;í•˜ìœ„ ì œí•œ ì™€ì¼ë“œì¹´ë“œ  &lt;code&gt;Lower Bounded Wildcards&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ìƒìœ„ì œí•œì™€ì¼ë“œì¹´ë“œì¥ì€ íŠ¹ì • íƒ€ì…ì´ë‚˜ ê·¸ íŠ¹ì •íƒ€ì…ì˜  ì„œë¸Œíƒ€ì…ì„ ì•Œ ìˆ˜ ì—†ì„ë•ŒëŠ” &amp;lsquo;extends&amp;rsquo; í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ë³´ì—¬ì¤¬ë‹¤. ë¹„ìŠ·í•œ ê²ƒìœ¼ë¡œ, í•˜ìœ„ì œí•œì™€ì¼ë“œì¹´ë“œëŠ” íŠ¹ì •íƒ€ì…ì´ë‚˜ ê·¸ íŠ¹ì • íƒ€ì…ì˜ ìŠˆí¼íƒ€ì…ì„ ì œí•œí•˜ê³ ìí• ë•Œ ì‚¬ìš©í•œë‹¤.
&lt;code&gt;The Upper Bounded Wildcards section shows that an upper bounded wildcard restricts the unknown type to be a specific type or a subtype of that type and is represented using the extends keyword. In a similar way, a lower bounded wildcard restricts the unknown type to be a specific type or a super type of that type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;í•˜ìœ„ì œí•œ ì™€ì¼ë“œì¹´ë“œëŠ” ì™€ì¼ë“œì¹´ë“œë¬¸ì(&amp;lsquo;?&amp;rsquo;) ê·¸ ë’¤ë¡œ super í‚¤ì›Œë“œì™€ ê·¸ ë’¤ë¡œ í•˜ìœ„ì œí•œ íƒ€ì…ì´ ì˜¨ë‹¤. &amp;lt;? super A&amp;gt;.
&lt;code&gt;A lower bounded wildcard is expressed using the wildcard character (&#39;?&#39;), following by the super keyword, followed by its lower bound: &amp;lt;? super A&amp;gt;.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ì¤‘ìš”: ìƒìœ„ì œí•œì™€ì¼ë“œì¹´ë“œë¥¼ ì‚¬ìš©í•˜ê±°ë‚˜ í•˜ìœ„ì œí•œì™€ì¼ë“œì¹´ë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆì§€ë§Œ, ë‘˜ì„ ë™ì‹œì— ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.&lt;/code&gt;
&lt;code&gt;Note: You can specify an upper bound for a wildcard, or you can specify a lower bound, but you cannot specify both.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ë¦¬ìŠ¤íŠ¸ì— Integer ê°ì²´ë¥¼ ë„£ëŠ” ì½”ë“œë¥¼ ì‘ì„±í• ë•Œ, List&amp;lt;Integer&amp;gt;, List&amp;lt;Number&amp;gt;, List&amp;lt;Object\&amp;gt;ì—ì„œë§Œ ë™ì‘í•˜ê¸¸ ì›í•˜ëŠ” ë©”ì„œë“œë¥¼ ë§Œë“ ë‹¤ê³  ê°€ì •í•˜ì.
&lt;code&gt;Say you want to write a method that puts Integer objects into a list. To maximize flexibility, you would like the method to work on List&amp;lt;Integer&amp;gt;, List&amp;lt;Number&amp;gt;, and List&amp;lt;Object&amp;gt; â€” anything that can hold Integer values.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Integeríƒ€ì´ì´ë‚˜ Integerì˜ ìƒìœ„íƒ€ì…ì—ì„œ ë™ì‘í•˜ëŠ” ë©”ì„œë“œë¥¼ ì‘ì„±í•˜ë ¤ë©´ List&amp;lt;? super Integer&amp;gt;ë¼ê³  í•  ìˆ˜ ìˆë‹¤. List&amp;lt;Integer&amp;gt;ëŠ” List&amp;lt;? super Integer&amp;gt;ë³´ë‹¤ ì œí•œì ì´ë‹¤. ì™œëƒí•˜ë©´ ì „ìëŠ” Integer íƒ€ì…ì˜ ë¦¬ìŠ¤íŠ¸ë§Œ ì‚¬ìš©, í›„ìëŠ” Integer íƒ€ì…ê³¼ Integerì˜ ìŠˆí¼íƒ€ì…ì— ì‚¬ìš©í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.
&lt;code&gt;To write the method that works on lists of Integer and the supertypes of Integer, such as Integer, Number, and Object, you would specify List&amp;lt;? super Integer&amp;gt;. The term List&amp;lt;Integer&amp;gt; is more restrictive than List&amp;lt;? super Integer&amp;gt; because the former matches a list of type Integer only, whereas the latter matches a list of any type that is a supertype of Integer.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì•„ë˜ì˜ ì½”ë“œëŠ” 1ì—ì„œ 10ê¹Œì§€ ë¦¬ìŠ¤íŠ¸ì— addí•œë‹¤.
&lt;code&gt;The following code adds the numbers 1 through 10 to the end of a list:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void addNumbers(List&amp;lt;? super Integer&amp;gt; list) {
    for (int i = 1; i &amp;lt;= 10; i++) {
        list.add(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì™€ì¼ë“œì¹´ë“œ ì‚¬ìš©ì ˆì—ì„œëŠ” ìƒìœ„ì œí•œì™€ì¼ë“œì¹´ë“œì™€ í•˜ìœ„ì œí•œì™€ì¼ë“œì¹´ë“œë¥¼ ê°ê° ì–¸ì œ ì‚¬ìš©í• ì§€ ì„¤ëª…í•˜ì˜€ë‹¤.
&lt;code&gt;The Guidelines for Wildcard Use section provides guidance on when to use upper bounded wildcards and when to use lower bounded wildcards.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(12) Java Generics: ìƒìœ„ ì œí•œëœ ì™€ì¼ë“œì¹´ë“œ(Upper Bounded Wildcards)</title>
      <link>http://durtchrt.github.io/blog/java/generics/12/</link>
      <pubDate>Mon, 07 Nov 2016 13:00:42 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/12/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/unboundedWildcards.html&#34;&gt;ì›ë¬¸ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì œí•œì—†ëŠ”-ì™€ì¼ë“œì¹´ë“œ-unbounded-wildcards&#34;&gt;ì œí•œì—†ëŠ” ì™€ì¼ë“œì¹´ë“œ &lt;code&gt;Unbounded Wildcards&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ì œí•œì—†ëŠ” ì™€ì¼ë“œì¹´ë“œ íƒ€ì…ì€ ì™€ì¼ë“œì¹´ë“œ ë¬¸ì(&amp;lsquo;?&amp;rsquo;)ë§Œ ì‚¬ìš©í•œê²ƒì´ë‹¤. ì˜ˆë¥¼ ë“¤ë©´ List&amp;lt;?&amp;gt;ì™€ ê°™ë‹¤. List&amp;lt;?&amp;gt;ì˜ ?ëŠ” Listì˜ &amp;lsquo;ì•Œìˆ˜ì—†ëŠ” íƒ€ì…(unkown type)&amp;lsquo;ì´ë¼ê³  ë¶€ë¥¸ë‹¤. ì•„ë˜ ë‘ê°œì˜ ì‹œë‚˜ë¦¬ì˜¤ëŠ” ì œí•œì—†ëŠ” ì™€ì¼ë“œì¹´ë“œê°€ ìœ ìš©í•œ ì ‘ê·¼ë²•ì´ë‹¤.
&lt;code&gt;The unbounded wildcard type is specified using the wildcard character (?), for example, List&amp;lt;?&amp;gt;. This is called a list of unknown type. There are two scenarios where an unbounded wildcard is a useful approach:&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Object í´ë˜ìŠ¤ì—ì„œ ì œê³µí•˜ëŠ” ê¸°ëŠ¥(ë©”ì„œë“œ)ì„ ì‚¬ìš©í•˜ë„ë¡ ë©”ì„œë“œë¥¼ êµ¬í˜„í•  ë•Œ.
&lt;code&gt;- If you are writing a method that can be implemented using functionality provided in the Object class.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ì½”ë“œê°€ generic í´ë˜ìŠ¤ì—ì„œ ë©”ì„œë“œê°€ íƒ€ì…ë§¤ê°œë³€ìˆ˜ì— ì˜ì¡´ì ì´ì§€ ì•Šê²Œ ì‘ì„±í•˜ê³  ì‹¶ì„ ë•Œ.(ì˜ˆ List.sizeë‚˜ List.clear). ì‚¬ì‹¤, Class&amp;lt;T&amp;gt; í´ë˜ìŠ¤ëŠ” ë²”ìœ„ì—†ëŠ” ì™€ì¼ë“œì¹´ë“œë¥¼ ìì£¼ ì‚¬ìš©í•œë‹¤.(Class&amp;lt;T&amp;gt;ì˜ ë©”ì„œë“œê°€ Tì— ì˜ì¡´ì ìœ¼ë¡œ ë™ì‘í•˜ì§€ ì•Šê²Œ ë§Œë“¤ê¸° ìœ„í•´)
&lt;code&gt;- When the code is using methods in the generic class that don&#39;t depend on the type parameter. For example, List.size or List.clear. In fact, Class&amp;lt;?&amp;gt; is so often used because most of the methods in Class&amp;lt;T&amp;gt; do not depend on T.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;printList ë©”ì„œë“œë¥¼ ì‚´í´ë³´ì.
&lt;code&gt;Consider the following method, printList:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void printList(List&amp;lt;Object&amp;gt; list) {
    for (Object elem : list)
        System.out.println(elem + &amp;quot; &amp;quot;); // elem.toString() ìë™ìœ¼ë¡œ í˜¸ì¶œë¨.
    System.out.println();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;printListëŠ” Listê°€ ê°€ì§„ ê°ì²´ê°€ ì–´ë–¤ íƒ€ì…ì´ë“ ê°„ì— ìƒê´€ì—†ì´ printí•˜ê³  ì‹¶ì–´í•œë‹¤. í•˜ì§€ë§Œ List ê°ì²´ëŠ” Object íƒ€ì…ì˜ ê°ì²´ë§Œ ì¶œë ¥í•  ìˆ˜ ìˆë‹¤. (ì°¸ì¡°:&lt;a href=&#34;../8&#34;&gt;ì œë„¤ë¦­ìŠ¤, ìƒì†, ì„œë¸Œíƒ€ì…&lt;/a&gt;) List&amp;lt;Object&amp;gt;ëŠ” List&amp;lt;Integer&amp;gt;, List&amp;lt;String&amp;gt;, List&amp;lt;Double&amp;gt;ì„ ì¶œë ¥í•  ìˆ˜ ì—†ë‹¤. ì™œëƒí•˜ë©´ List&amp;lt;Object&amp;gt; íƒ€ì…ì˜ stub type(ìŠ¤í…íƒ€ì… ìš©ì–´ ì•„ì‹œëŠ”ë¶„ ê³µìœ  ë¶€íƒìš” ã… ã… )ì´ ì•„ë‹ˆë‹¤. ì•„ë˜ëŠ” List&amp;lt;?&amp;gt;ë¥¼ ì‚¬ìš©í•´ì„œ generic ë©”ì„œë“œì¸ printListë¥¼ ì‘ì„±í•œ ì˜ˆì´ë‹¤..&lt;/p&gt;

&lt;p&gt;&lt;code&gt;The goal of printList is to print a list of any type, but it fails to achieve that goal â€” it prints only a list of Object instances; it cannot print List&amp;lt;Integer&amp;gt;, List&amp;lt;String&amp;gt;, List&amp;lt;Double&amp;gt;, and so on, because they are not subtypes of List&amp;lt;Object&amp;gt;. To write a generic printList method, use List&amp;lt;?&amp;gt;:&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(ì—­ì ì¶”ê°€ - ìœ„ì˜ ì˜ˆê°€ ì„¤ëª…í•˜ëŠ” ì½”ë“œ - ì»´íŒŒì¼ ì—ëŸ¬ ë°œìƒ)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Integer&amp;gt; integerList = Arrays.asList(1,2);
printList(integerList);   // ì»´íŒŒì¼ ì—ëŸ¬
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void printList(List&amp;lt;?&amp;gt; list) {
    for (Object elem: list)
        System.out.print(elem + &amp;quot; &amp;quot;);
    System.out.println();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì•„ë¬´ íƒ€ì…ì„ Aë¡œ ì§€ì¹­í–ˆì„ë•Œ, List&amp;lt;?&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ì€ List&amp;lt;A&amp;gt;ì´ ì„±ë¦½ì´ ë˜ê¸° ë•Œë¬¸ì—, printList ë©”ì„œë“œê°€ ëª¨ë“  íƒ€ì…ì„ ëŒ€ìƒìœ¼ë¡œ printí•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;Because for any concrete type A, List&amp;lt;A&amp;gt; is a subtype of List&amp;lt;?&amp;gt;, you can use printList to print a list of any type:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Integer&amp;gt; li = Arrays.asList(1, 2, 3);
List&amp;lt;String&amp;gt;  ls = Arrays.asList(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;);
printList(li);
printList(ls);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì°¸ê³ : Arrays.asList ë©”ì„œë“œëŠ” ë²”ìœ„ì—†ëŠ” ì™€ì¼ë“œì¹´ë“œë¥¼ ì‚¬ìš©í•´ì„œ êµ¬í˜„ë˜ì—ˆë‹¤. Arrays.asListë¼ëŠ” static íŒ©í† ë¦¬ ë©”ì„œë“œëŠ” ë°°ì—´ì„ êµ¬ì²´í™”í•˜ì—¬ ë³€ê²½í•˜ê³ (ìš”ì†Œë“¤ì˜ ê³µí†µ íƒ€ì…ì„ íƒ€ì…ì¶”ë¡ )  ê³ ì •ëœ ì‚¬ì´ì¦ˆì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•œë‹¤.
&lt;code&gt;Note: The Arrays.asList method is used in examples throughout this lesson. This static factory method converts the specified array and returns a fixed-size list.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(ì¤‘ìš”!)List&lt;Object&gt;ì™€ List&amp;lt;?&amp;gt;ê³¼ ë‹¤ë¥´ë‹¤. List&lt;Object&gt;ì— Object íƒ€ì…ì´ë‚˜ Objectì˜ ì„œë¸Œíƒ€ì…ì„ insertí•  ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ List&amp;lt;?&amp;gt;ì—ëŠ” nullë§Œ insertí•  ìˆ˜ ìˆë‹¤.(í•˜ê³ ìí•˜ëŠ” ë§ì´ ë¬´ì–¸ì§€ ì´í•´ê°€ ì•ˆëœë‹¤;;;) ì™€ì¼ë“œì¹´ë“œ ì‚¬ìš© ì„¹ì…˜ì€ì€ ìƒí™©ë³„ ì–´ë–¤ ì™€ì¼ë“œì¹´ë“œë¥¼ ì‚¬ìš©í• ì§€ ê²°ì •ì— ëŒ€í•œ ê°€ì´ë“œë¼ì¸ì„ ì œê³µí•œë‹¤.
&lt;code&gt;It&#39;s important to note that List&amp;lt;Object&amp;gt; and List&amp;lt;?&amp;gt; are not the same. You can insert an Object, or any subtype of Object, into a List&amp;lt;Object&amp;gt;. But you can only insert null into a List&amp;lt;?&amp;gt;. The Guidelines for Wildcard Use section has more information on how to determine what kind of wildcard, if any, should be used in a given situation.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(9) Java Generics: íƒ€ì…ì¶”ë¡ (Type Inference)</title>
      <link>http://durtchrt.github.io/blog/java/generics/9/</link>
      <pubDate>Sat, 05 Nov 2016 18:23:01 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/9/</guid>
      <description>

&lt;p&gt;ìš©ì–´&lt;/p&gt;

&lt;p&gt;statement: ë¬¸ì¥ìœ¼ë¡œ í•´ì„í•˜ë©´ ì˜¤í•´ì˜ ì—¬ì§€ê°€ ìˆì–´ì„œ statement ì˜ë¬¸ ê·¸ëŒ€ë¡œ ì‘ì„±í•œë‹¤. ì»´í“¨í„° í”„ë¡œê·¸ë˜ë°ì—ì„œëŠ” statementë¥¼ ë…ë¦½ì ì¸ ìš”ì†Œì˜ ìµœì†Œ ë‹¨ìœ„. &lt;a href=&#34;https://en.wikipedia.org/wiki/Statement_(computer_science)&#34;&gt;ì˜ë¬¸ìœ„í‚¤&lt;/a&gt;ì˜ ì¤‘ê°„ì„ ë³´ë©´ Kinds of statements íŒŒíŠ¸ì— Simple statments, Compound statements ë¶€ë¶„ì˜ ì½”ë“œë¥¼ ë³´ë©´ ëŠë‚Œì´ ì˜¨ë‹¤.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html&#34;&gt;ì›ë¬¸ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;íƒ€ì…ì¶”ë¡ -type-inference&#34;&gt;íƒ€ì…ì¶”ë¡  &lt;code&gt;Type Inference&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;íƒ€ì…ì¶”ë¡ ì€ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ì½”ë“œì—ì„œ íƒ€ì…ì¸ìê°€ ì •ì˜í•œëŒ€ë¡œ ì œëŒ€ë¡œ ì“°ì˜€ëŠ”ì§€ ì‚´í´ë³´ëŠ” ì»´íŒŒì¼ëŸ¬ì˜ ëŠ¥ë ¥ì´ë‹¤. íƒ€ì…ì¶”ë¡ ì€ ì¸ìì˜ íƒ€ì…ì„ í™•ì¸í•˜ê³  ë§Œì•½ ì‚¬ìš©ê°€ëŠ¥í•˜ë‹¤ë©´, í•´ë‹¹ íƒ€ì…ì„ í• ë‹¹í•˜ê±°ë‚˜ ë¦¬í„´ë  ê²ƒì´ë‹¤. ê²°êµ­ íƒ€ì…ì¶”ë¡ ì€ ëª¨ë“  ì¸ìì— ë™ì‘í•´ì„œ ê°€ì¥ êµ¬ì²´ì ì¸ íƒ€ì…ì„ ì°¾ëŠ” ê²ƒì„ ì‹œë„í•œë‹¤.(ë­”ê°€ ë§ì´ ì–´ë µë‹¤;;)
&lt;code&gt;[Type inference is a Java compiler&#39;s ability to look at each method invocation and corresponding declaration to determine the type argument (or arguments) that make the invocation applicable.] The inference algorithm determines the types of the arguments and, if available, the type that the result is being assigned, or returned. Finally, the inference algorithm tries to find the most specific type that works with all of the arguments.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;~&lt;del&gt;ì•„ë˜ì˜ ì˜ˆëŠ” ë§ˆì§€ë§‰ ì§€ì ì„ ì„¤ëª…í•œë‹¤.&lt;/del&gt;~ íƒ€ì…ì¶”ë¡ ì€ ë‘ë²ˆì§¸ ì¸ìê°€ ì „ë‹¬ë  ë•Œ pick ë©”ì„œë“œëŠ” Serializableë¡œ ê²°ì •ë˜ì–´ì§‘ë‹ˆë‹¤.
(ì—­ì£¼: pickì˜ ë‘ ì¸ì a1, a2ëŠ” íƒ€ì…ì¸ìë¡œ Stringê³¼ ArrayListë¥¼ ì „ë‹¬ ë°›ëŠ”ë‹¤. ë‘˜ì˜ ê³µí†µì ì€ Serializable ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ í´ë˜ìŠ¤ë¼ëŠ” ê²ƒì´ë‹¤. ì¸ìë“¤ì´ ê°™ì€ íƒ€ì…ì´ ì•„ë‹ˆë©´ ê°ê° ì¸ìë“¤ì˜ íƒ€ì…ì—ì„œ ê³µí†µìœ¼ë¡œ ì“°ëŠ” ìŠˆí¼ íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ . ì½”ë“œë ˆë²¨ë¡œ ì‘ì„±í•œê±°ë¼ ì¶”ë¡ ì´ë¼í•˜ê¸´ ë­í•œë°&amp;hellip; ì¼ë‹¨ ì§„í–‰.)
&lt;code&gt;To illustrate this last point, in the following example, inference determines that the second argument being passed to the pick method is of type Serializable:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static &amp;lt;T&amp;gt; T pick(T a1, T a2) { return a2; }
Serializable s = pick(&amp;quot;d&amp;quot;, new ArrayList&amp;lt;String&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;íƒ€ì…ì¶”ë¡ ê³¼-generic-ë©”ì„œë“œ-type-inference-and-generic-methods&#34;&gt;íƒ€ì…ì¶”ë¡ ê³¼ Generic ë©”ì„œë“œ &lt;code&gt;Type Inference and Generic Methods&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Generic ë©”ì„œë“œëŠ” êº½ì‡ ì•ˆì— íƒ€ì…ì„ ì‘ì„±í•˜ì§€ ì•Šê³ (ë¹ˆíƒ€ì…ì¸ì) ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë©´ íƒ€ì…ì¶”ë¡ ì„ ë³´ì—¬ì¤€ë‹¤. BoxDemo ì˜ˆë¥¼ ë³´ì‹œì˜¤. ì´ ì˜ˆëŠ” Box í´ë˜ìŠ¤ë¥¼ í•„ìš”ë¡œí•©ë‹ˆë‹¤.
&lt;code&gt;Generic Methods introduced you to type inference, which enables you to invoke a generic method as you would an ordinary method, without specifying a type between angle brackets. Consider the following example, BoxDemo, which requires the Box class:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BoxDemo {

  public static &amp;lt;U&amp;gt; void addBox(U u, 
      java.util.List&amp;lt;Box&amp;lt;U&amp;gt;&amp;gt; boxes) {
    Box&amp;lt;U&amp;gt; box = new Box&amp;lt;&amp;gt;();
    box.set(u);
    boxes.add(box);
  }

  public static &amp;lt;U&amp;gt; void outputBoxes(java.util.List&amp;lt;Box&amp;lt;U&amp;gt;&amp;gt; boxes) {
    int counter = 0;
    for (Box&amp;lt;U&amp;gt; box: boxes) {
      U boxContents = box.get();
      System.out.println(&amp;quot;Box #&amp;quot; + counter + &amp;quot; contains [&amp;quot; +
             boxContents.toString() + &amp;quot;]&amp;quot;);
      counter++;
    }
  }

  public static void main(String[] args) {
    java.util.ArrayList&amp;lt;Box&amp;lt;Integer&amp;gt;&amp;gt; listOfIntegerBoxes =
      new java.util.ArrayList&amp;lt;&amp;gt;();
    BoxDemo.&amp;lt;Integer&amp;gt;addBox(Integer.valueOf(10), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(30), listOfIntegerBoxes);
    BoxDemo.outputBoxes(listOfIntegerBoxes);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ì˜ˆì œëŠ” ì•„ë˜ì™€ ê°™ì€ ê²°ê³¼ë¥¼ ì¶œë ¥í•œë‹¤.
&lt;code&gt;The following is the output from this example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Box #0 contains [10]
Box #1 contains [20]
Box #2 contains [30]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generic ë©”ì„œë“œì¸ addboxëŠ” Uë¼ëŠ” íƒ€ì…ë§¤ê°œë³€ìˆ˜ê°€ ì„ ì–¸ë˜ì–´ìˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ, ìë°”ì»´íŒŒì¼ëŸ¬ëŠ” generic ë©”ì„œë“œ í˜¸ì¶œí•˜ëŠ” ì½”ë“œë¥¼ ë³´ê³  íƒ€ì…íŒŒë¼ë©”í„°ë¥¼ ì¶”ë¡ í•  ìˆ˜ ìˆë‹¤. ê·¸ ê²°ê³¼, ëŒ€ë¶€ë¶„ íƒ€ì…ì„ ê¼­ ëª…ì‹œí•˜ì§€ ì•Šì•„ë„ ëœë‹¤. ì˜ˆë¥¼ ë“¤ì–´ addBoxë¼ëŠ” generic ë©”ì„œë“œë¥¼ í˜¸ì¶œí• ë•Œ, ì•„ë˜ ì½”ë“œì²˜ëŸ¼ êµ¬ì²´ì ì¸ íƒ€ì… ë§¤ê°œë³€ìˆ˜ë¥¼ ì¤„ ìˆ˜ ìˆë‹¤.
&lt;code&gt;The generic method addBox defines one type parameter named U. Generally, a Java compiler can infer the type parameters of a generic method call. Consequently, in most cases, you do not have to specify them. For example, to invoke the generic method addBox, you can specify the type parameter with a type witness as follows:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BoxDemo.&amp;lt;Integer&amp;gt;addBox(Integer.valueOf(10), listOfIntegerBoxes);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ì½”ë“œ ëŒ€ì‹  ì•„ë˜ ì½”ë“œì²˜ëŸ¼ íƒ€ì… ì •ë³´ë¥¼ ì œê³µí•˜ì§€ ì•Šê³  ì½”ë“œë¥¼ ì‘ì„±í•´ë„, ìë°” ì»´íŒŒì¼ëŸ¬ëŠ” íƒ€ì…ë§¤ê°œë³€ìˆ˜ê°€ Integerë¼ê³  (ë©”ì„œë“œì˜ ì¸ìë“¤ë¡œë¶€í„°) ìë™ìœ¼ë¡œ ì¶”ë¡ ì„ í•œë‹¤.
&lt;code&gt;Alternatively, if you omit the type witness,a Java compiler automatically infers (from the method&#39;s arguments) that the type parameter is Integer:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;íƒ€ì…ì¶”ë¡ ê³¼-generic-ê°ì²´-type-inference-and-instantiation-of-generic-classes&#34;&gt;íƒ€ì…ì¶”ë¡ ê³¼ generic ê°ì²´  &lt;code&gt;Type Inference and Instantiation of Generic Classes&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic í´ë˜ìŠ¤ë¥¼ ìƒì„±ìë¥¼ í†µí•´ ê°ì²´ë¥¼ ìƒì„±í•  ë•Œ íƒ€ì…ì¸ì ëŒ€ì‹  ë¹ˆíƒ€ì…íŒŒë¼ë¯¸í„°(&amp;lt;&amp;gt;)ë¥¼ ì‚¬ìš©í• ë•Œ ìë°” ì»´íŒŒì¼ëŸ¬ëŠ” ì½”ë“œ ë¬¸ë§¥ìœ¼ë¡œë¶€í„° íƒ€ì…ì¸ìë¥¼ ìœ ì¶”í•  ìˆ˜ ìˆë‹¤. ë¹„ê³µì‹ì ìœ¼ë¡œ í•œìŒì˜ êº½ì‡ (&amp;lt;&amp;gt;)ëŠ” ë‹¤ì´ì•„ëª¬ë“œë¼ê³  ë¶€ë¥¸ë‹¤.
&amp;lsquo;You can replace the type arguments required to invoke the constructor of a generic class with an empty set of type parameters (&amp;lt;&amp;gt;) as long as the compiler can infer the type arguments from the context. This pair of angle brackets is informally called the diamond.&amp;rsquo;&lt;/p&gt;

&lt;p&gt;ì˜ˆë¥¼ ë“¤ì–´ ë³€ìˆ˜ ì„ ì–¸ì„ ë³´ì.
&lt;code&gt;For example, consider the following variable declaration:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; myMap = new HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(ìœ„ì˜ ì˜ˆì œ ì²˜ëŸ¼)generic í´ë˜ìŠ¤ì˜ ìƒì„±ìì— íƒ€ì…ë§¤ê°œë³€ìˆ˜í™”í•œ ìƒì„±ì ëŒ€ì‹  (ì•„ë˜ ì˜ˆì œ ì²˜ëŸ¼)&amp;lt;&amp;gt;ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;You can substitute the parameterized type of the constructor with an empty set of type parameters (&amp;lt;&amp;gt;):&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; myMap = new HashMap&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generic í´ë˜ìŠ¤ë¥¼ ê°ì²´í™”í•  ë•Œ íƒ€ì…ì¶”ë¡ ì„ ì‹œí‚¤ë ¤ë©´ ë°˜ë“œì‹œ ë‹¤ì´ì•„ëª¬ë“œ ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤. ì•„ë˜ì˜ ì˜ˆë¥¼ ë³´ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” Hashë§µì„ rawíƒ€ì…ìœ¼ë¡œ ì¸ì‹í•´ì„œ ê²½ê³ ë¥¼ í•œë‹¤.(ì„ ì–¸ë¬¸ì˜ Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;ì„ ë³´ê³  í• ë‹¹ë¬¸ì˜ HashMapì˜ ìƒì„±ìëŠ” íƒ€ì…ì¶”ë¡ ì„ í•˜ì§€ ì•ŠëŠ”ë‹¤. ê·¸ëƒ¥ raw íƒ€ì…ì´ ëœë‹¤. )
&lt;code&gt;Note that to take advantage of type inference during generic class instantiation, you must use the diamond. In the following example, the compiler generates an unchecked conversion warning because the HashMap() constructor refers to the HashMap raw type, not the Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; type:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; myMap = new HashMap(); // unchecked conversion warning
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;íƒ€ì…ì¶”ë¡ ê³¼-generic-íƒ€ì…ì˜-generic-ìƒì„±ì-ê·¸ë¦¬ê³ -non-generic-í´ë˜ìŠ¤ê°€-type-inference-and-generic-constructors-of-generic-and-non-generic-classes&#34;&gt;íƒ€ì…ì¶”ë¡ ê³¼ generic íƒ€ì…ì˜ Generic ìƒì„±ì ê·¸ë¦¬ê³  Non-Generic í´ë˜ìŠ¤ê°€ &lt;code&gt;Type Inference and Generic Constructors of Generic and Non-Generic Classes&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic í´ë˜ìŠ¤ì™€ non-generic í´ë˜ìŠ¤ëŠ” ë‘˜ë‹¤ generic(ì¼ë°˜ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ì„ ì–¸)ì´ ë  ìˆ˜ ìˆë‹¤. ì•„ë˜ ì˜ˆë¥¼ ë³´ì
&lt;code&gt;Note that constructors can be generic (in other words, declare their own formal type parameters) in both generic and non-generic classes. Consider the following example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MyClass&amp;lt;X&amp;gt; {
  &amp;lt;T&amp;gt; MyClass(T t) {
    // ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MyClass í´ë˜ìŠ¤ì˜ ê°ì²´ ìƒì„±ì„ ì‚´í´ë³´ë©´
&lt;code&gt;Consider the following instantiation of the class MyClass:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new MyClass&amp;lt;Integer&amp;gt;(&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ì½”ë“œëŠ” MyClass&amp;lt;Integer&amp;gt;ë¼ëŠ” ë§¤ê°œë³€ìˆ˜í™”ëœ íƒ€ì…ì˜ ê°ì²´ë¥¼ ìƒì„±í•˜ëŠ” statementì´ë‹¤. ì´ statementëŠ” generic í´ë˜ìŠ¤ì¸ MyClass&amp;lt;X&amp;gt;ì˜ íƒ€ì…ë§¤ê°œë³€ìˆ˜ì˜ í˜•ì‹ì„ Integer íƒ€ì…ìœ¼ë¡œ êµ¬ì²´í™”í•˜ë„ë¡ ëª…ì‹œí•œë‹¤. ì¤‘ìš”í•œì ì€ generic í´ë˜ìŠ¤ì˜ ìƒì„±ìëŠ” Të¼ëŠ” í˜•ì‹ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ í¬í•¨í•´ì•¼í•œë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” generic í´ë˜ìŠ¤ì˜ ìƒì„±ìì˜ í˜•ì‹ íŒŒë¼ë©”í„° Të¥¼ String íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ í•œë‹¤.(ì™œëƒí•˜ë©´ ìƒì„±ìì˜ ë§¤ê°œë³€ìˆ˜ëŠ” String íƒ€ì…ì˜ ê°ì²´ì´ê¸° ë•Œë¬¸ì´ë‹¤.)
&lt;code&gt;This statement creates an instance of the parameterized type MyClass&amp;lt;Integer&amp;gt;; the statement explicitly specifies the type Integer for the formal type parameter, X, of the generic class MyClass&amp;lt;X&amp;gt;. Note that the constructor for this generic class contains a formal type parameter, T. The compiler infers the type String for the formal type parameter, T, of the constructor of this generic class (because the actual parameter of this constructor is a String object).&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(ì—­ì - ë²ˆì—­í•˜ë‹¤ê°€ ë„í†µ ë­”ë§ì¸ì§€ ëª°ë¼ì„œ ì½”ë”©í•´ë´„.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Main {
	public static void main(String[] args) {
		MyClass&amp;lt;Integer&amp;gt; a = new MyClass&amp;lt;&amp;gt;(&amp;quot;&amp;quot;);
		System.out.println(a.x.getClass().getSimpleName());
	}
}

class MyClass&amp;lt;X&amp;gt; {
	X x;
	&amp;lt;T&amp;gt; MyClass(T t) {
		this.x = (X) t;
	}
}
// ëŸ°íƒ€ì„ ì—ëŸ¬ ë°œìƒë˜ëŠ” ì½”ë“œ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(ì—­ì)MyClassì˜ ìƒì„±ìì˜ Të¼ëŠ” íƒ€ì…ë§¤ê°œë³€ìˆ˜ë§Œ ì ìœ¼ë©´ ì»´íŒŒì¼ì´ ì•ˆëœë‹¤. ìƒì„±ì ì•ì— &amp;lt;T&amp;gt;ë¥¼ ë„£ì–´ì¤˜ì•¼ ì»´íŒŒì¼ì´ ë˜ëŠ”ë° ìš”ë†ˆì„ í˜•ì‹íƒ€ì…ë§¤ê°œë³€ìˆ˜ê°€ë¡œ ì§€ì¹­í•˜ëŠ” ê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤. í´ë˜ìŠ¤ì— ì ì–´ì¤€ &amp;lt;X&amp;gt;ë‘ì€ ë‹¤ë¦„ì„ ì£¼ì˜. ì•„ì§ì€ ë”±íˆ ì–´ëŠ ìƒí™©ì— ì¨ì•¼í• ì§€ ì˜ ëª¨ë¥´ê² ë‹¤&amp;hellip;.&lt;/p&gt;

&lt;p&gt;generic ë©”ì„œë“œì²˜ëŸ¼ generic ìƒì„±ìì—ì„œ ì‹¤ì œ íƒ€ì…íŒŒë¼ë©”í„°ë¥¼ ì¶”ë¡ í•˜ëŠ” ëŠ¥ë ¥ì€ Java SE 7ì´ì „ ì»´íŒŒì¼ëŸ¬ì—ì„œ ë¦´ë¦¬ì¦ˆë˜ì—ˆë‹¤.(ì—­ì??? ì´ë¶€ë¶„ì´ ì´í•´ê°€ ì•ˆê°) í•˜ì§€ë§Œ Java SE 7 ì´í›„ ì»´íŒŒì¼ëŸ¬ëŠ” ë‹¤ì´ì•„ëª¬ë“œì—°ì‚°ì(&amp;lt;&amp;gt;)ë¥¼ ì‚¬ìš©í•´ì„œ generic í´ë˜ìŠ¤ë¥¼ ê°ì²´ ìƒì„±í•  ë•Œ ì‹¤ì œ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ì¶”ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì•„ë˜ì˜ ì˜ˆë¥¼ ë³´ì„¸ìš”.
&lt;code&gt;Compilers from releases prior to Java SE 7 are able to infer the actual type parameters of generic constructors, similar to generic methods. However, compilers in Java SE 7 and later can infer the actual type parameters of the generic class being instantiated if you use the diamond (&amp;lt;&amp;gt;). Consider the following example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MyClass&amp;lt;Integer&amp;gt; myObject = new MyClass&amp;lt;&amp;gt;(&amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ì˜ˆì œëŠ” ì»´íŒŒì¼ëŸ¬ê°€ generic í´ë˜ìŠ¤ MyClass&amp;lt;X&amp;gt;ì˜ í˜•ì‹íƒ€ì… íŒŒë¼ë©”í„° Xë¥¼ Integer íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ í•œë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” generic í´ë˜ìŠ¤ì˜ ìƒì„±ìì˜ í˜•ì‹ë§¤ê°œë³€ìˆ˜ Tì— String íƒ€ì…ì„ ì¶”ë¡ í•œë‹¤.
&lt;code&gt;In this example, the compiler infers the type Integer for the formal type parameter, X, of the generic class MyClass&amp;lt;X&amp;gt;. It infers the type String for the formal type parameter, T, of the constructor of this generic class.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì¤‘ìš”: íƒ€ì…ì¶”ë¡  ì•Œê³ ë¦¬ì¦˜ì€ ì¸ì, ëŒ€ìƒ íƒ€ì…, ëª…ë°±íˆ ê¸°ëŒ€ë˜ëŠ” ë¦¬í„´ íƒ€ì…ë§Œ ì‚¬ìš©í•œë‹¤. ì¶”ë¡  ì•Œê³ ë¦¬ì¦˜ì€ í”„ë¡œê·¸ë¨ì—ì„œ ë‚˜ì¤‘ì— ê²°ê³¼ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤. (ì—­ì: ë‚´ìš©ì´ ëª…í™•íˆ ì•ˆë“¤ì–´ì˜´.)
&lt;code&gt;Note: It is important to note that the inference algorithm uses only invocation arguments, target types, and possibly an obvious expected return type to infer types. The inference algorithm does not use results from later in the program.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;target-types&#34;&gt;&lt;code&gt;Target Types&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ìë°” ì»´íŒŒì¼ëŸ¬ëŠ” generic ë©”ì„œë“œ í˜¸ì¶œì— íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ì¶”ë¡ í•˜ëŠ” target typingì€ ì¥ì ì„ ê°€ì§„ë‹¤. target type í‘œí˜„ì‹ì€ ìë°” ì»´íŒŒì¼ëŸ¬ê°€ ê¸°ëŒ€í•˜ëŠ” ë°ì´í„° íƒ€ì…ì´ë‹¤. Collection.emptyList ë©”ì„œë“œë¥¼ ì‚´í´ë³´ë©´ ì•„ë˜ì™€ ê°™ì´ ì„ ì–¸ë˜ì–´ìˆë‹¤.
&lt;code&gt;The Java compiler takes advantage of target typing to infer the type parameters of a generic method invocation. [The target type of an expression is the data type that the Java compiler expects depending on where the expression appears.] Consider the method Collections.emptyList, which is declared as follows:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; emptyList();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;í• ë‹¹ë¬¸ì„ ì‚´í´ë³´ë©´:
&lt;code&gt;Consider the following assignment statement:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; listOne = Collections.emptyList();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì´ statementëŠ” List&lt;String&gt;ì˜ ê°ì²´ë¥¼ ê¸°ëŒ€í•œë‹¤. ì´ ë°ì´í„° íƒ€ì…ì´ target typeì´ë‹¤. ì™œëƒí•˜ë©´ emptyList ë©”ì„œë“œëŠ” List&lt;T&gt; íƒ€ì…ì˜ ê°’ì„ ë¦¬í„´í•œë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” íƒ€ì…ì¸ìëŠ” ë°˜ë“œì‹œ String íƒ€ì…ì˜ ê°’ì¼ ê²ƒì´ë¼ê³  ì¶”ë¡ í•œë‹¤. ì´ëŠ” Java SE 7 ì´ìƒì—ì„œ ë™ì‘í•œë‹¤. ì¶”ë¡  ëŒ€ì‹ ì— ì•„ë˜ì˜ ì˜ˆì²˜ëŸ¼ íƒ€ì…ë§¤ê°œë³€ìˆ˜ Tì˜ íƒ€ì…ì¸ìê°’ì„ íŠ¹ì • íƒ€ì…ê°’ì„ ëª…ì‹œí•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;This statement is expecting an instance of List&amp;lt;String&amp;gt;; this data type is the target type. Because the method emptyList returns a value of type List&amp;lt;T&amp;gt;, the compiler infers that the type argument T must be the value String. This works in both Java SE 7 and 8. Alternatively, you could use a type witness and specify the value of T as follows:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; listOne = Collections.&amp;lt;String&amp;gt;emptyList();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;í•˜ì§€ë§Œ ìœ„ì˜ ì½”ë“œ ë¬¸ë§¥ìƒ target typeì´ í•„ìš”ì¹˜ ì•Šë‹¤. ì½”ë“œë¬¸ë§¥ìƒ target typeì´ í•„ìš”í•œ ì˜ˆë¥¼ ì•„ë˜ ì½”ë“œë¥¼ ë³´ë©° ì‚´í´ë³´ì.
&lt;code&gt;However, this is not necessary in this context. It was necessary in other contexts, though. Consider the following method:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void processStringList(List&amp;lt;String&amp;gt; stringList) {
    // process stringList
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë¹ˆë¦¬ìŠ¤íŠ¸ì™€ í•¨ê»˜ processStringList ë©”ì„œë“œë¥¼ í˜¸ì¶œí•œë‹¤ê³  ê°€ì •í•˜ì. Java SE 7ì—ì„œëŠ” ì•„ë˜ì˜ ì½”ë“œëŠ” ì»´íŒŒì¼ ë˜ì§€ ì•ŠëŠ”ë‹¤.
&lt;code&gt;Suppose you want to invoke the method processStringList with an empty list. In Java SE 7, the following statement does not compile:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;processStringList(Collections.emptyList());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java SE 7 ì»´íŒŒì¼ëŸ¬ëŠ” ì•„ë˜ì˜ ì—ëŸ¬ë©”ì„¸ì§€ë¥¼ ë˜ì§„ë‹¤.
&lt;code&gt;The Java SE 7 compiler generates an error message similar to the following:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shelll&#34;&gt;List&amp;lt;Object&amp;gt; cannot be converted to List&amp;lt;String&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì»´íŒŒì¼ëŸ¬ëŠ” Tì˜ íƒ€ì…ì¸ìê°€ í•„ìš”í•œë° TëŠ” target typeì„ ì£¼ì§€ ì•Šìœ¼ë©´ Objectì´ë‹¤. ê²°êµ­, Collection.emptyListì— íƒ€ì…ì¸ìëŠ” List&lt;Objec&gt; íƒ€ì…ì´ë‹¤. ê·¸ëŸ¬ë¯€ë¡œ Java SE 7ì€ ë°˜ë“œì‹œ ì•„ë˜ì˜ ì˜ˆì²˜ëŸ¼ íƒ€ì…ì¸ìë¥¼ ëª…í™•íˆ ì•Œë ¤ì¤˜ì•¼í•œë‹¤.
&lt;code&gt;The compiler requires a value for the type argument T so it starts with the value Object. Consequently, the invocation of Collections.emptyList returns a value of type List&amp;lt;Object&amp;gt;, which is incompatible with the method processStringList. Thus, in Java SE 7, you must specify the value of the value of the type argument as follows:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;processStringList(Collections.&amp;lt;String&amp;gt;emptyList());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java SE 8ì—ì„œëŠ” ë”ì´ìƒ í•„ìš”ì¹˜ ì•Šë‹¤. ì´ í‘œê¸°ë²•ì€ target typeì€ ë©”ì„œë“œ ì¸ìë¥¼ í¬í•¨í•´ì„œ í™•ì¥í–ˆë‹¤ (ì•„ë˜ ì˜ˆì²˜ëŸ¼ processStringList ë©”ì„œë“œì— ì¸ìë¥¼ ë„£ëŠ”ê²ƒì²˜ëŸ¼). ì´ëŸ°ê²½ìš°, processStringListëŠ” List&lt;String&gt; íƒ€ì…ì˜ ì¸ìë¥¼ í•„ìš”ë¡œí•œë‹¤. Collections.emptyList ë©”ì„œë“œëŠ” List&lt;T&gt; íƒ€ì…ì˜ ê°’ì„ ë¦¬í„´í•œë‹¤. ê·¸ëŸ¼ List&lt;String&gt;ì˜ target typeì„ ì‚¬ìš©í•˜ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” Tì˜ íƒ€ì…ì¸ìë¥¼ Stringìœ¼ë¡œ ì¶”ë¡ í•˜ë‹¤. ë”°ë¼ì„œ Java SE 8ì€ ì•„ë˜ì˜ ë¬¸ì¥ì´ ì»´íŒŒì¼ëœë‹¤.
&lt;code&gt;This is no longer necessary in Java SE 8. The notion of what is a target type has been expanded to include method arguments, such as the argument to the method processStringList. In this case, processStringList requires an argument of type List&amp;lt;String&amp;gt;. The method Collections.emptyList returns a value of List&amp;lt;T&amp;gt;, so using the target type of List&amp;lt;String&amp;gt;, the compiler infers that the type argument T has a value of String. Thus, in Java SE 8, the following statement compiles:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;processStringList(Collections.emptyList());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë” ë§ì€ ì •ë³´ëŠ” &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&#34;&gt;ëŒë‹¤í‘œí˜„ì‹&lt;/a&gt;ì—ì„œ &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#target-typing&#34;&gt;Target Typing&lt;/a&gt;ì„ ë³´ì„¸ìš”.
&lt;code&gt;See Target Typing in Lambda Expressions for more information.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(8) Java Generics: ì œë„¤ë¦­ìŠ¤, ìƒì†, ì„œë¸Œíƒ€ì… (Generics, Inheritance, and Subtypes)</title>
      <link>http://durtchrt.github.io/blog/java/generics/8/</link>
      <pubDate>Sat, 05 Nov 2016 08:48:42 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/8/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/inheritance.html&#34;&gt;ì›ë¬¸ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ìš©ì–´
ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜(method signature): ë©”ì„œë“¤ê°„ì— ê°œì„± ì£¼ëŠ”ê²ƒìœ¼ë¡œ ìë°” ì»´íŒŒì¼ëŸ¬ì¸ì§€ ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë²„ë¡œë”©ì„ í•œë‹¤.  ìë°”ì—ì„œëŠ” ë©”ì„œë“œëª…, íŒŒë¼ë¯¸í„° ê°¯ìˆ˜, íŒŒë¼ë¯¸í„° íƒ€ì…, íŒŒë¼ë¯¸í„° ìˆœì„œ(ìë°”ì—ì„œëŠ” ë¦¬í„´íƒ€ì…ì€ ì‹œê·¸ë‹ˆì²˜ê°€ ì•„ë‹ˆë‹¤.) - íŒŒë¼ë¯¸í„°ëª…ë„ ì‹œê·¸ë‹ˆì²˜ì¸ì§€ëŠ” ì•„ë¦¬ê¹Œë¦¬í•˜ë‹¤. ë©”ì„œë“œ ì˜¤ë²„ë¡œë”©ë¥¼ ìƒê°í•˜ë©´ ë§ëŠ”ê±° ê°™ì€ë°&amp;hellip; ì¢€ë” ìƒê°í•´ë³´ê³  ë‚´ìš© ìˆ˜ì • ì˜ˆì •
ì½˜í¬ë¦¬íŠ¸ íƒ€ì…, êµ¬í˜„íƒ€ì…(concrete type): ìë°”ì—ì„œëŠ” íƒ€ì…ë“¤ì¤‘ interface, abstract classë¥¼ ì œì™¸í•˜ê³  ë‚¨ì€ classë¥¼ concrete íƒ€ì…ìœ¼ë¡œ ì´í•´í•˜ë©´ ë  ë“¯.&lt;a href=&#34;http://dreuarchive.cra.org/2002/heise/typeComp.html&#34;&gt;ì°¸ê³ ë§í¬ - ì˜ë¬¸: ë²ˆì—­ ì˜ˆì •&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì œë„¤ë¦­ìŠ¤-ìƒì†-ì„œë¸Œíƒ€ì…-generics-inheritance-and-subtypes&#34;&gt;ì œë„¤ë¦­ìŠ¤, ìƒì†, ì„œë¸Œíƒ€ì… &lt;code&gt;Generics, Inheritance, and Subtypes&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;íƒ€ì…ê°„ í˜¸í™˜ì´ëœë‹¤ë©´ íŠ¹ì • íƒ€ì…ì˜ ê°ì²´ë¥¼ ë‹¤ë¥¸ íƒ€ì…ì— í• ë‹¹ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. ì•„ë˜ì˜ ì½”ë“œì²˜ëŸ¼ Object íƒ€ì…ì€ Integerì˜ ìŠˆí¼íƒ€ì…ì¤‘ í•˜ë‚˜ì´ê¸° ë•Œë¬¸ì— Integer íƒ€ì…ì¸ someIntegerì˜ ê°ì²´ê°€ Object íƒ€ì…ì¸ someObjectì— í• ë‹¹ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.
&lt;code&gt;As you already know, it is possible to assign an object of one type to an object of another type provided that the types are compatible. For example, you can assign an Integer to an Object, since Object is one of Integer&#39;s supertypes:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object someObject = new Object();
Integer someInteger = new Integer(10);
someObject = someInteger;   // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê°ì²´ì§€í–¥ ì´ë¡ ì—ì„œëŠ” ì´ë¥¼ &amp;ldquo;is a&amp;rdquo;(~ëŠ” ~ì´ë‹¤) ê´€ê³„ë¼ê³  ë¶€ë¥¸ë‹¤. IntegerëŠ” Objectì˜ &amp;ldquo;is a&amp;rdquo;ì´ë¯€ë¡œ Integer íƒ€ì…ì„ Object íƒ€ì…ì— í• ë‹¹ì´ ê°€ëŠ¥í•˜ë‹¤. í•˜ì§€ë§Œ IntegerëŠ” Number íƒ€ì…ì— &amp;ldquo;is a&amp;rdquo; ê´€ê³„ì´ë‹¤. ê·¸ëŸ¬ë¯€ë¡œ ì•„ë˜ì˜ ì½”ë“œëŠ” ì˜ ë™ì‘í•œë‹¤.
&lt;code&gt;In object-oriented terminology, this is called an &amp;quot;is a&amp;quot; relationship. Since an Integer is a kind of Object, the assignment is allowed. But Integer is also a kind of Number, so the following code is valid as well:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void someMethod(Number n) { /* ... */ }

someMethod(new Integer(10));   // OK
someMethod(new Double(10.1));   // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ë£°ì€ genericsë„ ë§ˆì°¬ê°€ì§€ë‹¤. generic íƒ€ì…ì„ í˜¸ì¶œí• ë•Œ, íƒ€ì…ì¸ìê°€ Number íƒ€ì…ê³¼ í˜¸í™˜ë˜ëŠ” &amp;ldquo;is a&amp;rdquo; ê´€ê³„ë¼ë©´ Number íƒ€ì…ìœ¼ë¡œ íƒ€ì…ì¸ìë¥¼ ì „ë‹¬í•œë‹¤.
&lt;code&gt;The same is also true with generics. You can perform a generic type invocation, passing Number as its type argument, and any subsequent invocation of add will be allowed if the argument is compatible with Number:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Number&amp;gt; box = new Box&amp;lt;Number&amp;gt;();
box.add(new Integer(10));   // OK
box.add(new Double(10.1));  // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì•„ë˜ì˜ ë©”ì„œë“œë¥¼ ì‚´í´ë³´ì
&lt;code&gt;Now consider the following method:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void boxTest(Box&amp;lt;Number&amp;gt; n) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì–´ë–¤ íƒ€ì…ì„ ì¸ìë¡œ ë°›ì„ìˆ˜ ìˆì„ê¹Œ? ë©”ì„œë“œì˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ë³´ë©´, Box&lt;Number&gt; íƒ€ì…ì˜ ê°ì²´ í•˜ë‚˜ë¥¼ ì¸ìë¡œ ë°›ëŠ” ë©”ì„œë“œì´ë‹¤. ê·¸ëŸ¼, Box&amp;lt;Integer&amp;gt;ë‚˜ Box&amp;lt;Double&amp;gt;ì„ ì¸ìë¡œ ë„£ì„ìˆ˜ ìˆì„ê¹Œ? ì•„ë‹ˆë‹¤! ì™œëƒí•˜ë©´ Box&amp;lt;Integer&amp;gt;, Box&amp;lt;Double&amp;gt;ëŠ” Box&amp;lt;Number&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ì´ ì•„ë‹ˆê¸° ë•Œë¬¸ì´ë‹¤. (ìë°”ì—ì„œëŠ” êº½ì‡ ì•ˆì— Number íƒ€ì…ì€ ì»´íŒŒì¼ëŸ¬ê°€ is aê´€ê³„ë¥¼ íŒŒì•…í•˜ì§€ ëª»í•œë‹¤. - ê³µë³€ì„±, ë°˜ê³µë³€ì„±ìª½ ë‚´ìš© ì°¸ì¡°í•˜ë©´ ì¢‹ì€ë° ìë°”ëŠ” ì´ë¥¼ ì§€ì› ëª»í•¨. ìŠ¤ì¹¼ë¼ ì–¸ì–´ ì°¸ì¡°. ëˆˆì´ ê³µë¶€í•˜ë‹¤ë³´ë©´ íŒ½íŒ½ ë”.)
&lt;code&gt;What type of argument does it accept? By looking at its signature, you can see that it accepts a single argument whose type is Box&amp;lt;Number&amp;gt;. But what does that mean? Are you allowed to pass in Box&amp;lt;Integer&amp;gt; or Box&amp;lt;Double&amp;gt;, as you might expect? The answer is &amp;quot;no&amp;quot;, because Box&amp;lt;Integer&amp;gt; and Box&amp;lt;Double&amp;gt; are not subtypes of Box&amp;lt;Number&amp;gt;.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì´ê²ƒì€ genericsë¥¼ ê³µë¶€í• ë•Œ í”íˆ ê²ªëŠ” ë¬¸ì œì´ë‹¤. í•˜ì§€ë§Œ genericì„ ê³µë¶€í• ë•Œ ì¤‘ìš”í•œ ì»¨ì…‰ì´ë‹¤.
&lt;code&gt;This is a common misunderstanding when it comes to programming with generics, but it is an important concept to learn.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../8-1.gif&#34; alt=&#34;Box&amp;lt;Integer&amp;gt; is not a subtype of Box&amp;lt;Number&amp;gt; even though Integer is a subtype of Number.&#34; /&gt;
&lt;br&gt;
Numberì˜ ì„œë¸Œíƒ€ì…ì¸ Integerë¥¼ ê°€ì§„ Box&amp;lt;Integer&amp;gt;ëŠ” Box&amp;lt;Number&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ì´ ì•„ë‹ˆë‹¤.
&lt;code&gt;Box&amp;lt;Integer&amp;gt; is not a subtype of Box&amp;lt;Number&amp;gt; even though Integer is a subtype of Number.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì¤‘ìš”:  Aì™€ B ë‘ êµ¬í˜„íƒ€ì…ì„ ì œê³µí• ë•Œ(ì˜ˆë¥¼ ë“¤ì–´ Numberì™€ Integer),Aì™€ Bê°€ &amp;ldquo;is a&amp;rdquo; ê´€ê³„ê°€ ìˆë“  ìƒê´€ì—†ì´  MyClass&amp;lt;A&amp;gt;ëŠ” MyClass&amp;lt;B&amp;gt;ì™€ ë” ì´ìƒ ê´€ê³„ê°€ í˜•ì„±ë˜ì§€ ì•ŠëŠ”ë‹¤.
&lt;code&gt;Note: Given two concrete types A and B (for example, Number and Integer), MyClass&amp;lt;A&amp;gt; has no relationship to MyClass&amp;lt;B&amp;gt;, regardless of whether or not A and B are related. The common parent of MyClass&amp;lt;A&amp;gt; and MyClass&amp;lt;B&amp;gt; is Object.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ë‘ generic í´ë˜ìŠ¤ë“¤ê°„ì— ì„œë¸Œíƒ€ì…&lt;strong&gt;ì²˜ëŸ¼&lt;/strong&gt; íƒ€ì…ë§¤ê°œë³€ìˆ˜ê°€ ê´€ë ¨ìˆë‹¤ë¼ëŠ” ì •ë³´ë¥¼ ì£¼ë ¤ë©´(ì»´íŒŒì¼ëŸ¬ì—ê²Œ), ì™€ì¼ë“œì¹´ë“œì™€ ì„œë¸Œíƒ€ì´í•‘ í•­ëª©ì„ ë³´ë¼
&lt;code&gt;For information on how to create a subtype-like relationship between two generic classes when the type parameters are related, see Wildcards and Subtyping.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì œë„¤ë¦­-í´ë˜ìŠ¤ì™€-ì„œë¸Œíƒ€ì´í•‘-generic-classes-and-subtyping&#34;&gt;ì œë„¤ë¦­ í´ë˜ìŠ¤ì™€ ì„œë¸Œíƒ€ì´í•‘ &lt;code&gt;Generic Classes and Subtyping&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic í´ë˜ìŠ¤ ìƒì† ë˜ëŠ” generic ì¸í„°í˜ì´ìŠ¤ ë§Œë“¤ ë•Œ, ë§Œë“œëŠ” íƒ€ì…ì„ ìƒì†(ë˜ëŠ” êµ¬í˜„) ë°›ì€ ë¶€ëª¨  generic íƒ€ì…ì˜ ì„œë¸Œ generic íƒ€ì…(ìì‹íƒ€ì…)ìœ¼ë¡œ ë‘ íƒ€ì…ê°„ì— ê´€ê³„(is a)ë¥¼ ë§Œë“¤ìˆ˜ ìˆë‹¤.
&lt;code&gt;You can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the extends and implements clauses.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Collections í´ë˜ìŠ¤ë“¤ ì‚¬ìš©í•  ë•Œ ì˜ˆë¥¼ ë“¤ë©´,  ArrayList&amp;lt;E&amp;gt;ëŠ” List&amp;lt;E&amp;gt;ë¥¼ êµ¬í˜„í–ˆê³  List&amp;lt;E&amp;gt;ëŠ” Collectionì„ ìƒì†í–ˆë‹¤. ê·¸ëŸ¬ë¯€ë¡œ ArrayList&amp;lt;String&amp;gt;ì€ List&amp;lt;String&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ì´ê³  List&amp;lt;String&amp;gt;ì€ Collection&amp;lt;String&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ë‹ˆë‹¤. ê·¸ëŸ¼ &amp;lt;String&amp;gt;ì´ë¼ëŠ” í˜•ì‹ì¸ìë¥¼ ë³€ê²½í•˜ì§€ ì•Šìœ¼ë©´ íƒ€ì…ê°„ ì„œë¸Œíƒ€ì´í•‘ ê´€ê³„ê°€ ìœ ì§€ëœë‹¤.
&lt;code&gt;Using the Collections classes as an example, ArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, and List&amp;lt;E&amp;gt; extends Collection&amp;lt;E&amp;gt;. So ArrayList&amp;lt;String&amp;gt; is a subtype of List&amp;lt;String&amp;gt;, which is a subtype of Collection&amp;lt;String&amp;gt;. So long as you do not vary the type argument, the subtyping relationship is preserved between the types.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../8-2.gif&#34; alt=&#34;A sample Collections hierarchy&#34; /&gt;
&lt;br&gt;
ì½œë ‰ì…˜ë“¤ê°„ì˜ ê³„ì¸µêµ¬ì¡° ì˜ˆ&lt;code&gt;sample Collections hierarchy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;PayloadListë¼ëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•  ë•Œ Pë¼ëŠ” generic íƒ€ì…ì„ ë©”ì„œë“œì˜ íŒŒë¼ë©”í„°ë¡œ ì‚¬ìš©í•œë‹¤ê³ í–ˆì„ë•Œ, ì•„ë˜ ì½”ë“œì™€ ê°™ì„ ê²ƒì´ë‹¤.
&lt;code&gt;Now imagine we want to define our own list interface, PayloadList, that associates an optional value of generic type P with each element. Its declaration might look like:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface PayloadList&amp;lt;E,P&amp;gt; extends List&amp;lt;E&amp;gt; {
  void setPayload(int index, P val);
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;List&amp;lt;String&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ì´ë©´ì„œ PayloadListê°€ íƒ€ì…ì¸ìë¡œ ì „ë‹¬í• ìˆ˜ ìˆëŠ” ê²ƒì€ ì•„ë˜ì²˜ëŸ¼ ë‹¤ì–‘í•˜ê²Œ ë³¼ìˆ˜ ìˆë‹¤.(ì¼ë¶€ì„.)
&lt;code&gt;The following parameterizations of PayloadList are subtypes of List&amp;lt;String&amp;gt;:&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PayloadList&lt;String,String&gt;&lt;/li&gt;
&lt;li&gt;PayloadList&lt;String,Integer&gt;&lt;/li&gt;
&lt;li&gt;PayloadList&lt;String,Exception&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../8-3.gif&#34; alt=&#34;A sample PayloadList hierarchy&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(7) Java Generics: Generic ë©”ì„œë“œì™€ ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ (Generic Methods and Bounded Type Parameters)</title>
      <link>http://durtchrt.github.io/blog/java/generics/7/</link>
      <pubDate>Sat, 05 Nov 2016 08:24:47 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/7/</guid>
      <description>

&lt;h3 id=&#34;generic-ë©”ì„œë“œì™€-ì œí•œëœ-íƒ€ì…-ë§¤ê°œë³€ìˆ˜-generic-methods-and-bounded-type-parameters&#34;&gt;Generic ë©”ì„œë“œì™€ ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ &lt;code&gt;Generic Methods and Bounded Type Parameters&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” generic ì•Œê³ ë¦¬ì¦˜ë“¤ì„ êµ¬í˜„í• ë•Œ í•µì‹¬ì´ëœë‹¤. ì•„ë˜ì˜ ì˜ˆëŠ” ë‘ë²ˆì§¸ ì¸ìë³´ë‹¤ í° ê°’ì´ ì²«ë²ˆì§¸ ì¸ìì¸ ë°°ì—´ì— ëª‡ê°œê°€ ìˆëŠ”ì§€ ì„¸ëŠ” ë©”ì„œë“œì´ë‹¤.
&lt;code&gt;Bounded type parameters are key to the implementation of generic algorithms. Consider the following method that counts the number of elements in an array T[] that are greater than a specified element elem.&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T&amp;gt; int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e &amp;gt; elem)  // compiler error
            ++count;
    return count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë©”ì„œë“œ êµ¬í˜„ì€ ê°„ë‹¨í•˜ì§€ë§Œ, &amp;lsquo;&amp;gt;&amp;rsquo; ì—°ì‚°ìê°€ ê¸°ë³¸í˜•(short, int, double, long, float, byte, char)ì—ë§Œ ë™ì‘ì´ í—ˆìš©ë˜ê¸° ë•Œë¬¸ì´ë‹¤. &amp;lsquo;&amp;gt;&amp;rsquo; ì—°ì‚°ìëŠ” ê°ì²´ê°„ ë¹„êµì—ëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¹„êµì—°ì‚°ì ëŒ€ì‹  Comparable&lt;T&gt;  ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•´ì„œ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
&lt;code&gt;The implementation of the method is straightforward, but it does not compile because the greater than operator (&amp;gt;) applies only to primitive types such as short, int, double, long, float, byte, and char. You cannot use the &amp;gt; operator to compare objects. To fix the problem, use a type parameter bounded by the Comparable&amp;lt;T&amp;gt; interface:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Comparable&amp;lt;T&amp;gt; {
    public int compareTo(T o);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comparable ì¸í„°í˜ì´ìŠ¤ê°€ ì ìš©ëœ ê²°ê³¼ ì½”ë“œëŠ” ì•„ë˜ì˜ ì½”ë“œì²˜ëŸ¼ ë  ê²ƒì…ë‹ˆë‹¤. &lt;code&gt;The resulting code will be:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e.compareTo(elem) &amp;gt; 0)
            ++count;
    return count;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(6) Java Generics: ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ (Bounded Type Parameters)</title>
      <link>http://durtchrt.github.io/blog/java/generics/6/</link>
      <pubDate>Fri, 04 Nov 2016 18:03:27 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/6/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/bounded.html&#34;&gt;ì›ë¬¸ ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì œí•œëœ-íƒ€ì…-ë§¤ê°œë³€ìˆ˜-bounded-type-parameters&#34;&gt;ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ &lt;code&gt;Bounded Type Parameters&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ë§¤ê°œë³€ìˆ˜í™”ëœ íƒ€ì…ì— íƒ€ì…ì¸ìë¥¼ ë„£ì„ë•Œ íƒ€ì… ì œí•œì„ ê±¸ê³  ì‹¶ì„ ë•Œê°€ ìˆì„ ê²ƒì´ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, Number íƒ€ì… ë˜ëŠ” Number íƒ€ì…ì˜ ìì‹ í´ë˜ìŠ¤ì˜ ê°ì²´ë§Œ í—ˆìš©í•˜ëŠ” ìˆ«ì ì²˜ë¦¬ë¥¼ ìœ„í•œ ë©”ì„œë“œë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤. ì´ê²ƒì´ ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ë‹¤
&lt;code&gt;There may be times when you want to restrict the types that can be used as type arguments in a parameterized type. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. This is what bounded type parameters are for.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì œí•œëœ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ëŠ” ë°©ë²•ì€, íƒ€ì…ë§¤ê°œë³€ìˆ˜ì˜ ì´ë¦„ ë’¤ì—  extends í‚¤ì›Œë“œë¥¼ ë†“ê³  ì œí•œì‹œí‚¬ íƒ€ì…ì„ ì‘ì„±í•˜ë©´ ëœë‹¤. ì•„ë˜ì˜ ì—ì—ì„œëŠ” Number íƒ€ì…ìœ¼ë¡œ í•˜ì˜€ë‹¤. ì£¼ì˜í• ì ì€, ì—¬ê¸°ì„œ ì‚¬ìš©í•œ extendsëŠ” í´ë˜ìŠ¤ì•ˆì˜ &amp;ldquo;extends&amp;rdquo; ë˜ëŠ” ì¸í„°í˜ì´ìŠ¤ì˜ &amp;ldquo;implements&amp;rdquo; ì²˜ëŸ¼ êµ¬í˜„í•œë‹¤ëŠ” ì˜ë¯¸ëŠ” ì•„ë‹ˆë‹¤.
&lt;code&gt;To declare a bounded type parameter, list the type parameter&#39;s name, followed by the extends keyword, followed by its upper bound, which in this example is Number. Note that, in this context, extends is used in a general sense to mean either &amp;quot;extends&amp;quot; (as in classes) or &amp;quot;implements&amp;quot; (as in interfaces).&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Box&amp;lt;T&amp;gt; {

    private T t;

    public void set(T t) {
        this.t = t;
    }

    public T get() {
        return t;
    }

    public &amp;lt;U extends Number&amp;gt; void inspect(U u){
        System.out.println(&amp;quot;T: &amp;quot; + t.getClass().getName());
        System.out.println(&amp;quot;U: &amp;quot; + u.getClass().getName());
    }

    public static void main(String[] args) {
        Box&amp;lt;Integer&amp;gt; integerBox = new Box&amp;lt;Integer&amp;gt;();
        integerBox.set(new Integer(10));
        integerBox.inspect(&amp;quot;some text&amp;quot;); // error: this is still String!
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generic Box í´ë˜ìŠ¤ëŠ” ì œí•œëœ íƒ€ì… íŒŒë¼ë©”í„°ë¥¼ ê°€ì§„ ë©”ì„œë“œì¸ inspectë¥¼ í¬í•¨í•˜ë„ë¡ ê¸°ì¡´ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì˜€ë‹¤. inspect ë©”ì„œë“œ í˜¸ì¶œì‹œì— String íƒ€ì…ì„ ì¸ìë¡œ ë°›ì•˜ê¸° ë•Œë¬¸ì— ì»´íŒŒì¼ì´ ì‹¤íŒ¨í•  ê²ƒì´ë‹¤.
&lt;code&gt;By modifying our generic method to include this bounded type parameter, compilation will now fail, since our invocation of inspect still includes a String:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Box.java:21: &amp;lt;U&amp;gt;inspect(U) in Box&amp;lt;java.lang.Integer&amp;gt; cannot
  be applied to (java.lang.String)
                        integerBox.inspect(&amp;quot;10&amp;quot;);
                                  ^
1 error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê²°ë¡ ì€ generic íƒ€ì…ì„ ê°ì²´ë¡œ ë§Œë“¤ë•Œ ì œí•œì„ ê±¸ìˆ˜ ìˆë‹¤. ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” ì •ì˜ëœ ì œí•œëœ ë²”ìœ„ ë‚´ì—ì„œ ë©”ì„œë“œë¥¼ í˜¸ì¶œ í•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;In addition to limiting the types you can use to instantiate a generic type, bounded type parameters allow you to invoke methods defined in the bounds:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class NaturalNumber&amp;lt;T extends Integer&amp;gt; {

    private T n;

    public NaturalNumber(T n)  { this.n = n; }

    public boolean isEven() {
        return n.intValue() % 2 == 0;
    }

    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;isEven ë©”ì„œë“œëŠ” ë³€ìˆ˜ nì— íƒ€ì…ì¸ìë¡œ ì „ë‹¬ëœ Integer íƒ€ì…ì— ì •ì˜ëœ intValue ë©”ì„œë“œë¥¼ í˜¸ì¶œí•œë‹¤.
&lt;code&gt;The isEven method invokes the intValue method defined in the Integer class through n.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì—¬ëŸ¬ë²ˆ-ì œí•œí•˜ê¸°-multiple-bounds&#34;&gt;ì—¬ëŸ¬ë²ˆ ì œí•œí•˜ê¸° &lt;code&gt;Multiple Bounds&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ì´ì „ê¹Œì§€ ì˜ˆì œëŠ” í•˜ë‚˜ë§Œ ì œí•œí•œ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•œ ê²ƒë§Œ ì„¤ëª…í–ˆì§€ë§Œ, íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” ì—¬ëŸ¬ê°œë¥¼ ì œí•œí•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;The preceding example illustrates the use of a type parameter with a single bound, but a type parameter can have multiple bounds:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;T extends B1 &amp;amp; B2 &amp;amp; B3&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì—¬ëŸ¬ê°œì˜ ì œí•œë“¤ë¡œ êµ¬ì„±ëœ íƒ€ì…ë§¤ê°œë³€ìˆ˜ëŠ” ì œí•œí•˜ë ¤ ë‚˜ì—´í•œ ëª¨ë“  íƒ€ì…ë“¤ì˜ ì„œë¸Œíƒ€ì…ì´ë‹¤.(êµ³ì´ classë¼ê³  ì•ˆí•˜ê³  íƒ€ì…ì´ë€ ìš©ì–´ë¥¼ ì“°ëŠ”ê±´ interfaceë¥¼ í¬í•¨í•˜ëŠ” ë‹¨ì–´ê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì´ë‹¤. í´ë˜ìŠ¤ëŠ” íƒ€ì…ì˜ ë¶€ë¶„) ì œí•œëœ íƒ€ì…ì¤‘ í•˜ë‚˜ê°€ classë¼ë©´, classëŠ” ì—´ê±°ë˜ëŠ” íƒ€ì…ë“¤ì¤‘ ì²˜ìŒì— ì‘ì„±í•´ì•¼í•œë‹¤. ì˜ˆë¥¼ ë“¤ë©´:
&lt;code&gt;A type variable with multiple bounds is a subtype of all the types listed in the bound. If one of the bounds is a class, it must be specified first. For example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Class A { /* ... */ }
interface B { /* ... */ }
interface C { /* ... */ }

class D &amp;lt;T extends A &amp;amp; B &amp;amp; C&amp;gt; { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë§Œì•½ Aë¼ëŠ” ì œí•œ classê°€ ë‹¤ë¥¸ ì œí•œ í´ë˜ìŠ¤ë“¤ì¤‘ ì²˜ìŒì— ìœ„ì¹˜í•˜ì§€ ì•Šìœ¼ë©´, ì»´íŒŒì¼íƒ€ì„ ì—ëŸ¬ë¥¼ ë°œìƒëœë‹¤.
&lt;code&gt;If bound A is not specified first, you get a compile-time error:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class D &amp;lt;T extends B &amp;amp; A &amp;amp; C&amp;gt; { /* ... */ }  // compile-time error
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(5) Java Generics: ì œë„¤ë¦­ ë©”ì„œë“œ</title>
      <link>http://durtchrt.github.io/blog/java/generics/5/</link>
      <pubDate>Fri, 04 Nov 2016 13:43:44 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/5/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/methods.html&#34;&gt;ì›ë¬¸ ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;generic-ë©”ì„œë“œ-generic-methods&#34;&gt;Generic ë©”ì„œë“œ &lt;code&gt;Generic Methods&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Generic ë©”ì„œë“œëŠ” ìì‹œì˜ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ê°€ì§„ ë©”ì„œë“œì´ë‹¤. generic íƒ€ì…ì„ ì„ ì–¸í•˜ëŠ” ê²ƒê³¼ ë¹„ìŠ·í•˜ì§€ë§Œ íƒ€ì…ë§¤ê°œë³€ìˆ˜ì˜ ìŠ¤ì½”í”„ëŠ” ë©”ì„œë“œë¡œ ì œí•œëœë‹¤. ì¼ë°˜ ë©”ì„œë“œ, ì •ì  ë©”ì„œë“œ generic í´ë˜ìŠ¤ì˜ ìƒì„±ìëŠ” ì´ ë£°ì„ ë™ì¼í•˜ê²Œ ì ìš©ëœë‹¤.
&lt;code&gt;Generic methods are methods that introduce their own type parameters. This is similar to declaring a generic type, but the type parameter&#39;s scope is limited to the method where it is declared. Static and non-static generic methods are allowed, as well as generic class constructors.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;generic ë©”ì„œë“œ ë¬¸ë²•ì€ return íƒ€ì… ì „ì— êº½ì‡  ì‚¬ì´ì— íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ í‘œê¸°í•œë‹¤. static generic ë©”ì„œë“œë¥¼ ìœ„í•´ íƒ€ì…ë§¤ê°œë³€ìˆ˜ëŠ” ë°˜ë“œì‹œ ë©”ì„œë“œì˜ return íƒ€ì… ì´ì „ì— ìœ„ì¹˜í•´ì•¼í•œë‹¤.
&lt;code&gt;The syntax for a generic method includes a type parameter, inside angle brackets, and appears before the method&#39;s return type. For static generic methods, the type parameter section must appear before the method&#39;s return type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Util í´ë˜ìŠ¤ëŠ” ë‘ Pair ê°ì²´ë¥¼ ë¹„êµí•˜ëŠ” generic ë©”ì„œë“œë¥¼ í¬í•¨í•˜ê³  ìˆìŠµë‹ˆë‹¤.
&lt;code&gt;The Util class includes a generic method, compare, which compares two Pair objects:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Util {
    public static &amp;lt;K, V&amp;gt; boolean compare(Pair&amp;lt;K, V&amp;gt; p1, Pair&amp;lt;K, V&amp;gt; p2) {
        return p1.getKey().equals(p2.getKey()) &amp;amp;&amp;amp;
               p1.getValue().equals(p2.getValue());
    }
}

public class Pair&amp;lt;K, V&amp;gt; {

    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public void setKey(K key) { this.key = key; }
    public void setValue(V value) { this.value = value; }
    public K getKey()   { return key; }
    public V getValue() { return value; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì´ ë©”ì„œë“œë¥¼(static &lt;K, V&gt; boolean compare)ë¥¼ í˜¸ì¶œí•œ ë¬¸ì¥ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.
&lt;code&gt;The complete syntax for invoking this method would be:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Pair&amp;lt;Integer, String&amp;gt; p1 = new Pair&amp;lt;&amp;gt;(1, &amp;quot;apple&amp;quot;);
Pair&amp;lt;Integer, String&amp;gt; p2 = new Pair&amp;lt;&amp;gt;(2, &amp;quot;pear&amp;quot;);
boolean same = Util.&amp;lt;Integer, String&amp;gt;compare(p1, p2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Util.&lt;strong&gt;&amp;lt;Integer, String&amp;gt;&lt;/strong&gt;compare(p1, p2)&lt;br&gt;
ê°•ì¡°í•œ ì˜ì—­ì²˜ëŸ¼ íƒ€ì…ì„ ëª…ì‹œí•˜ì˜€ë‹¤. íƒ€ì…ì¸ìëŠ” ì»´íŒŒì¼ëŸ¬ê°€ íƒ€ì… ì¶”ë¡ í• ë•Œ í•„ìš”í•œ ì •ë³´ê°€ ëœë‹¤.
&lt;code&gt;The type has been explicitly provided, as shown in bold. Generally, this can be left out and the compiler will infer the type that is needed:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Pair&amp;lt;Integer, String&amp;gt; p1 = new Pair&amp;lt;&amp;gt;(1, &amp;quot;apple&amp;quot;);
Pair&amp;lt;Integer, String&amp;gt; p2 = new Pair&amp;lt;&amp;gt;(2, &amp;quot;pear&amp;quot;);
boolean same = Util.compare(p1, p2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ì½”ë“œëŠ” íƒ€ì… ì¶”ë¡ ì„ ë‚˜íƒ€ë‚¸ê²ƒì´ë‹¤. êº½ì‡ ì— íƒ€ì… ëª…ì‹œí•˜ì§€ ì•Šê³  generic ë©”ì„œë“œê°€ ì•„ë‹Œ ì¼ë°˜ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•´ë„ íƒ€ì… ì¶”ë¡ ì´ ì´ë£¨ì–´ì§„ë‹¤. ì´ ì£¼ì œëŠ” ë’¤ì— ë‚˜ì˜¤ëŠ” íƒ€ì… ì¶”ë¡  ì„¹ì…˜ì—ì„œ ë” ë…¼ì˜í•œë‹¤.
&lt;code&gt;This feature, known as type inference, allows you to invoke a generic method as an ordinary method, without specifying a type between angle brackets. This topic is further discussed in the following section, Type Inference.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(4) Java Generics: ì›ì²œ(Raw) íƒ€ì…ë“¤</title>
      <link>http://durtchrt.github.io/blog/java/generics/4/</link>
      <pubDate>Tue, 01 Nov 2016 16:05:56 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/4/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&#34;&gt;ì›ë¬¸ ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì›ì²œ-íƒ€ì…ë“¤-raw-types&#34;&gt;ì›ì²œ íƒ€ì…ë“¤ &lt;code&gt;Raw Types&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Raw íƒ€ì…ì€ generic í´ë˜ìŠ¤ í˜¹ì€ ì¸í„°í˜ì´ìŠ¤ì— íƒ€ì…ì¸ìê°€ ì—†ëŠ” ê²ƒ. ì˜ˆë¥¼ë“¤ì–´ generic Box í´ë˜ìŠ¤ë¥¼ ë³´ì
&lt;code&gt;A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Box&amp;lt;T&amp;gt; {
    public void set(T t) { /* ... */ }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì•„ë˜ ì½”ë“œë¥¼ ë³´ë©´ Box&lt;T&gt;ì˜ ë§¤ê°œë³€ìˆ˜í™”ëœ íƒ€ì…ì„ ë§Œë“œë©´ì„œ, íƒ€ì…ë§¤ê°œë³€ìˆ˜ Tì— í•´ë‹¹í•˜ëŠ” Integerë¥¼ íƒ€ì…ì¸ìë¡œ ì œê³µí•˜ì˜€ë‹¤.
&lt;code&gt;To create a parameterized type of Box&amp;lt;T&amp;gt;, you supply an actual type argument for the formal type parameter T:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Integer&amp;gt; intBox = new Box&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;íƒ€ì…ì¸ìê°€ ìƒëµëœ ê²½ìš° Box&lt;T&gt;ì˜ Raw íƒ€ì…ì„ ë§Œë“¤ìˆ˜ ìˆë‹¤.
&lt;code&gt;If the actual type argument is omitted, you create a raw type of Box&amp;lt;T&amp;gt;:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box rawBox = new Box();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê²°êµ­, BoxëŠ” generic íƒ€ì… Box&lt;T&gt;ì˜ raw íƒ€ì…ì´ë‹¤. í•˜ì§€ë§Œ, generic í´ë˜ìŠ¤ ë˜ëŠ” ì¸í„°í˜ì´ìŠ¤ê°€ ì•„ë‹Œê²½ìš°ëŠ” raw íƒ€ì…ì´ ë  ìˆ˜ ì—†ë‹¤.()
&lt;code&gt;Therefore, Box is the raw type of the generic type Box&amp;lt;T&amp;gt;. However, a non-generic class or interface type is not a raw type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Raw íƒ€ì…ì€ JDK 5.0 ì´ì „ ìë°” API í´ë˜ìŠ¤ë“¤ì€ ì œë„¤ë¦­ì„ ì§€ì›í•˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì—(ì˜ˆë¥¼ ë“¤ì–´ Collections í´ë˜ìŠ¤) ë ˆê±°ì‹œ ì½”ë“œì—ì„œ ë‚˜íƒ€ë‚œë‹¤. raw íƒ€ì…ì„ ì‚¬ìš©í•  ë•ŒëŠ” ë°˜ë“œì‹œ generics ì´ì „ ë°©ë²•(íƒ€ì… ìºìŠ¤íŒ…)ì„ í•˜ì‹œì˜¤. í•˜ìœ„í˜¸í™˜ì„±ì„ ìœ„í•´, íƒ€ì…ë§¤ê°œë³€ìˆ˜ëŠ” rawíƒ€ì…ì„ í—ˆìš©í•˜ì˜€ë‹¤.
&lt;code&gt;Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior â€” a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;String&amp;gt; stringBox = new Box&amp;lt;&amp;gt;();
Box rawBox = stringBox;               // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;í•˜ì§€ë§Œ íƒ€ì…ë§¤ê°œë³€ìˆ˜ì— raw íƒ€ì…ì„ í• ë‹¹í•˜ë©´ (ì»´íŒŒì¼ëŸ¬ë¡œë¶€í„°) ê²½ê³ ë¥¼ ë°›ìŠµë‹ˆë‹¤.
&lt;code&gt;But if you assign a raw type to a parameterized type, you get a warning:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box rawBox = new Box();           // rawBox is a raw type of Box&amp;lt;T&amp;gt;
Box&amp;lt;Integer&amp;gt; intBox = rawBox;     // warning: unchecked conversion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë˜í•œ generic íƒ€ì…ì— ì •ì˜ëœ generic ë©”ì„œë“œë¥¼ í˜¸ì¶œí• ë•Œì—ë„ raw íƒ€ì…ì„ ì‚¬ìš©í•˜ë©´ ê²½ê³ ë¥¼ ë°›ìŠµë‹ˆë‹¤.
&lt;code&gt;You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;String&amp;gt; stringBox = new Box&amp;lt;&amp;gt;();
Box rawBox = stringBox;
rawBox.set(8);  // warning: unchecked invocation to set(T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê²½ê³ ëŠ” raw íƒ€ì…ë“¤ì´ generic íƒ€ì…ì²´í¬ë¥¼ í• ìˆ˜ ì—†ë‹¤ëŠ” ê²ƒì„ ë³´ì—¬ì¤ë‹ˆë‹¤. (ì»´íŒŒì¼ íƒ€ì„ì— ì²´í¬ë  ìˆ˜ ìˆëŠ”) ë¶ˆì•ˆí•œ ì½”ë“œê°€ ëŸ°íƒ€ì„ì— ë¶™ì¡íˆê²Œ (ì»´íŒŒì¼ íƒ€ì„ ì²´í‚¹ì„ ëŸ°íƒ€ì„ìœ¼ë¡œ) ë”œë ˆì´ ì‹œí‚¤ëŠ” ê²ƒì´ë¯€ë¡œ raw íƒ€ì… ì‚¬ìš©ì€ í”¼í•˜ëŠ”ê²ƒì´ ì¢‹ì„ ê²ƒì´ë‹¤.&lt;br /&gt;
&lt;code&gt;The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;íƒ€ì…ì†Œê±° ì„¹ì…˜ì—ì„œëŠ” ìë°” ì»´íŒŒì¼ëŸ¬ê°€ raw íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì— ëŒ€í•œ ë” ìì„¸í•œ ì„¤ëª…ì´ ìˆë‹¤.
&lt;code&gt;The Type Erasure section has more information on how the Java compiler uses raw types.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;unchecked-error-messages&#34;&gt;Unchecked Error Messages&lt;/h3&gt;

&lt;p&gt;ì´ì „ì— ë§í–‡ë“¯, generic ì½”ë“œì™€ ë ˆê±°ì‹œ ì½”ë“œë¥¼ ì„ê²Œ ë˜ë©´, ì•„ë˜ì™€ ê°™ì€ ê²½ê³  ë©”ì„¸ì§€ë¥¼ ë§ˆì£¼ì¹  ê²ƒì´ë‹¤.
&lt;code&gt;As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Note: Example.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;This can happen when using an older API that operates on raw types, as shown in the following example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WarningDemo {
    public static void main(String[] args){
        Box&amp;lt;Integer&amp;gt; bi;
        bi = createBox();
    }

    static Box createBox(){
        return new Box();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;unchecked(ì²´í¬ë˜ì§€ ì•ŠìŒ)&amp;ldquo;ëŠ” íƒ€ì… ì•ˆì •ì„±ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ í•„ìš”í•œ íƒ€ì…ì²´í¬ ì •ë³´ê°€ ì¶©ë¶„ì¹˜ ì•Šë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤. &amp;ldquo;unchecked&amp;rdquo; ê²½ê³ ëŠ” ì»´íŒŒì¼ëŸ¬ì—ê²Œ ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤.&amp;ldquo;unchecked&amp;rdquo; ê²½ê³ ë¥¼ ë³´ê³  ì‹¶ë‹¤ë©´ -Xlint:uncheckedì˜µì…˜ì„ ì£¼ê³  ë‹¤ì‹œ ì»´íŒŒì¼í•˜ë©´ ëª¨ë“  &amp;ldquo;unchecked&amp;rdquo; ê²½ê³ ë¥¼ ë³¼ ìˆ˜ ìˆë‹¤.
&lt;code&gt;The term &amp;quot;unchecked&amp;quot; means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The &amp;quot;unchecked&amp;quot; warning is disabled, by default, though the compiler gives a hint. To see all &amp;quot;unchecked&amp;quot; warnings, recompile with -Xlint:unchecked.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;-Xlint:unchecked ì˜µì…˜ê³¼ í•¨ê»˜ ì˜ˆì œë¥¼ ë‹¤ì‹œ ì»´íŒŒì¼í•´ë³´ë©´ ì•„ë˜ì— ë³´ì´ëŠ” ë‚´ìš©ì´ ë‚˜íƒ€ë‚  ê²ƒì´ë‹¤.
&lt;code&gt;Recompiling the previous example with -Xlint:unchecked reveals the following additional information:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;WarningDemo.java:4: warning: [unchecked] unchecked conversion
found   : Box
required: Box&amp;lt;java.lang.Integer&amp;gt;
        bi = createBox();
                      ^
1 warning
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì»´íŒŒì¼ ì˜µì…˜ì— -Xlint:-unchecked í”Œë˜ê·¸ë¥¼ ì‚¬ìš©í•˜ë©´ unchecked ê²½ê³ ë¥¼ ì—†ì•¨ ìˆ˜ ìˆë‹¤. @SupporessWarnings(&amp;ldquo;unchecked&amp;rdquo;) ì–´ë…¸í…Œì´ì…˜ì€ unchecked ê²½ê³ ê°€ ë‚˜íƒ€ë‚˜ì§€ ì•Šê²Œ í•  ìˆ˜ ìˆë‹¤. @SupressWarnings ë¬¸ë²•ì´ ìƒì†Œí•˜ë©´ Annotations ì„¹ì…˜ì„ ë³´ì‹œì˜¤. &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/annotations/index.html&#34;&gt;ë§í¬&lt;/a&gt;
&lt;code&gt;To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The @SuppressWarnings(&amp;quot;unchecked&amp;quot;) annotation suppresses unchecked warnings. If you are unfamiliar with the @SuppressWarnings syntax, see Annotations.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ì—­ì ì²¨ë¶€&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ javac WarningDemo.java 

Note: WarningDemo.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
    
$ javac -Xlint:unchecked WarningDemo.java

WarningDemo.java:7: warning: [unchecked] unchecked conversion
        bi = createBox();
                      ^
required: Box&amp;lt;Integer&amp;gt;
found:    Box
1 warning
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(3) Java Generics: ì œë„¤ë¦­ íƒ€ì…ë“¤</title>
      <link>http://durtchrt.github.io/blog/java/generics/3/</link>
      <pubDate>Mon, 31 Oct 2016 17:08:57 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/3/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/types.html&#34;&gt;ì›ë¬¸ ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ìš©ì–´ ì°¸ì¡°&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;íƒ€ì… : ìë°”ì—ì„œëŠ” í´ë˜ìŠ¤, ì¶”ìƒí´ë˜ìŠ¤, ì¸í„°í˜ì´ìŠ¤, ì—´ê±°í˜•(Enum), ë°°ì—´ì„ ì˜ë¯¸. ê¸°ë³¸í˜•, ì°¸ì¡°í˜•ì„ í¬ê´„í•˜ëŠ” ê°œë…

&lt;ul&gt;
&lt;li&gt;ê¸°ë³¸í˜•: byte, short, int, long, float, double, char, String, boolean (call by value)&lt;/li&gt;
&lt;li&gt;ì°¸ì¡°í˜•: ê¸°ë³¸í˜•ì„ ì œì™¸í•œ ëª¨ë“  íƒ€ì… (call by reference)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ë§¤ê°œë³€ìˆ˜ vs ì¸ì&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ë§¤ê°œë³€ìˆ˜(Parameter): í•¨ìˆ˜ ì„ ì–¸í•  ë•Œ ë³€ìˆ˜ì˜ ì´ë¦„&lt;/li&gt;
&lt;li&gt;ì¸ì(Argument): í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ ì „ë‹¬í•˜ëŠ” ê°’&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;generic-types&#34;&gt;Generic Types&lt;/h3&gt;

&lt;p&gt;generic íƒ€ì…ì€ í´ë˜ìŠ¤, ì¸í„°í˜ì´ìŠ¤ë¥¼ íƒ€ì… íŒŒë¼ë¯¸í„°í™”í•˜ëŠ” ê²ƒì´ë‹¤. Box í´ë˜ìŠ¤ëŠ” generic  íƒ€ì…ì„ ì„¤ëª…í•˜ë©´ì„œ ì½”ë“œë¥¼ ìˆ˜ì •í•  ê²ƒì´ë‹¤.
&lt;code&gt;A generic type is a generic class or interface that is parameterized over types. The following Box class will be modified to demonstrate the concept.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-simple-box-class&#34;&gt;A Simple Box Class&lt;/h3&gt;

&lt;p&gt;genericì„ ì‚¬ìš©í•˜ì§€ ì•Šì€ ì˜ˆì œë¡œ ì‹œì‘í•´ë´…ì‹œë‹¤. Box í´ë˜ìŠ¤ëŠ” set(ì¶”ê°€), get(ì¡°íšŒ) 2ê°œì˜ ë©”ì„œë“œê°€ ìˆìŠµë‹ˆë‹¤.
&lt;code&gt;Begin by examining a non-generic Box class that operates on objects of any type. It needs only to provide two methods: set, which adds an object to the box, and get, which retrieves it:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Box {
    private Object object;

    public void set(Object object) { this.object = object; }
    public Object get() { return object; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê°ì²´ì˜ set, get ë©”ì„œë“œëŠ” ê¸°ë³¸í˜•ì„ ì œì™¸í•˜ë©´ ì–´ë–¤ íƒ€ì…(ì°¸ì¡°í˜•)ì´ë“  ì¸ìë¡œ ë„£ì„ìˆ˜ ìˆë‹¤. Box í´ë˜ìŠ¤ê°€ ì‚¬ìš©ë˜ì–´ì§€ì§€ë§Œ ì»´íŒŒì¼ íƒ€ì„ì— ê²€ì¦í•  ë°©ë²•ì´ ì—†ë‹¤. ì½”ë“œ ì¼ë¶€ë¶„ì—ì„œëŠ” Integerë¥¼ ë„£ê³  Integerê°€ returnë˜ì–´ì§€ê¸¸ ê¸°ëŒ€í•˜ì§€ë§Œ ë‹¤ë¥¸ ì¼ë¶€ë¶„ì—ì„œëŠ” ì‹¤ìˆ˜ë¡œ Stringì„ ì…ë ¥í•´ì„œ ëŸ°íƒ€ì„ ì—ëŸ¬ê°€ ë‚˜ì˜¬ ê²ƒì´ë‹¤.
&lt;code&gt;Since its methods accept or return an Object, you are free to pass in whatever you want, provided that it is not one of the primitive types. There is no way to verify, at compile time, how the class is used. One part of the code may place an Integer in the box and expect to get Integers out of it, while another part of the code may mistakenly pass in a String, resulting in a runtime error.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;generic-ë²„ì „ì˜-box-í´ë˜ìŠ¤-br&#34;&gt;Generic ë²„ì „ì˜ Box í´ë˜ìŠ¤.&lt;br&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;A Generic Version of the Box Class&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;generic í´ë˜ì‹œëŠ” ì•„ë˜ í¬ë©§ì²˜ëŸ¼ ì •ì˜ë˜ì—ˆë‹¤.&lt;br&gt;
&lt;code&gt;A generic class is defined with the following format:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class name&amp;lt;T1, T2, ..., Tn&amp;gt; { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;íƒ€ì… íŒŒë¼ë¯¸í„° ë¬¸ë²•ì€ í´ë˜ìŠ¤ëª… ë’¤ì— êº½ì‡ (&amp;lt;&amp;gt;) ê¸°í˜¸ë¡œ êµ¬ë¶„ëœë‹¤. ì´ê²ƒì€ T1, T2, &amp;hellip;, and Tn ë“±ìœ¼ë¡œ íƒ€ì… ë§¤ê°œë³€ìˆ˜ë¥¼ ëª…ì‹œí•œë‹¤.(íƒ€ì…ë³€ìˆ˜ë¼ê³  ë¶ˆë¦¬ê¸°ë„í•œë‹¤.)
&lt;code&gt;The type parameter section, delimited by angle brackets (&amp;lt;&amp;gt;), follows the class name. It specifies the type parameters (also called type variables) T1, T2, ..., and Tn.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Box í´ë˜ìŠ¤ë¥¼ genericsë¡œ ë³€ê²½í•´ë³´ì. &amp;ldquo;public class Box&amp;rdquo; ì½”ë“œë¥¼ &amp;ldquo;public class Box&lt;T&gt;&amp;ldquo;ë¡œ ë³€ê²½í•´ì„œ generic íƒ€ì…ì„ ì„ ì–¸í•˜ì—¬ ë§Œë“ ë‹¤. Të¼ëŠ” íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” í´ë˜ìŠ¤ ì–´ë””ë“ ì§€ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë³€ìˆ˜ì´ë‹¤.
&lt;code&gt;To update the Box class to use generics, you create a generic type declaration by changing the code &amp;quot;public class Box&amp;quot; to &amp;quot;public class Box&amp;lt;T&amp;gt;&amp;quot;. This introduces the type variable, T, that can be used anywhere inside the class.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Box í´ë˜ìŠ¤ê°€ ì´ë ‡ê²Œ ë°”ë€ë‹¤.&lt;br&gt;
&lt;code&gt;With this change, the Box class becomes:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Generic version of the Box class.
 * @param &amp;lt;T&amp;gt; the type of the value being boxed
 */
public class Box&amp;lt;T&amp;gt; {
    // T stands for &amp;quot;Type&amp;quot;
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì†ŒìŠ¤ ì½”ë“œ ë³€ê²½ì—ì„œ ë³´ì´ë“¯, ê¸°ì¡´ ì½”ë“œì—ì„œ Object ëŒ€ì‹  Të¡œ ìˆ˜ì •ë˜ì—ˆë‹¤. Type ë³€ìˆ˜ëŠ” ê¸°ë³¸í˜• ë¹¼ê³ ëŠ”(=ì°¸ì¡°í˜•)ì´ë©´ ëœë‹¤.(í´ë˜ìŠ¤/ì¸í„°í˜ì´ìŠ¤/ë°°ì—´ íƒ€ì… ë˜ëŠ” ë‹¤ë¥¸ Type ë³€ìˆ˜ê°€ Type ë³€ìˆ˜ë¡œ ë  ìˆ˜ ìˆë‹¤.)
&lt;code&gt;As you can see, all occurrences of Object are replaced by T. A type variable can be any non-primitive type you specify: any class type, any interface type, any array type, or even another type variable.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;generic ì¸í„°í˜ì´ìŠ¤ë¥¼ ë§Œë“œëŠ” ë°©ë²•ë„ ê°™ë‹¤.
&amp;lsquo;This same technique can be applied to create generic interfaces.&amp;rsquo;&lt;/p&gt;

&lt;h3 id=&#34;type-íŒŒë¼ë¯¸í„°-ë„¤ì´ë°-ê´€ìŠµ&#34;&gt;Type íŒŒë¼ë¯¸í„° ë„¤ì´ë° ê´€ìŠµ&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Type Parameter Naming Conventions&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ê´€ìŠµì— ì˜í•˜ë©´, Type íŒŒë¼ë¯¸í„°ëŠ” ë‹¨ì¼ ëŒ€ë¬¸ìì…ë‹ˆë‹¤. ì´ ê¸°ì¤€ì€ ì´ë¯¸ ì•Œê³  ìˆëŠ” ë³€ìˆ˜ ë„¤ì´ë° ê´€ìŠµì— ê·¹ëª…í•˜ê²Œ ë°˜ëŒ€ì…ë‹ˆë‹¤. (ì¢‹ì€ì ì€)ì´ëŸ° ê´€ìŠµì´ ì—†ìœ¼ë©´ Type ë³€ìˆ˜ì™€ ì¼ë°˜ì ì¸ í´ë˜ìŠ¤ í˜¹ì€ ì¸í„°í˜ì´ìŠ¤ëª… ì‚¬ì´ì— ì°¨ì´ë¥¼ ì „ë‹¬í•˜ê¸° ì–´ë ¤ìš¸ê²ë‹ˆë‹¤.
&lt;code&gt;By convention, type parameter names are single, uppercase letters. This stands in sharp contrast to the variable naming conventions that you already know about, and with good reason: Without this convention, it would be difficult to tell the difference between a type variable and an ordinary class or interface name.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ìš©ë˜ì–´ì§€ëŠ” TypeíŒŒë¼ë¯¸í„°ëª…&lt;br&gt;
&lt;code&gt;The most commonly used type parameter names are:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E - Element (ìë°” ì½œë ‰ì…˜ í”„ë ˆì¸ì›Œí¬ì— ê´‘ë²”ìœ„í•˜ê²Œ ì‚¬ìš©ë¨ - used extensively by the Java Collections Framework)
K - Key
N - Number
T - Type
V - Value
S,U,V etc. - 2nd, 3rd, 4th types
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì´ëŸ¬í•œ ì´ë¦„ë“¤ì´ ìë°”SE APIì„ í†µí•´ ì“°ì—¬ì§€ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆì„ ê²ƒì…ë‹ˆë‹¤.
&lt;code&gt;You&#39;ll see these names used throughout the Java SE API and the rest of this lesson.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;generic-type-í˜¸ì¶œê³¼-ê°ì²´-ìƒì„±&#34;&gt;Generic Type í˜¸ì¶œê³¼ ê°ì²´ ìƒì„±&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Invoking and Instantiating a Generic Type&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì½”ë“œë‚´ì— generic Box í´ë˜ìŠ¤ë¥¼ ì°¸ì¡°í•˜ë ¤ë©´, generic Typeì„ í˜¸ì¶œí•´ Integer ê°™ì€ êµ¬í˜„ê°’(íƒ€ì…ê°’)ìœ¼ë¡œ Të¥¼ êµì²´í•©ë‹ˆë‹¤.
&lt;code&gt;To reference the generic Box class from within your code, you must perform a generic type invocation, which replaces T with some concrete value, such as Integer:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Integer&amp;gt; integerBox;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;í”í•œ ë©”ì†Œë“œ í˜¸ì¶œê³¼ generic type í˜¸ì¶œì´ ë¹„ìŠ·í•˜ê³  ìƒê°í•  ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ &lt;strong&gt;ë©”ì†Œë“œ&lt;/strong&gt;ì— ì¸ìë¥¼ ì „ë‹¬í•˜ëŠ” ë°˜ë©´ì— Box &lt;strong&gt;í´ë˜ìŠ¤&lt;/strong&gt;ì— type ì¸ìë¥¼ ì „ë‹¬í•œë‹¤(ì´ë²ˆì—ëŠ” Integerì„).
&lt;code&gt;You can think of a generic type invocation as being similar to an ordinary method invocation, but instead of passing an argument to a method, you are passing a type argument â€” Integer in this case â€” to the Box class itself.&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;Type íŒŒë¼ë¯¸í„°&#39;, &#39;Type ì¸ì&#39; ìš©ì–´ ì„¤ëª…: ë§ì€ ê°œë°œìë“¤ì€ &amp;quot;type íŒŒë¼ë¯¸í„°&amp;quot;ì™€ &amp;quot;type ì¸ì&amp;quot;ë¥¼ í˜¼ìš©í•´ì„œ ì‚¬ìš©í•œë‹¤. í•˜ì§€ë§Œ ì´ ìš©ì–´ë‚˜ ê°™ì§€ ì•Šë‹¤. ì½”ë”©í•  ë•Œ íŒŒë¼ë¯¸í„°í™”í•œ typeì„ ìƒì„±í•˜ê¸° ìœ„í•´ì„œ typeì¸ìë¥¼ ë§Œë“ ë‹¤. ê·¸ ê²°ê³¼, Foo&amp;lt;T&amp;gt;ì˜ TëŠ” Type íŒŒë¼ë¯¸í„°ì´ê³  Foo&amp;lt;String&amp;gt;ì˜ Stringì€  Type ì¸ìì´ë‹¤. ì´ë²ˆì¥ì—ì„œ Type ì¸ìì™€ Type íŒŒë¼ë¯¸í„°ë¥¼ ì‚¬ìš©í•  ë•Œ ìœ„ì— ì„¤ëª…í•œ ë‚´ìš©ì„ ìƒê¸°í•˜ê³  ì‚´í´ë´…ì‹œë‹¤.

`Type Parameter and Type Argument Terminology: Many developers use the terms &amp;quot;type parameter&amp;quot; and &amp;quot;type argument&amp;quot; interchangeably, but these terms are not the same. When coding, one provides type arguments in order to create a parameterized type. Therefore, the T in Foo&amp;lt;T&amp;gt; is a type parameter and the String in Foo&amp;lt;String&amp;gt; f is a type argument. This lesson observes this definition when using these terms.`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë‹¤ë¥¸ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ë“¯ì´, ì´ ì½”ë“œëŠ” ìƒˆë¡œìš´ Box ê°ì²´ë¥¼ ì‹¤ì œë¡œ ìƒì„±í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê°„ë‹¨íˆ ë§í•˜ë©´ integerBox ë³€ìˆ˜ëŠ” &amp;ldquo;Integer íƒ€ì…ì˜ Box í´ë˜ìŠ¤&amp;rdquo;ë¥¼ ê°€ë¦¬í‚¨ë‹¤.( Box&lt;Integer&gt;ëŠ” &amp;ldquo;Box of Integer&amp;rdquo;ë¼ê³  ì½ëŠ”ë‹¤.)
Like any other variable declaration, this code does not actually create a new Box object. It simply declares that integerBox will hold a reference to a &amp;ldquo;Box of Integer&amp;rdquo;, which is how Box&lt;Integer&gt; is read.&lt;/p&gt;

&lt;p&gt;generic íƒ€ì… í˜¸ì¶œì€ ì¼ë°˜ì ìœ¼ë¡œ íŒŒë¼ë¯¸í„°í™”ëœ typeìœ¼ë¡œ ì•Œë ¤ì ¸ ìˆë‹¤.
&lt;code&gt;An invocation of a generic type is generally known as a parameterized type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;í´ë˜ìŠ¤ë¥¼ ê°ì²´í™”í• ë•Œ ì‚¬ìš©í•˜ëŠ” new í‚¤ì›Œë“œëŠ” ê¸°ì¡´ê³¼ ê°™ì§€ë§Œ Genericsë¥¼ ìœ„í•œ í‘œê¸°ë²•ìœ¼ë¡œ  &lt;strong&gt;&lt;Integer&gt;&lt;/strong&gt;ê°€ í´ë˜ìŠ¤ëª…ê³¼ ì†Œê´„í˜¸(()) ì‚¬ì´ì— ìˆë‹¤.
&lt;code&gt;To instantiate this class, use the new keyword, as usual, but place &amp;lt;Integer&amp;gt; between the class name and the parenthesis:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Integer&amp;gt; integerBox = new Box&amp;lt;Integer&amp;gt;();
````
### ë‹¤ì´ì•„ëª¬ë“œ ì—°ì‚°ì(&amp;lt;&amp;gt;) `The Diamond`

ìë°”SE 7ë¶€í„° ì»´íŒŒì¼ëŸ¬ê°€ ì½”ë“œì˜ ë¬¸ë§¥ì„ ë³´ê³  íƒ€ì…ì„ ì¶”ë¡  í• ìˆ˜ ìˆê²Œ ë˜ì–´ íƒ€ì… ì¸ìê°€ í•„ìš”í•œ ë¶€ë¶„ì— empty type argument(ë¹ˆ type ì¸ì = &amp;lt;&amp;gt;)ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. êº½ì‡ (&amp;lt;&amp;gt;)ëŠ” ë¹„ê³µì‹ì ì´ì§€ë§Œ ë‹¤ì´ì•„ëª¬ë“œë¼ê³  ë¶ˆë¦°ë‹¤. ì˜ˆë¥¼ ë“¤ë©´, Box&amp;lt;Integer&amp;gt; ê°ì²´ë¥¼ ìƒì„±í• ë•Œ ì•„ë˜ì˜ ë¬¸ë²•ì„ ë”°ë¥¸ë‹¤:
`In Java SE 7 and later, you can replace the type arguments required to invoke the constructor of a generic class with an empty set of type arguments (&amp;lt;&amp;gt;) as long as the compiler can determine, or infer, the type arguments from the context. This pair of angle brackets, &amp;lt;&amp;gt;, is informally called the diamond. For example, you can create an instance of Box&amp;lt;Integer&amp;gt; with the following statement:`

```java
Box&amp;lt;Integer&amp;gt; integerBox = new Box&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë‹¤ì´ì•„ëª¬ë“œ í‘œê¸°ë²•ê³¼ íƒ€ì… ì¶”ë¡ ì— ëŒ€í•œ ë” ìì„¸í•œ ì •ë³´ëŠ” íƒ€ì… ì¶”ë¡ ì„ ë³´ì‹œì˜¤.
&lt;code&gt;For more information on diamond notation and type inference, see Type Inference.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;ë³µìˆ˜ê°œì˜-íƒ€ì…ë§¤ê°œë³€ìˆ˜&#34;&gt;ë³µìˆ˜ê°œì˜ íƒ€ì…ë§¤ê°œë³€ìˆ˜&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Multiple Type Parameters&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì´ì „ì— ë§í–ˆë“¯ì´, generic í´ë˜ìŠ¤ëŠ” ì—¬ëŸ¬ê°œì˜ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ê°€ì§ˆìˆ˜ ìˆë‹¤. ì˜ˆë¥¼ë“¤ì–´, generic OrderdPairí´ë˜ìŠ¤ëŠ” generic Pair ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ì˜€ë‹¤.
&lt;code&gt;As mentioned previously, a generic class can have multiple type parameters. For example, the generic OrderedPair class, which implements the generic Pair interface:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Pair&amp;lt;K, V&amp;gt; {
    public K getKey();
    public V getValue();
}

public class OrderedPair&amp;lt;K, V&amp;gt; implements Pair&amp;lt;K, V&amp;gt; {

    private K key;
    private V value;

    public OrderedPair(K key, V value) {
	this.key = key;
	this.value = value;
    }

    public K getKey()	{ return key; }
    public V getValue() { return value; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì•„ë˜ëŠ” OrderedPairí´ë˜ìŠ¤ë¡œ ë‘ê°œì˜ ê°ì²´ë¥¼ ë§Œë“œëŠ” ì½”ë“œì´ë‹¤.
&lt;code&gt;The following statements create two instantiations of the OrderedPair class:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Pair&amp;lt;String, Integer&amp;gt; p1 = new OrderedPair&amp;lt;String, Integer&amp;gt;(&amp;quot;Even&amp;quot;, 8);
Pair&amp;lt;String, String&amp;gt;  p2 = new OrderedPair&amp;lt;String, String&amp;gt;(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì½”ë“œëŠ” OrderedPair&lt;String, Integer&gt; ê°ì²´ë¥¼ ìƒì„±í•˜ë©´, KëŠ” String íƒ€ì…ì´ê³  VëŠ” Integer íƒ€ì…ì´ë‹¤. Orderedpairì˜ ìƒì„±ìì˜ íŒŒë¼ë¯¸í„° íƒ€ì…ë“¤ì€ String, Integerì´ë‹¤.  autoboxingì„ í†µí•´ Stringê³¼ intë¥¼ OrderedPairí´ë˜ìŠ¤ì— ì „ë‹¬í•´ë„ ë¬¸ì œì—†ë‹¤.(ì°¸ì¡°í˜•ì€ ìƒê´€ ì—†ëŠ”ë° ê¸°ë³¸í˜•ì¸ intëŠ” ì°¸ì¡°í˜•ìœ¼ë¡œ ë³€ê²½ë˜ì–´ì•¼í•œë‹¤. int -&amp;gt; Integer) 
&lt;code&gt;The code, new OrderedPair&amp;lt;String, Integer&amp;gt;, instantiates K as a String and V as an Integer. Therefore, the parameter types of OrderedPair&#39;s constructor are String and Integer, respectively. Due to autoboxing, it is valid to pass a String and an int to the class.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì´ì „ì— ë‹¤ì•„ëª¬ë“œ ì—°ì‚°ìë¥¼ ì–¸ê¸‰í–ˆë“¯ì´, ìë°” ì»´íŒŒì¼ëŸ¬ëŠ” OrderedPair&lt;String, Integer&gt;ë¡œ ì„ ì–¸í•œ K, V íƒ€ì…ì„ ì¶”ë¡  í• ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ë‹¤ì´ì•„ëª¬ë“œë¬¸ë²•ì„ ì‚¬ìš©í•´ì„œ ì½”ë“œë¥¼ ì¤„ì¼ìˆ˜ ìˆë‹¤.
&lt;code&gt;As mentioned in The Diamond, because a Java compiler can infer the K and V types from the declaration OrderedPair&amp;lt;String, Integer&amp;gt;, these statements can be shortened using diamond notation:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;OrderedPair&amp;lt;String, Integer&amp;gt; p1 = new OrderedPair&amp;lt;&amp;gt;(&amp;quot;Even&amp;quot;, 8);
OrderedPair&amp;lt;String, String&amp;gt;  p2 = new OrderedPair&amp;lt;&amp;gt;(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generic ì¸í„°í˜ì´ìŠ¤ë¥¼ ìƒì„±í•˜ëŠ”ê²ƒì€ generic í´ë˜ìŠ¤ë¥¼ ë§Œë“œëŠ” ë°©ë²•ê³¼ ê°™ë‹¤
&lt;code&gt;To create a generic interface, follow the same conventions as for creating a generic class.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;íƒ€ì…-íŒŒë¼ë¯¸í„°í™”&#34;&gt;íƒ€ì… íŒŒë¼ë¯¸í„°í™”&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Parameterized Types&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ë§¤ê°œë³€ìˆ˜íƒ€ì…(ì˜ˆ K, V)ì€  ë§¤ê°œë³€ìˆ˜í™”ëœ íƒ€ì…(ì˜ˆ List&lt;String&gt;)ìœ¼ë¡œ ëŒ€ì²´í•  ìˆ˜ ìˆë‹¤. OrderedPair&lt;K, V&gt;ë¥¼ ì˜ˆë¥¼ ë“¤ë©´:
&lt;code&gt;You can also substitute a type parameter (i.e., K or V) with a parameterized type (i.e., List&amp;lt;String&amp;gt;). For example, using the OrderedPair&amp;lt;K, V&amp;gt; example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;OrderedPair&amp;lt;String, Box&amp;lt;Integer&amp;gt;&amp;gt; p = new OrderedPair&amp;lt;&amp;gt;(&amp;quot;primes&amp;quot;, new Box&amp;lt;Integer&amp;gt;(...));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ì½”ë“œì—ì„œ ë§¤ê°œë³€ìˆ˜í™”ëœ íƒ€ì…(Parameterized Type)ì€ ìœ„ì˜ ì†ŒìŠ¤ì—ì„œëŠ” &lt;strong&gt;Box&amp;lt;Integer&amp;gt;&lt;/strong&gt;ì„ ì˜ë¯¸&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(2) Java Generics: ì œë„¤ë¦­ìŠ¤ëŠ” ì™œ ì‚¬ìš©í•˜ëŠ”ê°€? </title>
      <link>http://durtchrt.github.io/blog/java/generics/2/</link>
      <pubDate>Mon, 31 Oct 2016 15:52:48 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/2/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/why.html&#34;&gt;ì›ë¬¸&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GenericsëŠ” ì™œ ì‚¬ìš©í•˜ëŠ”ê°€&lt;/strong&gt;  (Why Use Generics?)&lt;/p&gt;

&lt;p&gt;ê°„ë‹¨íˆ ë§í•˜ë©´, genericsëŠ” íƒ€ì…ì„ í´ë˜ìŠ¤, ì¸í„°í˜ì´ìŠ¤, ë©”ì†Œë“œë¥¼ ì •ì˜í•  ë•Œ íŒŒë¼ë©”í„°í™” í•  ìˆ˜ ìˆë‹¤. ë©”ì†Œë“œ ì„ ì–¸ì— ì‚¬ìš©ë˜ëŠ” íŒŒë¼ë¯¸í„° í˜•ì‹ì²˜ëŸ¼, íƒ€ì… íŒŒë¼ë¯¸í„°ëŠ” ë‹¤ë¥¸ ì…ë ¥ê°’ì„ ê°™ì€ ì½”ë“œë¥¼ ì¬ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì„ ì œì‹œí•œë‹¤. ë‹¤ë¥¸ì ì€ í˜•ì‹ íŒŒë¼ë¯¸í„°ëŠ” ê°’ì´ ì…ë ¥ì´ë‹¤, íƒ€ì… íŒŒë¼ë©”í„°ëŠ” íƒ€ì…ì´ ì…ë ¥ì´ë‹¤.
&lt;code&gt;In a nutshell, generics enable types (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar formal parameters used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to type parameters are types.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;genericë¥¼ ì‚¬ìš©í•œ ì½”ë“œëŠ” ê·¸ë ‡ì§€ ì•ŠëŠ” ì½”ë“œ ëŒ€ë¹„ ë§ì€ ì¥ì ì„ ê°€ì¡Œë‹¤:
&lt;code&gt;Code that uses generics has many benefits over non-generic code&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ì»´íŒŒì¼ íƒ€ì„ì— ê°•ë ¥í•œ íƒ€ì… ì²´í¬ë¥¼í•œë‹¤.
&lt;code&gt;Stronger type checks at compile time.&lt;/code&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ìë°” ì»´íŒŒì¼ëŸ¬ëŠ” íƒ€ì… ì•ˆì „ì„±ì— ìœ„ë°˜í•˜ëŠ” ì½”ë“œê°€ ìˆë‹¤ë©´ ì¼ë°˜ì ì¸ ì½”ë“œì™€ ì˜¤ë¥˜ ì´ìŠˆì— ê°•í•œ íƒ€ì… ê²€ì‚¬ë¥¼ ì ìš©í•œë‹¤. ì»´íŒŒì¼íƒ€ì„ì— ì—ëŸ¬ë¥¼ ê³ ì¹˜ëŠ” ê²ƒì€ ëŸ°íƒ€ì„ ì—ëŸ¬ë¥¼ ê³ ì¹˜ëŠ” ê²ƒ ë³´ë‹¤ ì‰½ë‹¤.&lt;br /&gt;
&lt;code&gt;A Java compiler applies strong type checking to generic code and issues errors if the code violates type safety. Fixing compile-time errors is easier than fixing runtime errors, which can be difficult to find.&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Elimination of casts. &lt;br/&gt;
generics ì—†ì´ ìºìŠ¤íŒ…ì´ í•„ìš”í•œ ì½”ë“œ ì¡°ê°ì…ë‹ˆë‹¤.
&lt;code&gt;The following code snippet without generics requires casting:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List list = new ArrayList();
list.add(&amp;quot;hello&amp;quot;);
String s = (String) list.get(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;genericsë¥¼ ì‚¬ìš©í•´ì„œ ì½”ë“œë¥¼ ë‹¤ì‹œ ì‘ì„±í•˜ë©´, ì½”ë“œëŠ” ë”ì´ìƒ ìºìŠ¤íŒ…ì´ í•„ìš” ì—†ì–´ì§‘ë‹ˆë‹¤.
&lt;code&gt;When re-written to use generics, the code does not require casting:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
list.add(&amp;quot;hello&amp;quot;);
String s = list.get(0);   // no cast
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;í”„ë¡œê·¸ë˜ë¨¸ë“¤ì´ ì¼ë°˜ì ì¸ ì•Œê³ ë¦¬ì¦˜ì„ êµ¬í˜„í•˜ë„ë¡ ì§€ì›í•œë‹¤.&lt;br&gt;
genericsë¥¼ ì‚¬ìš©í•˜ë©´ì„œ í”„ë¡œê·¸ë˜ë¨¸ë“¤ì€ ë‹¤ì–‘í•œ íƒ€ì…ë“¤ì˜ ì½œë ‰ì…˜ì—ì„œ ë™ì‘í•˜ê³ , ìˆ˜ì •ê°€ëŠ¥í•˜ë©°, ë” ì•ˆì •ì ì´ê³  ì½ê¸° ì‰¬ìš´ ì½”ë“œë¥¼ ì¼ë°˜ì ì¸ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Enabling programmers to implement generic algorithms.
By using generics, programmers can implement generic algorithms that work on collections of different types, can be customized, and are type safe and easier to read.&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(1) Java  Generics</title>
      <link>http://durtchrt.github.io/blog/java/generics/1/</link>
      <pubDate>Mon, 31 Oct 2016 15:07:44 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/1/</guid>
      <description>

&lt;h1 id=&#34;ìë°”-ì œë„¥ë¦­ìŠ¤-java-generics-1&#34;&gt;ìë°” ì œë„¥ë¦­ìŠ¤ - Java Generics 1&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/index.html&#34;&gt;ì›ë³¸&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-java-tutorials&#34;&gt;The Java Tutorials&lt;/h2&gt;

&lt;h3 id=&#34;lesson-generics-updated&#34;&gt;Lesson: Generics(Updated)&lt;/h3&gt;

&lt;p&gt;ì†Œí”„íŠ¸ì›¨ì–´ì—ì„œ ë²„ê·¸ëŠ” ì¼ìƒì´ë‹¤. &lt;del&gt;ëª¨ë“  ì‚¬ì†Œí•˜ì§€ ì•Šì€ ì†Œí”„íŠ¸ì›¨ì–´ í”„ë¡œì íŠ¸ì—ì„œ ë²„ê·¸ëŠ” ì‚¶ì˜ ì§„ì‹¤ì´ë‹¤.&lt;/del&gt; ì£¼ì˜ê¹Šê²Œ ê³„íš, í”„ë¡œê·¸ë˜ë°, í…ŒìŠ¤íŠ¸ëŠ” ë²„ê·¸ê°€ ìŠ¤ë©°ë“œëŠ”ê²ƒì„ ì¤„ì—¬ì¤€ë‹¤. í•˜ì§€ë§Œ ì—¬ì°Œëë“ , ì–¸ì  ê°€! ë²„ê·¸ëŠ” ì½”ë“œì—ì„œ ê¸°ì–´ë‹¤ë‹ ë°©ë²•ì„ í•­ìƒ ì°¾ëŠ”ë‹¤. ì´ëŠ” ê²°êµ­ ìƒˆë¡œìš´ ê¸°ëŠ¥ì´ ë„ì…ë˜ê±°ë‚˜ ì½”ë“œ ì‚¬ì´ì¦ˆì™€ ë³µì¡ì„­ì´ ì¦ê°€ë¨ì— ë”°ë¼ ì‹¬ê°í•˜ê²Œ ëˆˆì— ë„ê²Œ ë  ê²ƒì´ë‹¤.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;In any nontrivial software project, bugs are simply a fact of life. Careful planning, programming, and testing can help reduce their pervasiveness, but somehow, somewhere, they&#39;ll always find a way to creep into your code. This becomes especially apparent as new features are introduced and your code base grows in size and complexity.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ìš´ì¢‹ê²Œ ëª‡ëª‡ ë²„ê·¸ëŠ” ì°¾ê¸° ì‰½ë‹¤. ì˜ˆë¥¼ë“¤ì–´, ì»´íŒŒì¼ íƒ€ì„ ë²„ê·¸ëŠ” ì´ˆê¸°ì— ì°¾ì„ ìˆ˜ ìˆë‹¤. ì»´íŒŒì¼ëŸ¬ì˜ ì—ëŸ¬ ë©”ì„¸ì§€ë¥¼ ì´ìš©í•˜ì—¬ ë¬¸ì œì ì„ ë°œê²¬í•˜ê³  ë°”ë¡œ ê±°ê¸°ì„œ ê³ ì¹ ìˆ˜ ìˆë‹¤. ë°˜ë©´ì— ëŸ°íƒ€ì„ ë²„ê·¸ëŠ” í›¨ì”¬ ë” í•´ê²°ì´ ì–´ë µë‹¤. ëŸ°íƒ€ì„ ë²„ê·¸ëŠ” ê²‰ìœ¼ë¡œ ì§ì ‘ ë‚˜íƒ€ë‚˜ì§€ ì•Šìœ¼ë©°, ë²„ê·¸ê°€ ë™ì‘í•  ë•Œ, ê·¸ê²ƒì€ í”„ë¡œê·¸ë¨ì—ì„œ ì‹¤ì œ ë¬¸ì œì˜ ì›ì¸ì—ì„œ ë©€ë¦¬ ë–¨ì–´ì§„ ì§€ì ì— ìˆì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Fortunately, some bugs are easier to detect than others. Compile-time bugs, for example, can be detected early on; you can use the compiler&#39;s error messages to figure out what the problem is and fix it, right then and there. Runtime bugs, however, can be much more problematic; they don&#39;t always surface immediately, and when they do, it may be at a point in the program that is far removed from the actual cause of the problem.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;GenericsëŠ” ì»´íŒŒì¼ íƒ€ì„ì— ë²„ê·¸ë¥¼ ì°¾ì„ìˆ˜ ìˆê²Œë˜ì–´ ì½”ë“œì— ì•ˆì •ì„±ì„ ë”í•©ë‹ˆë‹¤. ì´ ê³¼ì •ì„ ë§ˆì¹œí›„ì—ëŠ” Gilad Brachaì˜ Generics íŠœí† ë¦¬ì–¼ì„ ì§„í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Generics add stability to your code by making more of your bugs detectable at compile time. After completing this lesson, you may want to follow up with the Generics tutorial by Gilad Bracha.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>