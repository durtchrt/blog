<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>개발 저장소</title>
    <link>http://durtchrt.github.io/blog/tags/generics/index.xml</link>
    <description>Recent content on 개발 저장소</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>durtchrt</copyright>
    <atom:link href="http://durtchrt.github.io/blog/tags/generics/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>자바 제네릭스(10) 와일드카드 Wildcards </title>
      <link>http://durtchrt.github.io/blog/java/generics/11/</link>
      <pubDate>Sat, 12 Nov 2016 18:23:01 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/11/</guid>
      <description>

&lt;h3 id=&#34;상위-제한된-와일드-카드-upper-bounded-wildcards&#34;&gt;상위 제한된 와일드 카드 &lt;code&gt;Upper Bounded Wildcards&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;변수에 완화된 제한을 걸고 싶을때 upper bounded wildcard를 사용한다. 예를들면, List&amp;lt;Integer&amp;gt;, List&amp;lt;Double&amp;gt;, List&amp;lt;Number&amp;gt; 타입들에서 동작하는 메서드를 작성할때 upper bounded wildcard를 사용해서 만들수 있다.
&lt;code&gt;You can use an upper bounded wildcard to relax the restrictions on a variable. For example, say you want to write a method that works on List&amp;lt;Integer&amp;gt;, List&amp;lt;Double&amp;gt;, and List&amp;lt;Number&amp;gt;; you can achieve this by using an upper bounded wildcard.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;uppper-bounded wildcard는 와일드카드 문자 &amp;lsquo;?&amp;lsquo;와 뒤에는 extends 키워드를 사용하고 뒤에는 상위 타입을 써서 정의한다. 클래스의 extends, 인터페이스의 implements처럼 extends 키워드는 이러한 의미로 사용된다.
&lt;code&gt;To declare an upper-bounded wildcard, use the wildcard character (&#39;?&#39;), followed by the extends keyword, followed by its upper bound. Note that, in this context, extends is used in a general sense to mean either &amp;quot;extends&amp;quot; (as in classes) or &amp;quot;implements&amp;quot; (as in interfaces).&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Integer, Double, Float처럼 Number 타입의 서브타입들에서 동작하는 메서드를 작성할 때, List&amp;lt;? extends Number&amp;gt; 요래 작성하면된다. List&amp;lt;Number&amp;gt;는 List&amp;lt;? extends Number&amp;gt;보다 제한적이다. 전자는 Number 타입의 리스트만 가능, 후자는 Number 타입 또는 Number 타입의 서브 타입 리스트도 가능하다.
&lt;code&gt;To write the method that works on lists of Number and the subtypes of Number, such as Integer, Double, and Float, you would specify List&amp;lt;? extends Number&amp;gt;. The term List&amp;lt;Number&amp;gt; is more restrictive than List&amp;lt;? extends Number&amp;gt; because the former matches a list of type Number only, whereas the latter matches a list of type Number or any of its subclasses.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;아래의 process 메서드를 살펴보자 &lt;code&gt;Consider the following process method:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void process(List&amp;lt;? extends Foo&amp;gt; list) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lt;? extends Foo&amp;gt; upper bounded wildcard는 Foo와 Foo의 서브타입과 매치되는 표현이다. (아래의 코드 참조)process 메서드는 Foo타입과 같은 리스트의 요소를 엑세스할수 있다.
&lt;code&gt;The upper bounded wildcard, &amp;lt;? extends Foo&amp;gt;, where Foo is any type, matches Foo and any subtype of Foo. The process method can access the list elements as type Foo:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void process(List&amp;lt;? extends Foo&amp;gt; list) {
    for (Foo elem : list) {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;foreach절은 list의 각각 요소를 순회하며 elem 변수에 할당한다.  elem은 Foo 클래스에 정의되어 있는 메서드를 모두 사용할 수 있다.
&lt;code&gt;In the foreach clause, the elem variable iterates over each element in the list. Any method defined in the Foo class can now be used on elem.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;sumOfList메서드는 리스트 안의 숫자의 합을 리턴한다. &lt;code&gt;The sumOfList method returns the sum of the numbers in a list:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static double sumOfList(List&amp;lt;? extends Number&amp;gt; list) {
    double s = 0.0;
    for (Number n : list)
        s += n.doubleValue();
    return s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래의 코드는 Integer 객체 리스트를 사용하여 &amp;ldquo;sum = 6.0&amp;rdquo;을 출력한다.
&lt;code&gt;The following code, using a list of Integer objects, prints sum = 6.0:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Integer&amp;gt; li = Arrays.asList(1, 2, 3);
System.out.println(&amp;quot;sum = &amp;quot; + sumOfList(li));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Double값을 가진 리스트도 sumOfList 메서드를 역시 사용할 수 있다. 아래의 코드는 &amp;ldquo;sum = 7.0&amp;rdquo;을 출력한다.
&lt;code&gt;A list of Double values can use the same sumOfList method. The following code prints sum = 7.0:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Double&amp;gt; ld = Arrays.asList(1.2, 2.3, 3.5);
System.out.println(&amp;quot;sum = &amp;quot; + sumOfList(ld));
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(10) 와일드카드 Wildcards </title>
      <link>http://durtchrt.github.io/blog/java/generics/10/</link>
      <pubDate>Fri, 11 Nov 2016 18:23:01 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/10/</guid>
      <description>

&lt;h3 id=&#34;와일드카드-wildcards&#34;&gt;와일드카드 &lt;code&gt;Wildcards&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic 코드에서는 unkown 타입을 표현하는 물음표(?)를 와일드 카드라고 부른다. 와일드카드는 다양한 상황에서 쓰인다.(파라메터, 필드, 지역변수 타입 때로는 리턴 타입에도 쓰인다. (though it is better programming practice to be more specific). 와일드카드는 제네릭 메서드 호출, 제네릭 클래스의 인스턴스 생성, 또는 슈퍼타입을 위해 타입인자로는 사용되지 않는다.
&lt;code&gt;In generic code, the question mark (?), called the wildcard, represents an unknown type. The wildcard can be used in a variety of situations: as the type of a parameter, field, or local variable; sometimes as a return type (though it is better programming practice to be more specific). The wildcard is never used as a type argument for a generic method invocation, a generic class instance creation, or a supertype.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이번장에는 와일드카드에 대해 논의한다. 상위제한된 와일드카드/하위제한된 와일드카드, 와일드카드 캡쳐등을 다룬다.
&lt;code&gt;The following sections discuss wildcards in more detail, including upper bounded wildcards, lower bounded wildcards, and wildcard capture.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(13) Java Generics: 하위 제한 와일드카드(Lower Bounded Wildcards)</title>
      <link>http://durtchrt.github.io/blog/java/generics/13/</link>
      <pubDate>Mon, 07 Nov 2016 14:00:42 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/13/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/wildcards.htm://docs.oracle.com/javase/tutorial/java/generics/lowerBounded.html&#34;&gt;원문링크&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;하위-제한-와일드카드-lower-bounded-wildcards&#34;&gt;하위 제한 와일드카드  &lt;code&gt;Lower Bounded Wildcards&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;상위제한와일드카드장은 특정 타입이나 그 특정타입의  서브타입을 알 수 없을때는 &amp;lsquo;extends&amp;rsquo; 키워드를 사용하는 것을 보여줬다. 비슷한 것으로, 하위제한와일드카드는 특정타입이나 그 특정 타입의 슈퍼타입을 제한하고자할때 사용한다.
&lt;code&gt;The Upper Bounded Wildcards section shows that an upper bounded wildcard restricts the unknown type to be a specific type or a subtype of that type and is represented using the extends keyword. In a similar way, a lower bounded wildcard restricts the unknown type to be a specific type or a super type of that type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;하위제한 와일드카드는 와일드카드문자(&amp;lsquo;?&amp;rsquo;) 그 뒤로 super 키워드와 그 뒤로 하위제한 타입이 온다. &amp;lt;? super A&amp;gt;.
&lt;code&gt;A lower bounded wildcard is expressed using the wildcard character (&#39;?&#39;), following by the super keyword, followed by its lower bound: &amp;lt;? super A&amp;gt;.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;중요: 상위제한와일드카드를 사용하거나 하위제한와일드카드를 사용할 수 있지만, 둘을 동시에 사용할 수 없다.&lt;/code&gt;
&lt;code&gt;Note: You can specify an upper bound for a wildcard, or you can specify a lower bound, but you cannot specify both.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;리스트에 Integer 객체를 넣는 코드를 작성할때, List&amp;lt;Integer&amp;gt;, List&amp;lt;Number&amp;gt;, List&amp;lt;Object\&amp;gt;에서만 동작하길 원하는 메서드를 만든다고 가정하자.
&lt;code&gt;Say you want to write a method that puts Integer objects into a list. To maximize flexibility, you would like the method to work on List&amp;lt;Integer&amp;gt;, List&amp;lt;Number&amp;gt;, and List&amp;lt;Object&amp;gt; — anything that can hold Integer values.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Integer타이이나 Integer의 상위타입에서 동작하는 메서드를 작성하려면 List&amp;lt;? super Integer&amp;gt;라고 할 수 있다. List&amp;lt;Integer&amp;gt;는 List&amp;lt;? super Integer&amp;gt;보다 제한적이다. 왜냐하면 전자는 Integer 타입의 리스트만 사용, 후자는 Integer 타입과 Integer의 슈퍼타입에 사용할 수 있기 때문이다.
&lt;code&gt;To write the method that works on lists of Integer and the supertypes of Integer, such as Integer, Number, and Object, you would specify List&amp;lt;? super Integer&amp;gt;. The term List&amp;lt;Integer&amp;gt; is more restrictive than List&amp;lt;? super Integer&amp;gt; because the former matches a list of type Integer only, whereas the latter matches a list of any type that is a supertype of Integer.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;아래의 코드는 1에서 10까지 리스트에 add한다.
&lt;code&gt;The following code adds the numbers 1 through 10 to the end of a list:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void addNumbers(List&amp;lt;? super Integer&amp;gt; list) {
    for (int i = 1; i &amp;lt;= 10; i++) {
        list.add(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;와일드카드 사용절에서는 상위제한와일드카드와 하위제한와일드카드를 각각 언제 사용할지 설명하였다.
&lt;code&gt;The Guidelines for Wildcard Use section provides guidance on when to use upper bounded wildcards and when to use lower bounded wildcards.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(12) Java Generics: 상위 제한된 와일드카드(Upper Bounded Wildcards)</title>
      <link>http://durtchrt.github.io/blog/java/generics/12/</link>
      <pubDate>Mon, 07 Nov 2016 13:00:42 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/12/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/unboundedWildcards.html&#34;&gt;원문링크&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;제한없는-와일드카드-unbounded-wildcards&#34;&gt;제한없는 와일드카드 &lt;code&gt;Unbounded Wildcards&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;제한없는 와일드카드 타입은 와일드카드 문자(&amp;lsquo;?&amp;rsquo;)만 사용한것이다. 예를 들면 List&amp;lt;?&amp;gt;와 같다. List&amp;lt;?&amp;gt;의 ?는 List의 &amp;lsquo;알수없는 타입(unkown type)&amp;lsquo;이라고 부른다. 아래 두개의 시나리오는 제한없는 와일드카드가 유용한 접근법이다.
&lt;code&gt;The unbounded wildcard type is specified using the wildcard character (?), for example, List&amp;lt;?&amp;gt;. This is called a list of unknown type. There are two scenarios where an unbounded wildcard is a useful approach:&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Object 클래스에서 제공하는 기능(메서드)을 사용하도록 메서드를 구현할 때.
&lt;code&gt;- If you are writing a method that can be implemented using functionality provided in the Object class.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;코드가 generic 클래스에서 메서드가 타입매개변수에 의존적이지 않게 작성하고 싶을 때.(예 List.size나 List.clear). 사실, Class&amp;lt;T&amp;gt; 클래스는 범위없는 와일드카드를 자주 사용한다.(Class&amp;lt;T&amp;gt;의 메서드가 T에 의존적으로 동작하지 않게 만들기 위해)
&lt;code&gt;- When the code is using methods in the generic class that don&#39;t depend on the type parameter. For example, List.size or List.clear. In fact, Class&amp;lt;?&amp;gt; is so often used because most of the methods in Class&amp;lt;T&amp;gt; do not depend on T.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;printList 메서드를 살펴보자.
&lt;code&gt;Consider the following method, printList:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void printList(List&amp;lt;Object&amp;gt; list) {
    for (Object elem : list)
        System.out.println(elem + &amp;quot; &amp;quot;); // elem.toString() 자동으로 호출됨.
    System.out.println();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;printList는 List가 가진 객체가 어떤 타입이든간에 상관없이 print하고 싶어한다. 하지만 List 객체는 Object 타입의 객체만 출력할 수 있다. (참조:&lt;a href=&#34;../8&#34;&gt;제네릭스, 상속, 서브타입&lt;/a&gt;) List&amp;lt;Object&amp;gt;는 List&amp;lt;Integer&amp;gt;, List&amp;lt;String&amp;gt;, List&amp;lt;Double&amp;gt;을 출력할 수 없다. 왜냐하면 List&amp;lt;Object&amp;gt; 타입의 stub type(스텁타입 용어 아시는분 공유 부탁요 ㅠㅠ)이 아니다. 아래는 List&amp;lt;?&amp;gt;를 사용해서 generic 메서드인 printList를 작성한 예이다..&lt;/p&gt;

&lt;p&gt;&lt;code&gt;The goal of printList is to print a list of any type, but it fails to achieve that goal — it prints only a list of Object instances; it cannot print List&amp;lt;Integer&amp;gt;, List&amp;lt;String&amp;gt;, List&amp;lt;Double&amp;gt;, and so on, because they are not subtypes of List&amp;lt;Object&amp;gt;. To write a generic printList method, use List&amp;lt;?&amp;gt;:&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(역자 추가 - 위의 예가 설명하는 코드 - 컴파일 에러 발생)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Integer&amp;gt; integerList = Arrays.asList(1,2);
printList(integerList);   // 컴파일 에러
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void printList(List&amp;lt;?&amp;gt; list) {
    for (Object elem: list)
        System.out.print(elem + &amp;quot; &amp;quot;);
    System.out.println();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아무 타입을 A로 지칭했을때, List&amp;lt;?&amp;gt;의 서브타입은 List&amp;lt;A&amp;gt;이 성립이 되기 때문에, printList 메서드가 모든 타입을 대상으로 print할 수 있다.
&lt;code&gt;Because for any concrete type A, List&amp;lt;A&amp;gt; is a subtype of List&amp;lt;?&amp;gt;, you can use printList to print a list of any type:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Integer&amp;gt; li = Arrays.asList(1, 2, 3);
List&amp;lt;String&amp;gt;  ls = Arrays.asList(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;);
printList(li);
printList(ls);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고: Arrays.asList 메서드는 범위없는 와일드카드를 사용해서 구현되었다. Arrays.asList라는 static 팩토리 메서드는 배열을 구체화하여 변경하고(요소들의 공통 타입을 타입추론)  고정된 사이즈의 리스트를 반환한다.
&lt;code&gt;Note: The Arrays.asList method is used in examples throughout this lesson. This static factory method converts the specified array and returns a fixed-size list.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(중요!)List&lt;Object&gt;와 List&amp;lt;?&amp;gt;과 다르다. List&lt;Object&gt;에 Object 타입이나 Object의 서브타입을 insert할 수 있다. 하지만 List&amp;lt;?&amp;gt;에는 null만 insert할 수 있다.(하고자하는 말이 무언지 이해가 안된다;;;) 와일드카드 사용 섹션은은 상황별 어떤 와일드카드를 사용할지 결정에 대한 가이드라인을 제공한다.
&lt;code&gt;It&#39;s important to note that List&amp;lt;Object&amp;gt; and List&amp;lt;?&amp;gt; are not the same. You can insert an Object, or any subtype of Object, into a List&amp;lt;Object&amp;gt;. But you can only insert null into a List&amp;lt;?&amp;gt;. The Guidelines for Wildcard Use section has more information on how to determine what kind of wildcard, if any, should be used in a given situation.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(9) Java Generics: 타입추론(Type Inference)</title>
      <link>http://durtchrt.github.io/blog/java/generics/9/</link>
      <pubDate>Sat, 05 Nov 2016 18:23:01 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/9/</guid>
      <description>

&lt;p&gt;용어&lt;/p&gt;

&lt;p&gt;statement: 문장으로 해석하면 오해의 여지가 있어서 statement 영문 그대로 작성한다. 컴퓨터 프로그래밍에서는 statement를 독립적인 요소의 최소 단위. &lt;a href=&#34;https://en.wikipedia.org/wiki/Statement_(computer_science)&#34;&gt;영문위키&lt;/a&gt;의 중간을 보면 Kinds of statements 파트에 Simple statments, Compound statements 부분의 코드를 보면 느낌이 온다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html&#34;&gt;원문링크&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;타입추론-type-inference&#34;&gt;타입추론 &lt;code&gt;Type Inference&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;타입추론은 메서드를 호출하는 코드에서 타입인자가 정의한대로 제대로 쓰였는지 살펴보는 컴파일러의 능력이다. 타입추론은 인자의 타입을 확인하고 만약 사용가능하다면, 해당 타입을 할당하거나 리턴될 것이다. 결국 타입추론은 모든 인자에 동작해서 가장 구체적인 타입을 찾는 것을 시도한다.(뭔가 말이 어렵다;;)
&lt;code&gt;[Type inference is a Java compiler&#39;s ability to look at each method invocation and corresponding declaration to determine the type argument (or arguments) that make the invocation applicable.] The inference algorithm determines the types of the arguments and, if available, the type that the result is being assigned, or returned. Finally, the inference algorithm tries to find the most specific type that works with all of the arguments.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;~&lt;del&gt;아래의 예는 마지막 지점을 설명한다.&lt;/del&gt;~ 타입추론은 두번째 인자가 전달될 때 pick 메서드는 Serializable로 결정되어집니다.
(역주: pick의 두 인자 a1, a2는 타입인자로 String과 ArrayList를 전달 받는다. 둘의 공통점은 Serializable 인터페이스를 구현한 클래스라는 것이다. 인자들이 같은 타입이 아니면 각각 인자들의 타입에서 공통으로 쓰는 슈퍼 타입으로 추론. 코드레벨로 작성한거라 추론이라하긴 뭐한데&amp;hellip; 일단 진행.)
&lt;code&gt;To illustrate this last point, in the following example, inference determines that the second argument being passed to the pick method is of type Serializable:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static &amp;lt;T&amp;gt; T pick(T a1, T a2) { return a2; }
Serializable s = pick(&amp;quot;d&amp;quot;, new ArrayList&amp;lt;String&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;타입추론과-generic-메서드-type-inference-and-generic-methods&#34;&gt;타입추론과 Generic 메서드 &lt;code&gt;Type Inference and Generic Methods&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Generic 메서드는 꺽쇠안에 타입을 작성하지 않고(빈타입인자) 메서드를 호출하면 타입추론을 보여준다. BoxDemo 예를 보시오. 이 예는 Box 클래스를 필요로합니다.
&lt;code&gt;Generic Methods introduced you to type inference, which enables you to invoke a generic method as you would an ordinary method, without specifying a type between angle brackets. Consider the following example, BoxDemo, which requires the Box class:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BoxDemo {

  public static &amp;lt;U&amp;gt; void addBox(U u, 
      java.util.List&amp;lt;Box&amp;lt;U&amp;gt;&amp;gt; boxes) {
    Box&amp;lt;U&amp;gt; box = new Box&amp;lt;&amp;gt;();
    box.set(u);
    boxes.add(box);
  }

  public static &amp;lt;U&amp;gt; void outputBoxes(java.util.List&amp;lt;Box&amp;lt;U&amp;gt;&amp;gt; boxes) {
    int counter = 0;
    for (Box&amp;lt;U&amp;gt; box: boxes) {
      U boxContents = box.get();
      System.out.println(&amp;quot;Box #&amp;quot; + counter + &amp;quot; contains [&amp;quot; +
             boxContents.toString() + &amp;quot;]&amp;quot;);
      counter++;
    }
  }

  public static void main(String[] args) {
    java.util.ArrayList&amp;lt;Box&amp;lt;Integer&amp;gt;&amp;gt; listOfIntegerBoxes =
      new java.util.ArrayList&amp;lt;&amp;gt;();
    BoxDemo.&amp;lt;Integer&amp;gt;addBox(Integer.valueOf(10), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(30), listOfIntegerBoxes);
    BoxDemo.outputBoxes(listOfIntegerBoxes);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 예제는 아래와 같은 결과를 출력한다.
&lt;code&gt;The following is the output from this example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Box #0 contains [10]
Box #1 contains [20]
Box #2 contains [30]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generic 메서드인 addbox는 U라는 타입매개변수가 선언되어있다. 일반적으로, 자바컴파일러는 generic 메서드 호출하는 코드를 보고 타입파라메터를 추론할 수 있다. 그 결과, 대부분 타입을 꼭 명시하지 않아도 된다. 예를 들어 addBox라는 generic 메서드를 호출할때, 아래 코드처럼 구체적인 타입 매개변수를 줄 수 있다.
&lt;code&gt;The generic method addBox defines one type parameter named U. Generally, a Java compiler can infer the type parameters of a generic method call. Consequently, in most cases, you do not have to specify them. For example, to invoke the generic method addBox, you can specify the type parameter with a type witness as follows:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BoxDemo.&amp;lt;Integer&amp;gt;addBox(Integer.valueOf(10), listOfIntegerBoxes);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 코드 대신 아래 코드처럼 타입 정보를 제공하지 않고 코드를 작성해도, 자바 컴파일러는 타입매개변수가 Integer라고 (메서드의 인자들로부터) 자동으로 추론을 한다.
&lt;code&gt;Alternatively, if you omit the type witness,a Java compiler automatically infers (from the method&#39;s arguments) that the type parameter is Integer:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;타입추론과-generic-객체-type-inference-and-instantiation-of-generic-classes&#34;&gt;타입추론과 generic 객체  &lt;code&gt;Type Inference and Instantiation of Generic Classes&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic 클래스를 생성자를 통해 객체를 생성할 때 타입인자 대신 빈타입파라미터(&amp;lt;&amp;gt;)를 사용할때 자바 컴파일러는 코드 문맥으로부터 타입인자를 유추할 수 있다. 비공식적으로 한쌍의 꺽쇠(&amp;lt;&amp;gt;)는 다이아몬드라고 부른다.
&amp;lsquo;You can replace the type arguments required to invoke the constructor of a generic class with an empty set of type parameters (&amp;lt;&amp;gt;) as long as the compiler can infer the type arguments from the context. This pair of angle brackets is informally called the diamond.&amp;rsquo;&lt;/p&gt;

&lt;p&gt;예를 들어 변수 선언을 보자.
&lt;code&gt;For example, consider the following variable declaration:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; myMap = new HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(위의 예제 처럼)generic 클래스의 생성자에 타입매개변수화한 생성자 대신 (아래 예제 처럼)&amp;lt;&amp;gt;를 사용할 수 있다.
&lt;code&gt;You can substitute the parameterized type of the constructor with an empty set of type parameters (&amp;lt;&amp;gt;):&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; myMap = new HashMap&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generic 클래스를 객체화할 때 타입추론을 시키려면 반드시 다이아몬드 연산자를 사용하십시오. 아래의 예를 보면 컴파일러는 Hash맵을 raw타입으로 인식해서 경고를 한다.(선언문의 Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;을 보고 할당문의 HashMap의 생성자는 타입추론을 하지 않는다. 그냥 raw 타입이 된다. )
&lt;code&gt;Note that to take advantage of type inference during generic class instantiation, you must use the diamond. In the following example, the compiler generates an unchecked conversion warning because the HashMap() constructor refers to the HashMap raw type, not the Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; type:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; myMap = new HashMap(); // unchecked conversion warning
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;타입추론과-generic-타입의-generic-생성자-그리고-non-generic-클래스가-type-inference-and-generic-constructors-of-generic-and-non-generic-classes&#34;&gt;타입추론과 generic 타입의 Generic 생성자 그리고 Non-Generic 클래스가 &lt;code&gt;Type Inference and Generic Constructors of Generic and Non-Generic Classes&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic 클래스와 non-generic 클래스는 둘다 generic(일반 타입매개변수를 선언)이 될 수 있다. 아래 예를 보자
&lt;code&gt;Note that constructors can be generic (in other words, declare their own formal type parameters) in both generic and non-generic classes. Consider the following example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MyClass&amp;lt;X&amp;gt; {
  &amp;lt;T&amp;gt; MyClass(T t) {
    // ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MyClass 클래스의 객체 생성을 살펴보면
&lt;code&gt;Consider the following instantiation of the class MyClass:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new MyClass&amp;lt;Integer&amp;gt;(&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 코드는 MyClass&amp;lt;Integer&amp;gt;라는 매개변수화된 타입의 객체를 생성하는 statement이다. 이 statement는 generic 클래스인 MyClass&amp;lt;X&amp;gt;의 타입매개변수의 형식을 Integer 타입으로 구체화하도록 명시한다. 중요한점은 generic 클래스의 생성자는 T라는 형식 타입매개변수를 포함해야한다. 컴파일러는 generic 클래스의 생성자의 형식 파라메터 T를 String 타입으로 추론한다.(왜냐하면 생성자의 매개변수는 String 타입의 객체이기 때문이다.)
&lt;code&gt;This statement creates an instance of the parameterized type MyClass&amp;lt;Integer&amp;gt;; the statement explicitly specifies the type Integer for the formal type parameter, X, of the generic class MyClass&amp;lt;X&amp;gt;. Note that the constructor for this generic class contains a formal type parameter, T. The compiler infers the type String for the formal type parameter, T, of the constructor of this generic class (because the actual parameter of this constructor is a String object).&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(역자 - 번역하다가 도통 뭔말인지 몰라서 코딩해봄.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Main {
	public static void main(String[] args) {
		MyClass&amp;lt;Integer&amp;gt; a = new MyClass&amp;lt;&amp;gt;(&amp;quot;&amp;quot;);
		System.out.println(a.x.getClass().getSimpleName());
	}
}

class MyClass&amp;lt;X&amp;gt; {
	X x;
	&amp;lt;T&amp;gt; MyClass(T t) {
		this.x = (X) t;
	}
}
// 런타임 에러 발생되는 코드
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(역자)MyClass의 생성자의 T라는 타입매개변수만 적으면 컴파일이 안된다. 생성자 앞에 &amp;lt;T&amp;gt;를 넣어줘야 컴파일이 되는데 요놈을 형식타입매개변수가로 지칭하는 것으로 보인다. 클래스에 적어준 &amp;lt;X&amp;gt;랑은 다름을 주의. 아직은 딱히 어느 상황에 써야할지 잘 모르겠다&amp;hellip;.&lt;/p&gt;

&lt;p&gt;generic 메서드처럼 generic 생성자에서 실제 타입파라메터를 추론하는 능력은 Java SE 7이전 컴파일러에서 릴리즈되었다.(역자??? 이부분이 이해가 안감) 하지만 Java SE 7 이후 컴파일러는 다이아몬드연산자(&amp;lt;&amp;gt;)를 사용해서 generic 클래스를 객체 생성할 때 실제 타입매개변수를 추론할 수 있습니다. 아래의 예를 보세요.
&lt;code&gt;Compilers from releases prior to Java SE 7 are able to infer the actual type parameters of generic constructors, similar to generic methods. However, compilers in Java SE 7 and later can infer the actual type parameters of the generic class being instantiated if you use the diamond (&amp;lt;&amp;gt;). Consider the following example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MyClass&amp;lt;Integer&amp;gt; myObject = new MyClass&amp;lt;&amp;gt;(&amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 예제는 컴파일러가 generic 클래스 MyClass&amp;lt;X&amp;gt;의 형식타입 파라메터 X를 Integer 타입으로 추론한다. 컴파일러는 generic 클래스의 생성자의 형식매개변수 T에 String 타입을 추론한다.
&lt;code&gt;In this example, the compiler infers the type Integer for the formal type parameter, X, of the generic class MyClass&amp;lt;X&amp;gt;. It infers the type String for the formal type parameter, T, of the constructor of this generic class.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;중요: 타입추론 알고리즘은 인자, 대상 타입, 명백히 기대되는 리턴 타입만 사용한다. 추론 알고리즘은 프로그램에서 나중에 결과를 사용하지 않는다. (역자: 내용이 명확히 안들어옴.)
&lt;code&gt;Note: It is important to note that the inference algorithm uses only invocation arguments, target types, and possibly an obvious expected return type to infer types. The inference algorithm does not use results from later in the program.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;target-types&#34;&gt;&lt;code&gt;Target Types&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;자바 컴파일러는 generic 메서드 호출에 타입매개변수를 추론하는 target typing은 장점을 가진다. target type 표현식은 자바 컴파일러가 기대하는 데이터 타입이다. Collection.emptyList 메서드를 살펴보면 아래와 같이 선언되어있다.
&lt;code&gt;The Java compiler takes advantage of target typing to infer the type parameters of a generic method invocation. [The target type of an expression is the data type that the Java compiler expects depending on where the expression appears.] Consider the method Collections.emptyList, which is declared as follows:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; emptyList();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;할당문을 살펴보면:
&lt;code&gt;Consider the following assignment statement:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; listOne = Collections.emptyList();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 statement는 List&lt;String&gt;의 객체를 기대한다. 이 데이터 타입이 target type이다. 왜냐하면 emptyList 메서드는 List&lt;T&gt; 타입의 값을 리턴한다. 컴파일러는 타입인자는 반드시 String 타입의 값일 것이라고 추론한다. 이는 Java SE 7 이상에서 동작한다. 추론 대신에 아래의 예처럼 타입매개변수 T의 타입인자값을 특정 타입값을 명시할 수 있다.
&lt;code&gt;This statement is expecting an instance of List&amp;lt;String&amp;gt;; this data type is the target type. Because the method emptyList returns a value of type List&amp;lt;T&amp;gt;, the compiler infers that the type argument T must be the value String. This works in both Java SE 7 and 8. Alternatively, you could use a type witness and specify the value of T as follows:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; listOne = Collections.&amp;lt;String&amp;gt;emptyList();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;하지만 위의 코드 문맥상 target type이 필요치 않다. 코드문맥상 target type이 필요한 예를 아래 코드를 보며 살펴보자.
&lt;code&gt;However, this is not necessary in this context. It was necessary in other contexts, though. Consider the following method:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void processStringList(List&amp;lt;String&amp;gt; stringList) {
    // process stringList
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빈리스트와 함께 processStringList 메서드를 호출한다고 가정하자. Java SE 7에서는 아래의 코드는 컴파일 되지 않는다.
&lt;code&gt;Suppose you want to invoke the method processStringList with an empty list. In Java SE 7, the following statement does not compile:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;processStringList(Collections.emptyList());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java SE 7 컴파일러는 아래의 에러메세지를 던진다.
&lt;code&gt;The Java SE 7 compiler generates an error message similar to the following:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shelll&#34;&gt;List&amp;lt;Object&amp;gt; cannot be converted to List&amp;lt;String&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;컴파일러는 T의 타입인자가 필요한데 T는 target type을 주지 않으면 Object이다. 결국, Collection.emptyList에 타입인자는 List&lt;Objec&gt; 타입이다. 그러므로 Java SE 7은 반드시 아래의 예처럼 타입인자를 명확히 알려줘야한다.
&lt;code&gt;The compiler requires a value for the type argument T so it starts with the value Object. Consequently, the invocation of Collections.emptyList returns a value of type List&amp;lt;Object&amp;gt;, which is incompatible with the method processStringList. Thus, in Java SE 7, you must specify the value of the value of the type argument as follows:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;processStringList(Collections.&amp;lt;String&amp;gt;emptyList());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java SE 8에서는 더이상 필요치 않다. 이 표기법은 target type은 메서드 인자를 포함해서 확장했다 (아래 예처럼 processStringList 메서드에 인자를 넣는것처럼). 이런경우, processStringList는 List&lt;String&gt; 타입의 인자를 필요로한다. Collections.emptyList 메서드는 List&lt;T&gt; 타입의 값을 리턴한다. 그럼 List&lt;String&gt;의 target type을 사용하면 컴파일러는 T의 타입인자를 String으로 추론하다. 따라서 Java SE 8은 아래의 문장이 컴파일된다.
&lt;code&gt;This is no longer necessary in Java SE 8. The notion of what is a target type has been expanded to include method arguments, such as the argument to the method processStringList. In this case, processStringList requires an argument of type List&amp;lt;String&amp;gt;. The method Collections.emptyList returns a value of List&amp;lt;T&amp;gt;, so using the target type of List&amp;lt;String&amp;gt;, the compiler infers that the type argument T has a value of String. Thus, in Java SE 8, the following statement compiles:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;processStringList(Collections.emptyList());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 많은 정보는 &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&#34;&gt;람다표현식&lt;/a&gt;에서 &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#target-typing&#34;&gt;Target Typing&lt;/a&gt;을 보세요.
&lt;code&gt;See Target Typing in Lambda Expressions for more information.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(8) Java Generics: 제네릭스, 상속, 서브타입 (Generics, Inheritance, and Subtypes)</title>
      <link>http://durtchrt.github.io/blog/java/generics/8/</link>
      <pubDate>Sat, 05 Nov 2016 08:48:42 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/8/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/inheritance.html&#34;&gt;원문링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;용어
메서드 시그니처(method signature): 메서들간에 개성 주는것으로 자바 컴파일러인지 메서드 시그니처를 기준으로 오버로딩을 한다.  자바에서는 메서드명, 파라미터 갯수, 파라미터 타입, 파라미터 순서(자바에서는 리턴타입은 시그니처가 아니다.) - 파라미터명도 시그니처인지는 아리까리하다. 메서드 오버로딩를 생각하면 맞는거 같은데&amp;hellip; 좀더 생각해보고 내용 수정 예정
콘크리트 타입, 구현타입(concrete type): 자바에서는 타입들중 interface, abstract class를 제외하고 남은 class를 concrete 타입으로 이해하면 될 듯.&lt;a href=&#34;http://dreuarchive.cra.org/2002/heise/typeComp.html&#34;&gt;참고링크 - 영문: 번역 예정&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;제네릭스-상속-서브타입-generics-inheritance-and-subtypes&#34;&gt;제네릭스, 상속, 서브타입 &lt;code&gt;Generics, Inheritance, and Subtypes&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;타입간 호환이된다면 특정 타입의 객체를 다른 타입에 할당이 가능합니다. 아래의 코드처럼 Object 타입은 Integer의 슈퍼타입중 하나이기 때문에 Integer 타입인 someInteger의 객체가 Object 타입인 someObject에 할당이 가능합니다.
&lt;code&gt;As you already know, it is possible to assign an object of one type to an object of another type provided that the types are compatible. For example, you can assign an Integer to an Object, since Object is one of Integer&#39;s supertypes:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object someObject = new Object();
Integer someInteger = new Integer(10);
someObject = someInteger;   // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;객체지향 이론에서는 이를 &amp;ldquo;is a&amp;rdquo;(~는 ~이다) 관계라고 부른다. Integer는 Object의 &amp;ldquo;is a&amp;rdquo;이므로 Integer 타입을 Object 타입에 할당이 가능하다. 하지만 Integer는 Number 타입에 &amp;ldquo;is a&amp;rdquo; 관계이다. 그러므로 아래의 코드는 잘 동작한다.
&lt;code&gt;In object-oriented terminology, this is called an &amp;quot;is a&amp;quot; relationship. Since an Integer is a kind of Object, the assignment is allowed. But Integer is also a kind of Number, so the following code is valid as well:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void someMethod(Number n) { /* ... */ }

someMethod(new Integer(10));   // OK
someMethod(new Double(10.1));   // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 룰은 generics도 마찬가지다. generic 타입을 호출할때, 타입인자가 Number 타입과 호환되는 &amp;ldquo;is a&amp;rdquo; 관계라면 Number 타입으로 타입인자를 전달한다.
&lt;code&gt;The same is also true with generics. You can perform a generic type invocation, passing Number as its type argument, and any subsequent invocation of add will be allowed if the argument is compatible with Number:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Number&amp;gt; box = new Box&amp;lt;Number&amp;gt;();
box.add(new Integer(10));   // OK
box.add(new Double(10.1));  // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래의 메서드를 살펴보자
&lt;code&gt;Now consider the following method:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void boxTest(Box&amp;lt;Number&amp;gt; n) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어떤 타입을 인자로 받을수 있을까? 메서드의 시그니처를 보면, Box&lt;Number&gt; 타입의 객체 하나를 인자로 받는 메서드이다. 그럼, Box&amp;lt;Integer&amp;gt;나 Box&amp;lt;Double&amp;gt;을 인자로 넣을수 있을까? 아니다! 왜냐하면 Box&amp;lt;Integer&amp;gt;, Box&amp;lt;Double&amp;gt;는 Box&amp;lt;Number&amp;gt;의 서브타입이 아니기 때문이다. (자바에서는 꺽쇠안에 Number 타입은 컴파일러가 is a관계를 파악하지 못한다. - 공변성, 반공변성쪽 내용 참조하면 좋은데 자바는 이를 지원 못함. 스칼라 언어 참조. 눈이 공부하다보면 팽팽 돔.)
&lt;code&gt;What type of argument does it accept? By looking at its signature, you can see that it accepts a single argument whose type is Box&amp;lt;Number&amp;gt;. But what does that mean? Are you allowed to pass in Box&amp;lt;Integer&amp;gt; or Box&amp;lt;Double&amp;gt;, as you might expect? The answer is &amp;quot;no&amp;quot;, because Box&amp;lt;Integer&amp;gt; and Box&amp;lt;Double&amp;gt; are not subtypes of Box&amp;lt;Number&amp;gt;.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이것은 generics를 공부할때 흔히 겪는 문제이다. 하지만 generic을 공부할때 중요한 컨셉이다.
&lt;code&gt;This is a common misunderstanding when it comes to programming with generics, but it is an important concept to learn.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../8-1.gif&#34; alt=&#34;Box&amp;lt;Integer&amp;gt; is not a subtype of Box&amp;lt;Number&amp;gt; even though Integer is a subtype of Number.&#34; /&gt;
&lt;br&gt;
Number의 서브타입인 Integer를 가진 Box&amp;lt;Integer&amp;gt;는 Box&amp;lt;Number&amp;gt;의 서브타입이 아니다.
&lt;code&gt;Box&amp;lt;Integer&amp;gt; is not a subtype of Box&amp;lt;Number&amp;gt; even though Integer is a subtype of Number.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;중요:  A와 B 두 구현타입을 제공할때(예를 들어 Number와 Integer),A와 B가 &amp;ldquo;is a&amp;rdquo; 관계가 있든 상관없이  MyClass&amp;lt;A&amp;gt;는 MyClass&amp;lt;B&amp;gt;와 더 이상 관계가 형성되지 않는다.
&lt;code&gt;Note: Given two concrete types A and B (for example, Number and Integer), MyClass&amp;lt;A&amp;gt; has no relationship to MyClass&amp;lt;B&amp;gt;, regardless of whether or not A and B are related. The common parent of MyClass&amp;lt;A&amp;gt; and MyClass&amp;lt;B&amp;gt; is Object.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;두 generic 클래스들간에 서브타입&lt;strong&gt;처럼&lt;/strong&gt; 타입매개변수가 관련있다라는 정보를 주려면(컴파일러에게), 와일드카드와 서브타이핑 항목을 보라
&lt;code&gt;For information on how to create a subtype-like relationship between two generic classes when the type parameters are related, see Wildcards and Subtyping.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;제네릭-클래스와-서브타이핑-generic-classes-and-subtyping&#34;&gt;제네릭 클래스와 서브타이핑 &lt;code&gt;Generic Classes and Subtyping&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic 클래스 상속 또는 generic 인터페이스 만들 때, 만드는 타입을 상속(또는 구현) 받은 부모  generic 타입의 서브 generic 타입(자식타입)으로 두 타입간에 관계(is a)를 만들수 있다.
&lt;code&gt;You can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the extends and implements clauses.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Collections 클래스들 사용할 때 예를 들면,  ArrayList&amp;lt;E&amp;gt;는 List&amp;lt;E&amp;gt;를 구현했고 List&amp;lt;E&amp;gt;는 Collection을 상속했다. 그러므로 ArrayList&amp;lt;String&amp;gt;은 List&amp;lt;String&amp;gt;의 서브타입이고 List&amp;lt;String&amp;gt;은 Collection&amp;lt;String&amp;gt;의 서브타입니다. 그럼 &amp;lt;String&amp;gt;이라는 형식인자를 변경하지 않으면 타입간 서브타이핑 관계가 유지된다.
&lt;code&gt;Using the Collections classes as an example, ArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, and List&amp;lt;E&amp;gt; extends Collection&amp;lt;E&amp;gt;. So ArrayList&amp;lt;String&amp;gt; is a subtype of List&amp;lt;String&amp;gt;, which is a subtype of Collection&amp;lt;String&amp;gt;. So long as you do not vary the type argument, the subtyping relationship is preserved between the types.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../8-2.gif&#34; alt=&#34;A sample Collections hierarchy&#34; /&gt;
&lt;br&gt;
콜렉션들간의 계층구조 예&lt;code&gt;sample Collections hierarchy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;PayloadList라는 인터페이스를 정의할 때 P라는 generic 타입을 메서드의 파라메터로 사용한다고했을때, 아래 코드와 같을 것이다.
&lt;code&gt;Now imagine we want to define our own list interface, PayloadList, that associates an optional value of generic type P with each element. Its declaration might look like:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface PayloadList&amp;lt;E,P&amp;gt; extends List&amp;lt;E&amp;gt; {
  void setPayload(int index, P val);
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;List&amp;lt;String&amp;gt;의 서브타입이면서 PayloadList가 타입인자로 전달할수 있는 것은 아래처럼 다양하게 볼수 있다.(일부임.)
&lt;code&gt;The following parameterizations of PayloadList are subtypes of List&amp;lt;String&amp;gt;:&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PayloadList&lt;String,String&gt;&lt;/li&gt;
&lt;li&gt;PayloadList&lt;String,Integer&gt;&lt;/li&gt;
&lt;li&gt;PayloadList&lt;String,Exception&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../8-3.gif&#34; alt=&#34;A sample PayloadList hierarchy&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(7) Java Generics: Generic 메서드와 제한된 타입 매개변수 (Generic Methods and Bounded Type Parameters)</title>
      <link>http://durtchrt.github.io/blog/java/generics/7/</link>
      <pubDate>Sat, 05 Nov 2016 08:24:47 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/7/</guid>
      <description>

&lt;h3 id=&#34;generic-메서드와-제한된-타입-매개변수-generic-methods-and-bounded-type-parameters&#34;&gt;Generic 메서드와 제한된 타입 매개변수 &lt;code&gt;Generic Methods and Bounded Type Parameters&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;제한된 타입 매개변수는 generic 알고리즘들을 구현할때 핵심이된다. 아래의 예는 두번째 인자보다 큰 값이 첫번째 인자인 배열에 몇개가 있는지 세는 메서드이다.
&lt;code&gt;Bounded type parameters are key to the implementation of generic algorithms. Consider the following method that counts the number of elements in an array T[] that are greater than a specified element elem.&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T&amp;gt; int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e &amp;gt; elem)  // compiler error
            ++count;
    return count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;메서드 구현은 간단하지만, &amp;lsquo;&amp;gt;&amp;rsquo; 연산자가 기본형(short, int, double, long, float, byte, char)에만 동작이 허용되기 때문이다. &amp;lsquo;&amp;gt;&amp;rsquo; 연산자는 객체간 비교에는 사용할 수 없습니다. 비교연산자 대신 Comparable&lt;T&gt;  인터페이스를 사용해서 문제를 해결할 수 있습니다.
&lt;code&gt;The implementation of the method is straightforward, but it does not compile because the greater than operator (&amp;gt;) applies only to primitive types such as short, int, double, long, float, byte, and char. You cannot use the &amp;gt; operator to compare objects. To fix the problem, use a type parameter bounded by the Comparable&amp;lt;T&amp;gt; interface:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Comparable&amp;lt;T&amp;gt; {
    public int compareTo(T o);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comparable 인터페이스가 적용된 결과 코드는 아래의 코드처럼 될 것입니다. &lt;code&gt;The resulting code will be:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e.compareTo(elem) &amp;gt; 0)
            ++count;
    return count;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(6) Java Generics: 제한된 타입 매개변수 (Bounded Type Parameters)</title>
      <link>http://durtchrt.github.io/blog/java/generics/6/</link>
      <pubDate>Fri, 04 Nov 2016 18:03:27 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/6/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/bounded.html&#34;&gt;원문 링크&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;제한된-타입-매개변수-bounded-type-parameters&#34;&gt;제한된 타입 매개변수 &lt;code&gt;Bounded Type Parameters&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;매개변수화된 타입에 타입인자를 넣을때 타입 제한을 걸고 싶을 때가 있을 것이다. 예를 들어, Number 타입 또는 Number 타입의 자식 클래스의 객체만 허용하는 숫자 처리를 위한 메서드를 만들 수 있다. 이것이 제한된 타입 매개변수다
&lt;code&gt;There may be times when you want to restrict the types that can be used as type arguments in a parameterized type. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. This is what bounded type parameters are for.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;제한된 타입매개변수를 선언하는 방법은, 타입매개변수의 이름 뒤에  extends 키워드를 놓고 제한시킬 타입을 작성하면 된다. 아래의 에에서는 Number 타입으로 하였다. 주의할점은, 여기서 사용한 extends는 클래스안의 &amp;ldquo;extends&amp;rdquo; 또는 인터페이스의 &amp;ldquo;implements&amp;rdquo; 처럼 구현한다는 의미는 아니다.
&lt;code&gt;To declare a bounded type parameter, list the type parameter&#39;s name, followed by the extends keyword, followed by its upper bound, which in this example is Number. Note that, in this context, extends is used in a general sense to mean either &amp;quot;extends&amp;quot; (as in classes) or &amp;quot;implements&amp;quot; (as in interfaces).&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Box&amp;lt;T&amp;gt; {

    private T t;

    public void set(T t) {
        this.t = t;
    }

    public T get() {
        return t;
    }

    public &amp;lt;U extends Number&amp;gt; void inspect(U u){
        System.out.println(&amp;quot;T: &amp;quot; + t.getClass().getName());
        System.out.println(&amp;quot;U: &amp;quot; + u.getClass().getName());
    }

    public static void main(String[] args) {
        Box&amp;lt;Integer&amp;gt; integerBox = new Box&amp;lt;Integer&amp;gt;();
        integerBox.set(new Integer(10));
        integerBox.inspect(&amp;quot;some text&amp;quot;); // error: this is still String!
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generic Box 클래스는 제한된 타입 파라메터를 가진 메서드인 inspect를 포함하도록 기존 코드를 수정하였다. inspect 메서드 호출시에 String 타입을 인자로 받았기 때문에 컴파일이 실패할 것이다.
&lt;code&gt;By modifying our generic method to include this bounded type parameter, compilation will now fail, since our invocation of inspect still includes a String:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Box.java:21: &amp;lt;U&amp;gt;inspect(U) in Box&amp;lt;java.lang.Integer&amp;gt; cannot
  be applied to (java.lang.String)
                        integerBox.inspect(&amp;quot;10&amp;quot;);
                                  ^
1 error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결론은 generic 타입을 객체로 만들때 제한을 걸수 있다. 제한된 타입 매개변수는 정의된 제한된 범위 내에서 메서드를 호출 할 수 있다.
&lt;code&gt;In addition to limiting the types you can use to instantiate a generic type, bounded type parameters allow you to invoke methods defined in the bounds:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class NaturalNumber&amp;lt;T extends Integer&amp;gt; {

    private T n;

    public NaturalNumber(T n)  { this.n = n; }

    public boolean isEven() {
        return n.intValue() % 2 == 0;
    }

    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;isEven 메서드는 변수 n에 타입인자로 전달된 Integer 타입에 정의된 intValue 메서드를 호출한다.
&lt;code&gt;The isEven method invokes the intValue method defined in the Integer class through n.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;여러번-제한하기-multiple-bounds&#34;&gt;여러번 제한하기 &lt;code&gt;Multiple Bounds&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;이전까지 예제는 하나만 제한한 타입매개변수를 사용한 것만 설명했지만, 타입 매개변수는 여러개를 제한할 수 있다.
&lt;code&gt;The preceding example illustrates the use of a type parameter with a single bound, but a type parameter can have multiple bounds:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;T extends B1 &amp;amp; B2 &amp;amp; B3&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여러개의 제한들로 구성된 타입매개변수는 제한하려 나열한 모든 타입들의 서브타입이다.(굳이 class라고 안하고 타입이란 용어를 쓰는건 interface를 포함하는 단어가 아니기 때문이다. 클래스는 타입의 부분) 제한된 타입중 하나가 class라면, class는 열거되는 타입들중 처음에 작성해야한다. 예를 들면:
&lt;code&gt;A type variable with multiple bounds is a subtype of all the types listed in the bound. If one of the bounds is a class, it must be specified first. For example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Class A { /* ... */ }
interface B { /* ... */ }
interface C { /* ... */ }

class D &amp;lt;T extends A &amp;amp; B &amp;amp; C&amp;gt; { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 A라는 제한 class가 다른 제한 클래스들중 처음에 위치하지 않으면, 컴파일타임 에러를 발생된다.
&lt;code&gt;If bound A is not specified first, you get a compile-time error:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class D &amp;lt;T extends B &amp;amp; A &amp;amp; C&amp;gt; { /* ... */ }  // compile-time error
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(5) Java Generics: 제네릭 메서드</title>
      <link>http://durtchrt.github.io/blog/java/generics/5/</link>
      <pubDate>Fri, 04 Nov 2016 13:43:44 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/5/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/methods.html&#34;&gt;원문 링크&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;generic-메서드-generic-methods&#34;&gt;Generic 메서드 &lt;code&gt;Generic Methods&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Generic 메서드는 자시의 타입매개변수를 가진 메서드이다. generic 타입을 선언하는 것과 비슷하지만 타입매개변수의 스코프는 메서드로 제한된다. 일반 메서드, 정적 메서드 generic 클래스의 생성자는 이 룰을 동일하게 적용된다.
&lt;code&gt;Generic methods are methods that introduce their own type parameters. This is similar to declaring a generic type, but the type parameter&#39;s scope is limited to the method where it is declared. Static and non-static generic methods are allowed, as well as generic class constructors.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;generic 메서드 문법은 return 타입 전에 꺽쇠 사이에 타입매개변수를 표기한다. static generic 메서드를 위해 타입매개변수는 반드시 메서드의 return 타입 이전에 위치해야한다.
&lt;code&gt;The syntax for a generic method includes a type parameter, inside angle brackets, and appears before the method&#39;s return type. For static generic methods, the type parameter section must appear before the method&#39;s return type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Util 클래스는 두 Pair 객체를 비교하는 generic 메서드를 포함하고 있습니다.
&lt;code&gt;The Util class includes a generic method, compare, which compares two Pair objects:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Util {
    public static &amp;lt;K, V&amp;gt; boolean compare(Pair&amp;lt;K, V&amp;gt; p1, Pair&amp;lt;K, V&amp;gt; p2) {
        return p1.getKey().equals(p2.getKey()) &amp;amp;&amp;amp;
               p1.getValue().equals(p2.getValue());
    }
}

public class Pair&amp;lt;K, V&amp;gt; {

    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public void setKey(K key) { this.key = key; }
    public void setValue(V value) { this.value = value; }
    public K getKey()   { return key; }
    public V getValue() { return value; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 메서드를(static &lt;K, V&gt; boolean compare)를 호출한 문장은 다음과 같다.
&lt;code&gt;The complete syntax for invoking this method would be:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Pair&amp;lt;Integer, String&amp;gt; p1 = new Pair&amp;lt;&amp;gt;(1, &amp;quot;apple&amp;quot;);
Pair&amp;lt;Integer, String&amp;gt; p2 = new Pair&amp;lt;&amp;gt;(2, &amp;quot;pear&amp;quot;);
boolean same = Util.&amp;lt;Integer, String&amp;gt;compare(p1, p2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Util.&lt;strong&gt;&amp;lt;Integer, String&amp;gt;&lt;/strong&gt;compare(p1, p2)&lt;br&gt;
강조한 영역처럼 타입을 명시하였다. 타입인자는 컴파일러가 타입 추론할때 필요한 정보가 된다.
&lt;code&gt;The type has been explicitly provided, as shown in bold. Generally, this can be left out and the compiler will infer the type that is needed:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Pair&amp;lt;Integer, String&amp;gt; p1 = new Pair&amp;lt;&amp;gt;(1, &amp;quot;apple&amp;quot;);
Pair&amp;lt;Integer, String&amp;gt; p2 = new Pair&amp;lt;&amp;gt;(2, &amp;quot;pear&amp;quot;);
boolean same = Util.compare(p1, p2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 코드는 타입 추론을 나타낸것이다. 꺽쇠에 타입 명시하지 않고 generic 메서드가 아닌 일반 메서드를 호출해도 타입 추론이 이루어진다. 이 주제는 뒤에 나오는 타입 추론 섹션에서 더 논의한다.
&lt;code&gt;This feature, known as type inference, allows you to invoke a generic method as an ordinary method, without specifying a type between angle brackets. This topic is further discussed in the following section, Type Inference.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(4) Java Generics: 원천(Raw) 타입들</title>
      <link>http://durtchrt.github.io/blog/java/generics/4/</link>
      <pubDate>Tue, 01 Nov 2016 16:05:56 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/4/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&#34;&gt;원문 링크&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;원천-타입들-raw-types&#34;&gt;원천 타입들 &lt;code&gt;Raw Types&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Raw 타입은 generic 클래스 혹은 인터페이스에 타입인자가 없는 것. 예를들어 generic Box 클래스를 보자
&lt;code&gt;A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Box&amp;lt;T&amp;gt; {
    public void set(T t) { /* ... */ }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래 코드를 보면 Box&lt;T&gt;의 매개변수화된 타입을 만드면서, 타입매개변수 T에 해당하는 Integer를 타입인자로 제공하였다.
&lt;code&gt;To create a parameterized type of Box&amp;lt;T&amp;gt;, you supply an actual type argument for the formal type parameter T:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Integer&amp;gt; intBox = new Box&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;타입인자가 생략된 경우 Box&lt;T&gt;의 Raw 타입을 만들수 있다.
&lt;code&gt;If the actual type argument is omitted, you create a raw type of Box&amp;lt;T&amp;gt;:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box rawBox = new Box();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결국, Box는 generic 타입 Box&lt;T&gt;의 raw 타입이다. 하지만, generic 클래스 또는 인터페이스가 아닌경우는 raw 타입이 될 수 없다.()
&lt;code&gt;Therefore, Box is the raw type of the generic type Box&amp;lt;T&amp;gt;. However, a non-generic class or interface type is not a raw type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Raw 타입은 JDK 5.0 이전 자바 API 클래스들은 제네릭을 지원하지 않았기 때문에(예를 들어 Collections 클래스) 레거시 코드에서 나타난다. raw 타입을 사용할 때는 반드시 generics 이전 방법(타입 캐스팅)을 하시오. 하위호환성을 위해, 타입매개변수는 raw타입을 허용하였다.
&lt;code&gt;Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior — a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;String&amp;gt; stringBox = new Box&amp;lt;&amp;gt;();
Box rawBox = stringBox;               // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;하지만 타입매개변수에 raw 타입을 할당하면 (컴파일러로부터) 경고를 받습니다.
&lt;code&gt;But if you assign a raw type to a parameterized type, you get a warning:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box rawBox = new Box();           // rawBox is a raw type of Box&amp;lt;T&amp;gt;
Box&amp;lt;Integer&amp;gt; intBox = rawBox;     // warning: unchecked conversion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;또한 generic 타입에 정의된 generic 메서드를 호출할때에도 raw 타입을 사용하면 경고를 받습니다.
&lt;code&gt;You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;String&amp;gt; stringBox = new Box&amp;lt;&amp;gt;();
Box rawBox = stringBox;
rawBox.set(8);  // warning: unchecked invocation to set(T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;경고는 raw 타입들이 generic 타입체크를 할수 없다는 것을 보여줍니다. (컴파일 타임에 체크될 수 있는) 불안한 코드가 런타임에 붙잡히게 (컴파일 타임 체킹을 런타임으로) 딜레이 시키는 것이므로 raw 타입 사용은 피하는것이 좋을 것이다.&lt;br /&gt;
&lt;code&gt;The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;타입소거 섹션에서는 자바 컴파일러가 raw 타입을 사용하는 것에 대한 더 자세한 설명이 있다.
&lt;code&gt;The Type Erasure section has more information on how the Java compiler uses raw types.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;unchecked-error-messages&#34;&gt;Unchecked Error Messages&lt;/h3&gt;

&lt;p&gt;이전에 말햇듯, generic 코드와 레거시 코드를 섞게 되면, 아래와 같은 경고 메세지를 마주칠 것이다.
&lt;code&gt;As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Note: Example.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;This can happen when using an older API that operates on raw types, as shown in the following example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WarningDemo {
    public static void main(String[] args){
        Box&amp;lt;Integer&amp;gt; bi;
        bi = createBox();
    }

    static Box createBox(){
        return new Box();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;unchecked(체크되지 않음)&amp;ldquo;는 타입 안정성을 보장하기 위해 필요한 타입체크 정보가 충분치 않다는 것을 의미한다. &amp;ldquo;unchecked&amp;rdquo; 경고는 컴파일러에게 기본 설정으로는 사용하지 않는다.&amp;ldquo;unchecked&amp;rdquo; 경고를 보고 싶다면 -Xlint:unchecked옵션을 주고 다시 컴파일하면 모든 &amp;ldquo;unchecked&amp;rdquo; 경고를 볼 수 있다.
&lt;code&gt;The term &amp;quot;unchecked&amp;quot; means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The &amp;quot;unchecked&amp;quot; warning is disabled, by default, though the compiler gives a hint. To see all &amp;quot;unchecked&amp;quot; warnings, recompile with -Xlint:unchecked.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;-Xlint:unchecked 옵션과 함께 예제를 다시 컴파일해보면 아래에 보이는 내용이 나타날 것이다.
&lt;code&gt;Recompiling the previous example with -Xlint:unchecked reveals the following additional information:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;WarningDemo.java:4: warning: [unchecked] unchecked conversion
found   : Box
required: Box&amp;lt;java.lang.Integer&amp;gt;
        bi = createBox();
                      ^
1 warning
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;컴파일 옵션에 -Xlint:-unchecked 플래그를 사용하면 unchecked 경고를 없앨 수 있다. @SupporessWarnings(&amp;ldquo;unchecked&amp;rdquo;) 어노테이션은 unchecked 경고가 나타나지 않게 할 수 있다. @SupressWarnings 문법이 생소하면 Annotations 섹션을 보시오. &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/annotations/index.html&#34;&gt;링크&lt;/a&gt;
&lt;code&gt;To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The @SuppressWarnings(&amp;quot;unchecked&amp;quot;) annotation suppresses unchecked warnings. If you are unfamiliar with the @SuppressWarnings syntax, see Annotations.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;역자 첨부&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ javac WarningDemo.java 

Note: WarningDemo.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
    
$ javac -Xlint:unchecked WarningDemo.java

WarningDemo.java:7: warning: [unchecked] unchecked conversion
        bi = createBox();
                      ^
required: Box&amp;lt;Integer&amp;gt;
found:    Box
1 warning
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(3) Java Generics: 제네릭 타입들</title>
      <link>http://durtchrt.github.io/blog/java/generics/3/</link>
      <pubDate>Mon, 31 Oct 2016 17:08:57 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/3/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/types.html&#34;&gt;원문 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;용어 참조&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;타입 : 자바에서는 클래스, 추상클래스, 인터페이스, 열거형(Enum), 배열을 의미. 기본형, 참조형을 포괄하는 개념

&lt;ul&gt;
&lt;li&gt;기본형: byte, short, int, long, float, double, char, String, boolean (call by value)&lt;/li&gt;
&lt;li&gt;참조형: 기본형을 제외한 모든 타입 (call by reference)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;매개변수 vs 인자&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;매개변수(Parameter): 함수 선언할 때 변수의 이름&lt;/li&gt;
&lt;li&gt;인자(Argument): 함수를 호출할 때 전달하는 값&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;generic-types&#34;&gt;Generic Types&lt;/h3&gt;

&lt;p&gt;generic 타입은 클래스, 인터페이스를 타입 파라미터화하는 것이다. Box 클래스는 generic  타입을 설명하면서 코드를 수정할 것이다.
&lt;code&gt;A generic type is a generic class or interface that is parameterized over types. The following Box class will be modified to demonstrate the concept.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-simple-box-class&#34;&gt;A Simple Box Class&lt;/h3&gt;

&lt;p&gt;generic을 사용하지 않은 예제로 시작해봅시다. Box 클래스는 set(추가), get(조회) 2개의 메서드가 있습니다.
&lt;code&gt;Begin by examining a non-generic Box class that operates on objects of any type. It needs only to provide two methods: set, which adds an object to the box, and get, which retrieves it:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Box {
    private Object object;

    public void set(Object object) { this.object = object; }
    public Object get() { return object; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;객체의 set, get 메서드는 기본형을 제외하면 어떤 타입(참조형)이든 인자로 넣을수 있다. Box 클래스가 사용되어지지만 컴파일 타임에 검증할 방법이 없다. 코드 일부분에서는 Integer를 넣고 Integer가 return되어지길 기대하지만 다른 일부분에서는 실수로 String을 입력해서 런타임 에러가 나올 것이다.
&lt;code&gt;Since its methods accept or return an Object, you are free to pass in whatever you want, provided that it is not one of the primitive types. There is no way to verify, at compile time, how the class is used. One part of the code may place an Integer in the box and expect to get Integers out of it, while another part of the code may mistakenly pass in a String, resulting in a runtime error.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;generic-버전의-box-클래스-br&#34;&gt;Generic 버전의 Box 클래스.&lt;br&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;A Generic Version of the Box Class&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;generic 클래시는 아래 포멧처럼 정의되었다.&lt;br&gt;
&lt;code&gt;A generic class is defined with the following format:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class name&amp;lt;T1, T2, ..., Tn&amp;gt; { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;타입 파라미터 문법은 클래스명 뒤에 꺽쇠(&amp;lt;&amp;gt;) 기호로 구분된다. 이것은 T1, T2, &amp;hellip;, and Tn 등으로 타입 매개변수를 명시한다.(타입변수라고 불리기도한다.)
&lt;code&gt;The type parameter section, delimited by angle brackets (&amp;lt;&amp;gt;), follows the class name. It specifies the type parameters (also called type variables) T1, T2, ..., and Tn.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Box 클래스를 generics로 변경해보자. &amp;ldquo;public class Box&amp;rdquo; 코드를 &amp;ldquo;public class Box&lt;T&gt;&amp;ldquo;로 변경해서 generic 타입을 선언하여 만든다. T라는 타입 매개변수는 클래스 어디든지 사용할 수 있는 변수이다.
&lt;code&gt;To update the Box class to use generics, you create a generic type declaration by changing the code &amp;quot;public class Box&amp;quot; to &amp;quot;public class Box&amp;lt;T&amp;gt;&amp;quot;. This introduces the type variable, T, that can be used anywhere inside the class.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Box 클래스가 이렇게 바뀐다.&lt;br&gt;
&lt;code&gt;With this change, the Box class becomes:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Generic version of the Box class.
 * @param &amp;lt;T&amp;gt; the type of the value being boxed
 */
public class Box&amp;lt;T&amp;gt; {
    // T stands for &amp;quot;Type&amp;quot;
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;소스 코드 변경에서 보이듯, 기존 코드에서 Object 대신 T로 수정되었다. Type 변수는 기본형 빼고는(=참조형)이면 된다.(클래스/인터페이스/배열 타입 또는 다른 Type 변수가 Type 변수로 될 수 있다.)
&lt;code&gt;As you can see, all occurrences of Object are replaced by T. A type variable can be any non-primitive type you specify: any class type, any interface type, any array type, or even another type variable.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;generic 인터페이스를 만드는 방법도 같다.
&amp;lsquo;This same technique can be applied to create generic interfaces.&amp;rsquo;&lt;/p&gt;

&lt;h3 id=&#34;type-파라미터-네이밍-관습&#34;&gt;Type 파라미터 네이밍 관습&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Type Parameter Naming Conventions&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;관습에 의하면, Type 파라미터는 단일 대문자입니다. 이 기준은 이미 알고 있는 변수 네이밍 관습에 극명하게 반대입니다. (좋은점은)이런 관습이 없으면 Type 변수와 일반적인 클래스 혹은 인터페이스명 사이에 차이를 전달하기 어려울겁니다.
&lt;code&gt;By convention, type parameter names are single, uppercase letters. This stands in sharp contrast to the variable naming conventions that you already know about, and with good reason: Without this convention, it would be difficult to tell the difference between a type variable and an ordinary class or interface name.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;일반적으로 사용되어지는 Type파라미터명&lt;br&gt;
&lt;code&gt;The most commonly used type parameter names are:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E - Element (자바 콜렉션 프레인워크에 광범위하게 사용됨 - used extensively by the Java Collections Framework)
K - Key
N - Number
T - Type
V - Value
S,U,V etc. - 2nd, 3rd, 4th types
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이러한 이름들이 자바SE API을 통해 쓰여지는 것을 볼 수 있을 것입니다.
&lt;code&gt;You&#39;ll see these names used throughout the Java SE API and the rest of this lesson.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;generic-type-호출과-객체-생성&#34;&gt;Generic Type 호출과 객체 생성&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Invoking and Instantiating a Generic Type&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;코드내에 generic Box 클래스를 참조하려면, generic Type을 호출해 Integer 같은 구현값(타입값)으로 T를 교체합니다.
&lt;code&gt;To reference the generic Box class from within your code, you must perform a generic type invocation, which replaces T with some concrete value, such as Integer:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Integer&amp;gt; integerBox;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;흔한 메소드 호출과 generic type 호출이 비슷하고 생각할 수 있다. 하지만 &lt;strong&gt;메소드&lt;/strong&gt;에 인자를 전달하는 반면에 Box &lt;strong&gt;클래스&lt;/strong&gt;에 type 인자를 전달한다(이번에는 Integer임).
&lt;code&gt;You can think of a generic type invocation as being similar to an ordinary method invocation, but instead of passing an argument to a method, you are passing a type argument — Integer in this case — to the Box class itself.&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;Type 파라미터&#39;, &#39;Type 인자&#39; 용어 설명: 많은 개발자들은 &amp;quot;type 파라미터&amp;quot;와 &amp;quot;type 인자&amp;quot;를 혼용해서 사용한다. 하지만 이 용어나 같지 않다. 코딩할 때 파라미터화한 type을 생성하기 위해서 type인자를 만든다. 그 결과, Foo&amp;lt;T&amp;gt;의 T는 Type 파라미터이고 Foo&amp;lt;String&amp;gt;의 String은  Type 인자이다. 이번장에서 Type 인자와 Type 파라미터를 사용할 때 위에 설명한 내용을 상기하고 살펴봅시다.

`Type Parameter and Type Argument Terminology: Many developers use the terms &amp;quot;type parameter&amp;quot; and &amp;quot;type argument&amp;quot; interchangeably, but these terms are not the same. When coding, one provides type arguments in order to create a parameterized type. Therefore, the T in Foo&amp;lt;T&amp;gt; is a type parameter and the String in Foo&amp;lt;String&amp;gt; f is a type argument. This lesson observes this definition when using these terms.`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다른 변수를 선언하듯이, 이 코드는 새로운 Box 객체를 실제로 생성하지 않습니다. 간단히 말하면 integerBox 변수는 &amp;ldquo;Integer 타입의 Box 클래스&amp;rdquo;를 가리킨다.( Box&lt;Integer&gt;는 &amp;ldquo;Box of Integer&amp;rdquo;라고 읽는다.)
Like any other variable declaration, this code does not actually create a new Box object. It simply declares that integerBox will hold a reference to a &amp;ldquo;Box of Integer&amp;rdquo;, which is how Box&lt;Integer&gt; is read.&lt;/p&gt;

&lt;p&gt;generic 타입 호출은 일반적으로 파라미터화된 type으로 알려져 있다.
&lt;code&gt;An invocation of a generic type is generally known as a parameterized type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;클래스를 객체화할때 사용하는 new 키워드는 기존과 같지만 Generics를 위한 표기법으로  &lt;strong&gt;&lt;Integer&gt;&lt;/strong&gt;가 클래스명과 소괄호(()) 사이에 있다.
&lt;code&gt;To instantiate this class, use the new keyword, as usual, but place &amp;lt;Integer&amp;gt; between the class name and the parenthesis:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Integer&amp;gt; integerBox = new Box&amp;lt;Integer&amp;gt;();
````
### 다이아몬드 연산자(&amp;lt;&amp;gt;) `The Diamond`

자바SE 7부터 컴파일러가 코드의 문맥을 보고 타입을 추론 할수 있게 되어 타입 인자가 필요한 부분에 empty type argument(빈 type 인자 = &amp;lt;&amp;gt;)를 사용할 수 있다. 꺽쇠(&amp;lt;&amp;gt;)는 비공식적이지만 다이아몬드라고 불린다. 예를 들면, Box&amp;lt;Integer&amp;gt; 객체를 생성할때 아래의 문법을 따른다:
`In Java SE 7 and later, you can replace the type arguments required to invoke the constructor of a generic class with an empty set of type arguments (&amp;lt;&amp;gt;) as long as the compiler can determine, or infer, the type arguments from the context. This pair of angle brackets, &amp;lt;&amp;gt;, is informally called the diamond. For example, you can create an instance of Box&amp;lt;Integer&amp;gt; with the following statement:`

```java
Box&amp;lt;Integer&amp;gt; integerBox = new Box&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다이아몬드 표기법과 타입 추론에 대한 더 자세한 정보는 타입 추론을 보시오.
&lt;code&gt;For more information on diamond notation and type inference, see Type Inference.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;복수개의-타입매개변수&#34;&gt;복수개의 타입매개변수&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Multiple Type Parameters&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이전에 말했듯이, generic 클래스는 여러개의 타입매개변수를 가질수 있다. 예를들어, generic OrderdPair클래스는 generic Pair 인터페이스를 구현하였다.
&lt;code&gt;As mentioned previously, a generic class can have multiple type parameters. For example, the generic OrderedPair class, which implements the generic Pair interface:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Pair&amp;lt;K, V&amp;gt; {
    public K getKey();
    public V getValue();
}

public class OrderedPair&amp;lt;K, V&amp;gt; implements Pair&amp;lt;K, V&amp;gt; {

    private K key;
    private V value;

    public OrderedPair(K key, V value) {
	this.key = key;
	this.value = value;
    }

    public K getKey()	{ return key; }
    public V getValue() { return value; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래는 OrderedPair클래스로 두개의 객체를 만드는 코드이다.
&lt;code&gt;The following statements create two instantiations of the OrderedPair class:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Pair&amp;lt;String, Integer&amp;gt; p1 = new OrderedPair&amp;lt;String, Integer&amp;gt;(&amp;quot;Even&amp;quot;, 8);
Pair&amp;lt;String, String&amp;gt;  p2 = new OrderedPair&amp;lt;String, String&amp;gt;(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;코드는 OrderedPair&lt;String, Integer&gt; 객체를 생성하면, K는 String 타입이고 V는 Integer 타입이다. Orderedpair의 생성자의 파라미터 타입들은 String, Integer이다.  autoboxing을 통해 String과 int를 OrderedPair클래스에 전달해도 문제없다.(참조형은 상관 없는데 기본형인 int는 참조형으로 변경되어야한다. int -&amp;gt; Integer) 
&lt;code&gt;The code, new OrderedPair&amp;lt;String, Integer&amp;gt;, instantiates K as a String and V as an Integer. Therefore, the parameter types of OrderedPair&#39;s constructor are String and Integer, respectively. Due to autoboxing, it is valid to pass a String and an int to the class.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이전에 다아몬드 연산자를 언급했듯이, 자바 컴파일러는 OrderedPair&lt;String, Integer&gt;로 선언한 K, V 타입을 추론 할수 있기 때문에 다이아몬드문법을 사용해서 코드를 줄일수 있다.
&lt;code&gt;As mentioned in The Diamond, because a Java compiler can infer the K and V types from the declaration OrderedPair&amp;lt;String, Integer&amp;gt;, these statements can be shortened using diamond notation:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;OrderedPair&amp;lt;String, Integer&amp;gt; p1 = new OrderedPair&amp;lt;&amp;gt;(&amp;quot;Even&amp;quot;, 8);
OrderedPair&amp;lt;String, String&amp;gt;  p2 = new OrderedPair&amp;lt;&amp;gt;(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generic 인터페이스를 생성하는것은 generic 클래스를 만드는 방법과 같다
&lt;code&gt;To create a generic interface, follow the same conventions as for creating a generic class.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;타입-파라미터화&#34;&gt;타입 파라미터화&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Parameterized Types&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;매개변수타입(예 K, V)은  매개변수화된 타입(예 List&lt;String&gt;)으로 대체할 수 있다. OrderedPair&lt;K, V&gt;를 예를 들면:
&lt;code&gt;You can also substitute a type parameter (i.e., K or V) with a parameterized type (i.e., List&amp;lt;String&amp;gt;). For example, using the OrderedPair&amp;lt;K, V&amp;gt; example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;OrderedPair&amp;lt;String, Box&amp;lt;Integer&amp;gt;&amp;gt; p = new OrderedPair&amp;lt;&amp;gt;(&amp;quot;primes&amp;quot;, new Box&amp;lt;Integer&amp;gt;(...));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 코드에서 매개변수화된 타입(Parameterized Type)은 위의 소스에서는 &lt;strong&gt;Box&amp;lt;Integer&amp;gt;&lt;/strong&gt;을 의미&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(2) Java Generics: 제네릭스는 왜 사용하는가? </title>
      <link>http://durtchrt.github.io/blog/java/generics/2/</link>
      <pubDate>Mon, 31 Oct 2016 15:52:48 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/2/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/why.html&#34;&gt;원문&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Generics는 왜 사용하는가&lt;/strong&gt;  (Why Use Generics?)&lt;/p&gt;

&lt;p&gt;간단히 말하면, generics는 타입을 클래스, 인터페이스, 메소드를 정의할 때 파라메터화 할 수 있다. 메소드 선언에 사용되는 파라미터 형식처럼, 타입 파라미터는 다른 입력값을 같은 코드를 재 사용할 수 있는 방법을 제시한다. 다른점은 형식 파라미터는 값이 입력이다, 타입 파라메터는 타입이 입력이다.
&lt;code&gt;In a nutshell, generics enable types (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar formal parameters used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to type parameters are types.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;generic를 사용한 코드는 그렇지 않는 코드 대비 많은 장점을 가졌다:
&lt;code&gt;Code that uses generics has many benefits over non-generic code&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;컴파일 타임에 강력한 타입 체크를한다.
&lt;code&gt;Stronger type checks at compile time.&lt;/code&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자바 컴파일러는 타입 안전성에 위반하는 코드가 있다면 일반적인 코드와 오류 이슈에 강한 타입 검사를 적용한다. 컴파일타임에 에러를 고치는 것은 런타임 에러를 고치는 것 보다 쉽다.&lt;br /&gt;
&lt;code&gt;A Java compiler applies strong type checking to generic code and issues errors if the code violates type safety. Fixing compile-time errors is easier than fixing runtime errors, which can be difficult to find.&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Elimination of casts. &lt;br/&gt;
generics 없이 캐스팅이 필요한 코드 조각입니다.
&lt;code&gt;The following code snippet without generics requires casting:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List list = new ArrayList();
list.add(&amp;quot;hello&amp;quot;);
String s = (String) list.get(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generics를 사용해서 코드를 다시 작성하면, 코드는 더이상 캐스팅이 필요 없어집니다.
&lt;code&gt;When re-written to use generics, the code does not require casting:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
list.add(&amp;quot;hello&amp;quot;);
String s = list.get(0);   // no cast
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;프로그래머들이 일반적인 알고리즘을 구현하도록 지원한다.&lt;br&gt;
generics를 사용하면서 프로그래머들은 다양한 타입들의 콜렉션에서 동작하고, 수정가능하며, 더 안정적이고 읽기 쉬운 코드를 일반적인 알고리즘으로 구현할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Enabling programmers to implement generic algorithms.
By using generics, programmers can implement generic algorithms that work on collections of different types, can be customized, and are type safe and easier to read.&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>자바 제네릭스(1) Java  Generics</title>
      <link>http://durtchrt.github.io/blog/java/generics/1/</link>
      <pubDate>Mon, 31 Oct 2016 15:07:44 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/1/</guid>
      <description>

&lt;h1 id=&#34;자바-제넥릭스-java-generics-1&#34;&gt;자바 제넥릭스 - Java Generics 1&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/index.html&#34;&gt;원본&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-java-tutorials&#34;&gt;The Java Tutorials&lt;/h2&gt;

&lt;h3 id=&#34;lesson-generics-updated&#34;&gt;Lesson: Generics(Updated)&lt;/h3&gt;

&lt;p&gt;소프트웨어에서 버그는 일상이다. &lt;del&gt;모든 사소하지 않은 소프트웨어 프로젝트에서 버그는 삶의 진실이다.&lt;/del&gt; 주의깊게 계획, 프로그래밍, 테스트는 버그가 스며드는것을 줄여준다. 하지만 여찌됐든, 언젠가! 버그는 코드에서 기어다닐 방법을 항상 찾는다. 이는 결국 새로운 기능이 도입되거나 코드 사이즈와 복잡섭이 증가됨에 따라 심각하게 눈에 띄게 될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;In any nontrivial software project, bugs are simply a fact of life. Careful planning, programming, and testing can help reduce their pervasiveness, but somehow, somewhere, they&#39;ll always find a way to creep into your code. This becomes especially apparent as new features are introduced and your code base grows in size and complexity.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;운좋게 몇몇 버그는 찾기 쉽다. 예를들어, 컴파일 타임 버그는 초기에 찾을 수 있다. 컴파일러의 에러 메세지를 이용하여 문제점을 발견하고 바로 거기서 고칠수 있다. 반면에 런타임 버그는 훨씬 더 해결이 어렵다. 런타임 버그는 겉으로 직접 나타나지 않으며, 버그가 동작할 때, 그것은 프로그램에서 실제 문제의 원인에서 멀리 떨어진 지점에 있을 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Fortunately, some bugs are easier to detect than others. Compile-time bugs, for example, can be detected early on; you can use the compiler&#39;s error messages to figure out what the problem is and fix it, right then and there. Runtime bugs, however, can be much more problematic; they don&#39;t always surface immediately, and when they do, it may be at a point in the program that is far removed from the actual cause of the problem.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Generics는 컴파일 타임에 버그를 찾을수 있게되어 코드에 안정성을 더합니다. 이 과정을 마친후에는 Gilad Bracha의 Generics 튜토리얼을 진행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Generics add stability to your code by making more of your bugs detectable at compile time. After completing this lesson, you may want to follow up with the Generics tutorial by Gilad Bracha.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>