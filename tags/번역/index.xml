<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ê°œë°œ ì €ì¥ì†Œ</title>
    <link>http://durtchrt.github.io/blog/tags/%EB%B2%88%EC%97%AD/index.xml</link>
    <description>Recent content on ê°œë°œ ì €ì¥ì†Œ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>durtchrt</copyright>
    <atom:link href="http://durtchrt.github.io/blog/tags/%EB%B2%88%EC%97%AD/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>java generics: ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ (Bounded Type Parameters)</title>
      <link>http://durtchrt.github.io/blog/java/generics/6/</link>
      <pubDate>Fri, 04 Nov 2016 18:03:27 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/6/</guid>
      <description>

&lt;h3 id=&#34;ì œí•œëœ-íƒ€ì…-ë§¤ê°œë³€ìˆ˜-bounded-type-parameters&#34;&gt;ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ &lt;code&gt;Bounded Type Parameters&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ë§¤ê°œë³€ìˆ˜í™”ëœ íƒ€ì…ì— íƒ€ì…ì¸ìë¥¼ ë„£ì„ë•Œ íƒ€ì… ì œí•œì„ ê±¸ê³  ì‹¶ì„ ë•Œê°€ ìˆì„ ê²ƒì´ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, Number íƒ€ì… ë˜ëŠ” Number íƒ€ì…ì˜ ìì‹ í´ë˜ìŠ¤ì˜ ê°ì²´ë§Œ í—ˆìš©í•˜ëŠ” ìˆ«ì ì²˜ë¦¬ë¥¼ ìœ„í•œ ë©”ì„œë“œë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤. ì´ê²ƒì´ ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ë‹¤
&lt;code&gt;There may be times when you want to restrict the types that can be used as type arguments in a parameterized type. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. This is what bounded type parameters are for.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì œí•œëœ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ëŠ” ë°©ë²•ì€, íƒ€ì…ë§¤ê°œë³€ìˆ˜ì˜ ì´ë¦„ ë’¤ì—  extends í‚¤ì›Œë“œë¥¼ ë†“ê³  ì œí•œì‹œí‚¬ íƒ€ì…ì„ ì‘ì„±í•˜ë©´ ëœë‹¤. ì•„ë˜ì˜ ì—ì—ì„œëŠ” Number íƒ€ì…ìœ¼ë¡œ í•˜ì˜€ë‹¤. ì£¼ì˜í• ì ì€, ì—¬ê¸°ì„œ ì‚¬ìš©í•œ extendsëŠ” í´ë˜ìŠ¤ì•ˆì˜ &amp;ldquo;extends&amp;rdquo; ë˜ëŠ” ì¸í„°í˜ì´ìŠ¤ì˜ &amp;ldquo;implements&amp;rdquo; ì²˜ëŸ¼ êµ¬í˜„í•œë‹¤ëŠ” ì˜ë¯¸ëŠ” ì•„ë‹ˆë‹¤.
&lt;code&gt;To declare a bounded type parameter, list the type parameter&#39;s name, followed by the extends keyword, followed by its upper bound, which in this example is Number. Note that, in this context, extends is used in a general sense to mean either &amp;quot;extends&amp;quot; (as in classes) or &amp;quot;implements&amp;quot; (as in interfaces).&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Box&amp;lt;T&amp;gt; {

    private T t;

    public void set(T t) {
        this.t = t;
    }

    public T get() {
        return t;
    }

    public &amp;lt;U extends Number&amp;gt; void inspect(U u){
        System.out.println(&amp;quot;T: &amp;quot; + t.getClass().getName());
        System.out.println(&amp;quot;U: &amp;quot; + u.getClass().getName());
    }

    public static void main(String[] args) {
        Box&amp;lt;Integer&amp;gt; integerBox = new Box&amp;lt;Integer&amp;gt;();
        integerBox.set(new Integer(10));
        integerBox.inspect(&amp;quot;some text&amp;quot;); // error: this is still String!
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generic Box í´ë˜ìŠ¤ëŠ” ì œí•œëœ íƒ€ì… íŒŒë¼ë©”í„°ë¥¼ ê°€ì§„ ë©”ì„œë“œì¸ inspectë¥¼ í¬í•¨í•˜ë„ë¡ ê¸°ì¡´ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì˜€ë‹¤. inspect ë©”ì„œë“œ í˜¸ì¶œì‹œì— String íƒ€ì…ì„ ì¸ìë¡œ ë°›ì•˜ê¸° ë•Œë¬¸ì— ì»´íŒŒì¼ì´ ì‹¤íŒ¨í•  ê²ƒì´ë‹¤.
&lt;code&gt;By modifying our generic method to include this bounded type parameter, compilation will now fail, since our invocation of inspect still includes a String:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Box.java:21: &amp;lt;U&amp;gt;inspect(U) in Box&amp;lt;java.lang.Integer&amp;gt; cannot
  be applied to (java.lang.String)
                        integerBox.inspect(&amp;quot;10&amp;quot;);
                                  ^
1 error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê²°ë¡ ì€ generic íƒ€ì…ì„ ê°ì²´ë¡œ ë§Œë“¤ë•Œ ì œí•œì„ ê±¸ìˆ˜ ìˆë‹¤. ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” ì •ì˜ëœ ì œí•œëœ ë²”ìœ„ ë‚´ì—ì„œ ë©”ì„œë“œë¥¼ í˜¸ì¶œ í•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;In addition to limiting the types you can use to instantiate a generic type, bounded type parameters allow you to invoke methods defined in the bounds:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class NaturalNumber&amp;lt;T extends Integer&amp;gt; {

    private T n;

    public NaturalNumber(T n)  { this.n = n; }

    public boolean isEven() {
        return n.intValue() % 2 == 0;
    }

    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;isEven ë©”ì„œë“œëŠ” ë³€ìˆ˜ nì— íƒ€ì…ì¸ìë¡œ ì „ë‹¬ëœ Integer íƒ€ì…ì— ì •ì˜ëœ intValue ë©”ì„œë“œë¥¼ í˜¸ì¶œí•œë‹¤.
&lt;code&gt;The isEven method invokes the intValue method defined in the Integer class through n.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì—¬ëŸ¬ë²ˆ-ì œí•œí•˜ê¸°-multiple-bounds&#34;&gt;ì—¬ëŸ¬ë²ˆ ì œí•œí•˜ê¸° &lt;code&gt;Multiple Bounds&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ì´ì „ê¹Œì§€ ì˜ˆì œëŠ” í•˜ë‚˜ë§Œ ì œí•œí•œ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•œ ê²ƒë§Œ ì„¤ëª…í–ˆì§€ë§Œ, íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” ì—¬ëŸ¬ê°œë¥¼ ì œí•œí•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;The preceding example illustrates the use of a type parameter with a single bound, but a type parameter can have multiple bounds:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;T extends B1 &amp;amp; B2 &amp;amp; B3&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì—¬ëŸ¬ê°œì˜ ì œí•œë“¤ë¡œ êµ¬ì„±ëœ íƒ€ì…ë§¤ê°œë³€ìˆ˜ëŠ” ì œí•œí•˜ë ¤ ë‚˜ì—´í•œ ëª¨ë“  íƒ€ì…ë“¤ì˜ ì„œë¸Œíƒ€ì…ì´ë‹¤.(êµ³ì´ classë¼ê³  ì•ˆí•˜ê³  íƒ€ì…ì´ë€ ìš©ì–´ë¥¼ ì“°ëŠ”ê±´ interfaceë¥¼ í¬í•¨í•˜ëŠ” ë‹¨ì–´ê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì´ë‹¤. í´ë˜ìŠ¤ëŠ” íƒ€ì…ì˜ ë¶€ë¶„) ì œí•œëœ íƒ€ì…ì¤‘ í•˜ë‚˜ê°€ classë¼ë©´, classëŠ” ì—´ê±°ë˜ëŠ” íƒ€ì…ë“¤ì¤‘ ì²˜ìŒì— ì‘ì„±í•´ì•¼í•œë‹¤. ì˜ˆë¥¼ ë“¤ë©´:
&lt;code&gt;A type variable with multiple bounds is a subtype of all the types listed in the bound. If one of the bounds is a class, it must be specified first. For example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Class A { /* ... */ }
interface B { /* ... */ }
interface C { /* ... */ }

class D &amp;lt;T extends A &amp;amp; B &amp;amp; C&amp;gt; { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë§Œì•½ Aë¼ëŠ” ì œí•œ classê°€ ë‹¤ë¥¸ ì œí•œ í´ë˜ìŠ¤ë“¤ì¤‘ ì²˜ìŒì— ìœ„ì¹˜í•˜ì§€ ì•Šìœ¼ë©´, ì»´íŒŒì¼íƒ€ì„ ì—ëŸ¬ë¥¼ ë°œìƒëœë‹¤.
&lt;code&gt;If bound A is not specified first, you get a compile-time error:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class D &amp;lt;T extends B &amp;amp; A &amp;amp; C&amp;gt; { /* ... */ }  // compile-time error
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>java generics ë²ˆì—­ 5</title>
      <link>http://durtchrt.github.io/blog/java/generics/5/</link>
      <pubDate>Fri, 04 Nov 2016 13:43:44 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/5/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/methods.html&#34;&gt;ì›ë¬¸ ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;generic-ë©”ì„œë“œ-generic-methods&#34;&gt;Generic ë©”ì„œë“œ &lt;code&gt;Generic Methods&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Generic ë©”ì„œë“œëŠ” ìì‹œì˜ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ê°€ì§„ ë©”ì„œë“œì´ë‹¤. generic íƒ€ì…ì„ ì„ ì–¸í•˜ëŠ” ê²ƒê³¼ ë¹„ìŠ·í•˜ì§€ë§Œ íƒ€ì…ë§¤ê°œë³€ìˆ˜ì˜ ìŠ¤ì½”í”„ëŠ” ë©”ì„œë“œë¡œ ì œí•œëœë‹¤. ì¼ë°˜ ë©”ì„œë“œ, ì •ì  ë©”ì„œë“œ generic í´ë˜ìŠ¤ì˜ ìƒì„±ìëŠ” ì´ ë£°ì„ ë™ì¼í•˜ê²Œ ì ìš©ëœë‹¤.
&lt;code&gt;Generic methods are methods that introduce their own type parameters. This is similar to declaring a generic type, but the type parameter&#39;s scope is limited to the method where it is declared. Static and non-static generic methods are allowed, as well as generic class constructors.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;generic ë©”ì„œë“œ ë¬¸ë²•ì€ return íƒ€ì… ì „ì— êº½ì‡  ì‚¬ì´ì— íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ í‘œê¸°í•œë‹¤. static generic ë©”ì„œë“œë¥¼ ìœ„í•´ íƒ€ì…ë§¤ê°œë³€ìˆ˜ëŠ” ë°˜ë“œì‹œ ë©”ì„œë“œì˜ return íƒ€ì… ì´ì „ì— ìœ„ì¹˜í•´ì•¼í•œë‹¤.
&lt;code&gt;The syntax for a generic method includes a type parameter, inside angle brackets, and appears before the method&#39;s return type. For static generic methods, the type parameter section must appear before the method&#39;s return type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Util í´ë˜ìŠ¤ëŠ” ë‘ Pair ê°ì²´ë¥¼ ë¹„êµí•˜ëŠ” generic ë©”ì„œë“œë¥¼ í¬í•¨í•˜ê³  ìˆìŠµë‹ˆë‹¤.
&lt;code&gt;The Util class includes a generic method, compare, which compares two Pair objects:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Util {
    public static &amp;lt;K, V&amp;gt; boolean compare(Pair&amp;lt;K, V&amp;gt; p1, Pair&amp;lt;K, V&amp;gt; p2) {
        return p1.getKey().equals(p2.getKey()) &amp;amp;&amp;amp;
               p1.getValue().equals(p2.getValue());
    }
}

public class Pair&amp;lt;K, V&amp;gt; {

    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public void setKey(K key) { this.key = key; }
    public void setValue(V value) { this.value = value; }
    public K getKey()   { return key; }
    public V getValue() { return value; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì´ ë©”ì„œë“œë¥¼(static &lt;K, V&gt; boolean compare)ë¥¼ í˜¸ì¶œí•œ ë¬¸ì¥ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.
&lt;code&gt;The complete syntax for invoking this method would be:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Pair&amp;lt;Integer, String&amp;gt; p1 = new Pair&amp;lt;&amp;gt;(1, &amp;quot;apple&amp;quot;);
Pair&amp;lt;Integer, String&amp;gt; p2 = new Pair&amp;lt;&amp;gt;(2, &amp;quot;pear&amp;quot;);
boolean same = Util.&amp;lt;Integer, String&amp;gt;compare(p1, p2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Util.&lt;strong&gt;&amp;lt;Integer, String&amp;gt;&lt;/strong&gt;compare(p1, p2)&lt;br&gt;
ê°•ì¡°í•œ ì˜ì—­ì²˜ëŸ¼ íƒ€ì…ì„ ëª…ì‹œí•˜ì˜€ë‹¤. íƒ€ì…ì¸ìëŠ” ì»´íŒŒì¼ëŸ¬ê°€ íƒ€ì… ì¶”ë¡ í• ë•Œ í•„ìš”í•œ ì •ë³´ê°€ ëœë‹¤.
&lt;code&gt;The type has been explicitly provided, as shown in bold. Generally, this can be left out and the compiler will infer the type that is needed:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Pair&amp;lt;Integer, String&amp;gt; p1 = new Pair&amp;lt;&amp;gt;(1, &amp;quot;apple&amp;quot;);
Pair&amp;lt;Integer, String&amp;gt; p2 = new Pair&amp;lt;&amp;gt;(2, &amp;quot;pear&amp;quot;);
boolean same = Util.compare(p1, p2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ì½”ë“œëŠ” íƒ€ì… ì¶”ë¡ ì„ ë‚˜íƒ€ë‚¸ê²ƒì´ë‹¤. êº½ì‡ ì— íƒ€ì… ëª…ì‹œí•˜ì§€ ì•Šê³  generic ë©”ì„œë“œê°€ ì•„ë‹Œ ì¼ë°˜ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•´ë„ íƒ€ì… ì¶”ë¡ ì´ ì´ë£¨ì–´ì§„ë‹¤. ì´ ì£¼ì œëŠ” ë’¤ì— ë‚˜ì˜¤ëŠ” íƒ€ì… ì¶”ë¡  ì„¹ì…˜ì—ì„œ ë” ë…¼ì˜í•œë‹¤.
&lt;code&gt;This feature, known as type inference, allows you to invoke a generic method as an ordinary method, without specifying a type between angle brackets. This topic is further discussed in the following section, Type Inference.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>java generics ë²ˆì—­ 4</title>
      <link>http://durtchrt.github.io/blog/java/generics/4/</link>
      <pubDate>Tue, 01 Nov 2016 16:05:56 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/4/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&#34;&gt;ì›ë¬¸ ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;raw-types&#34;&gt;Raw Types&lt;/h3&gt;

&lt;p&gt;Raw íƒ€ì…ì€ generic í´ë˜ìŠ¤ í˜¹ì€ ì¸í„°í˜ì´ìŠ¤ì— íƒ€ì…ì¸ìê°€ ì—†ëŠ” ê²ƒ. ì˜ˆë¥¼ë“¤ì–´ generic Box í´ë˜ìŠ¤ë¥¼ ë³´ì
&lt;code&gt;A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Box&amp;lt;T&amp;gt; {
    public void set(T t) { /* ... */ }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì•„ë˜ ì½”ë“œë¥¼ ë³´ë©´ Box&lt;T&gt;ì˜ ë§¤ê°œë³€ìˆ˜í™”ëœ íƒ€ì…ì„ ë§Œë“œë©´ì„œ, íƒ€ì…ë§¤ê°œë³€ìˆ˜ Tì— í•´ë‹¹í•˜ëŠ” Integerë¥¼ íƒ€ì…ì¸ìë¡œ ì œê³µí•˜ì˜€ë‹¤.
&lt;code&gt;To create a parameterized type of Box&amp;lt;T&amp;gt;, you supply an actual type argument for the formal type parameter T:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Integer&amp;gt; intBox = new Box&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;íƒ€ì…ì¸ìê°€ ìƒëµëœ ê²½ìš° Box&lt;T&gt;ì˜ Raw íƒ€ì…ì„ ë§Œë“¤ìˆ˜ ìˆë‹¤.
&lt;code&gt;If the actual type argument is omitted, you create a raw type of Box&amp;lt;T&amp;gt;:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box rawBox = new Box();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê²°êµ­, BoxëŠ” generic íƒ€ì… Box&lt;T&gt;ì˜ raw íƒ€ì…ì´ë‹¤. í•˜ì§€ë§Œ, generic í´ë˜ìŠ¤ ë˜ëŠ” ì¸í„°í˜ì´ìŠ¤ê°€ ì•„ë‹Œê²½ìš°ëŠ” raw íƒ€ì…ì´ ë  ìˆ˜ ì—†ë‹¤.()
&lt;code&gt;Therefore, Box is the raw type of the generic type Box&amp;lt;T&amp;gt;. However, a non-generic class or interface type is not a raw type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Raw íƒ€ì…ì€ JDK 5.0 ì´ì „ ìë°” API í´ë˜ìŠ¤ë“¤ì€ ì œë„¤ë¦­ì„ ì§€ì›í•˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì—(ì˜ˆë¥¼ ë“¤ì–´ Collections í´ë˜ìŠ¤) ë ˆê±°ì‹œ ì½”ë“œì—ì„œ ë‚˜íƒ€ë‚œë‹¤. raw íƒ€ì…ì„ ì‚¬ìš©í•  ë•ŒëŠ” ë°˜ë“œì‹œ generics ì´ì „ ë°©ë²•(íƒ€ì… ìºìŠ¤íŒ…)ì„ í•˜ì‹œì˜¤. í•˜ìœ„í˜¸í™˜ì„±ì„ ìœ„í•´, íƒ€ì…ë§¤ê°œë³€ìˆ˜ëŠ” rawíƒ€ì…ì„ í—ˆìš©í•˜ì˜€ë‹¤.
&lt;code&gt;Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior â€” a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;String&amp;gt; stringBox = new Box&amp;lt;&amp;gt;();
Box rawBox = stringBox;               // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;í•˜ì§€ë§Œ íƒ€ì…ë§¤ê°œë³€ìˆ˜ì— raw íƒ€ì…ì„ í• ë‹¹í•˜ë©´ (ì»´íŒŒì¼ëŸ¬ë¡œë¶€í„°) ê²½ê³ ë¥¼ ë°›ìŠµë‹ˆë‹¤.
&lt;code&gt;But if you assign a raw type to a parameterized type, you get a warning:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box rawBox = new Box();           // rawBox is a raw type of Box&amp;lt;T&amp;gt;
Box&amp;lt;Integer&amp;gt; intBox = rawBox;     // warning: unchecked conversion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë˜í•œ generic íƒ€ì…ì— ì •ì˜ëœ generic ë©”ì„œë“œë¥¼ í˜¸ì¶œí• ë•Œì—ë„ raw íƒ€ì…ì„ ì‚¬ìš©í•˜ë©´ ê²½ê³ ë¥¼ ë°›ìŠµë‹ˆë‹¤.
&lt;code&gt;You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;String&amp;gt; stringBox = new Box&amp;lt;&amp;gt;();
Box rawBox = stringBox;
rawBox.set(8);  // warning: unchecked invocation to set(T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê²½ê³ ëŠ” raw íƒ€ì…ë“¤ì´ generic íƒ€ì…ì²´í¬ë¥¼ í• ìˆ˜ ì—†ë‹¤ëŠ” ê²ƒì„ ë³´ì—¬ì¤ë‹ˆë‹¤. (ì»´íŒŒì¼ íƒ€ì„ì— ì²´í¬ë  ìˆ˜ ìˆëŠ”) ë¶ˆì•ˆí•œ ì½”ë“œê°€ ëŸ°íƒ€ì„ì— ë¶™ì¡íˆê²Œ (ì»´íŒŒì¼ íƒ€ì„ ì²´í‚¹ì„ ëŸ°íƒ€ì„ìœ¼ë¡œ) ë”œë ˆì´ ì‹œí‚¤ëŠ” ê²ƒì´ë¯€ë¡œ raw íƒ€ì… ì‚¬ìš©ì€ í”¼í•˜ëŠ”ê²ƒì´ ì¢‹ì„ ê²ƒì´ë‹¤.&lt;br /&gt;
&lt;code&gt;The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;íƒ€ì…ì†Œê±° ì„¹ì…˜ì—ì„œëŠ” ìë°” ì»´íŒŒì¼ëŸ¬ê°€ raw íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì— ëŒ€í•œ ë” ìì„¸í•œ ì„¤ëª…ì´ ìˆë‹¤.
&lt;code&gt;The Type Erasure section has more information on how the Java compiler uses raw types.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;unchecked-error-messages&#34;&gt;Unchecked Error Messages&lt;/h3&gt;

&lt;p&gt;ì´ì „ì— ë§í–‡ë“¯, generic ì½”ë“œì™€ ë ˆê±°ì‹œ ì½”ë“œë¥¼ ì„ê²Œ ë˜ë©´, ì•„ë˜ì™€ ê°™ì€ ê²½ê³  ë©”ì„¸ì§€ë¥¼ ë§ˆì£¼ì¹  ê²ƒì´ë‹¤.
&lt;code&gt;As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Note: Example.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;This can happen when using an older API that operates on raw types, as shown in the following example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WarningDemo {
    public static void main(String[] args){
        Box&amp;lt;Integer&amp;gt; bi;
        bi = createBox();
    }

    static Box createBox(){
        return new Box();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;unchecked(ì²´í¬ë˜ì§€ ì•ŠìŒ)&amp;ldquo;ëŠ” íƒ€ì… ì•ˆì •ì„±ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ í•„ìš”í•œ íƒ€ì…ì²´í¬ ì •ë³´ê°€ ì¶©ë¶„ì¹˜ ì•Šë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤. &amp;ldquo;unchecked&amp;rdquo; ê²½ê³ ëŠ” ì»´íŒŒì¼ëŸ¬ì—ê²Œ ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤.&amp;ldquo;unchecked&amp;rdquo; ê²½ê³ ë¥¼ ë³´ê³  ì‹¶ë‹¤ë©´ -Xlint:uncheckedì˜µì…˜ì„ ì£¼ê³  ë‹¤ì‹œ ì»´íŒŒì¼í•˜ë©´ ëª¨ë“  &amp;ldquo;unchecked&amp;rdquo; ê²½ê³ ë¥¼ ë³¼ ìˆ˜ ìˆë‹¤.
&lt;code&gt;The term &amp;quot;unchecked&amp;quot; means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The &amp;quot;unchecked&amp;quot; warning is disabled, by default, though the compiler gives a hint. To see all &amp;quot;unchecked&amp;quot; warnings, recompile with -Xlint:unchecked.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;-Xlint:unchecked ì˜µì…˜ê³¼ í•¨ê»˜ ì˜ˆì œë¥¼ ë‹¤ì‹œ ì»´íŒŒì¼í•´ë³´ë©´ ì•„ë˜ì— ë³´ì´ëŠ” ë‚´ìš©ì´ ë‚˜íƒ€ë‚  ê²ƒì´ë‹¤.
&lt;code&gt;Recompiling the previous example with -Xlint:unchecked reveals the following additional information:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;WarningDemo.java:4: warning: [unchecked] unchecked conversion
found   : Box
required: Box&amp;lt;java.lang.Integer&amp;gt;
        bi = createBox();
                      ^
1 warning
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì»´íŒŒì¼ ì˜µì…˜ì— -Xlint:-unchecked í”Œë˜ê·¸ë¥¼ ì‚¬ìš©í•˜ë©´ unchecked ê²½ê³ ë¥¼ ì—†ì•¨ ìˆ˜ ìˆë‹¤. @SupporessWarnings(&amp;ldquo;unchecked&amp;rdquo;) ì–´ë…¸í…Œì´ì…˜ì€ unchecked ê²½ê³ ê°€ ë‚˜íƒ€ë‚˜ì§€ ì•Šê²Œ í•  ìˆ˜ ìˆë‹¤. @SupressWarnings ë¬¸ë²•ì´ ìƒì†Œí•˜ë©´ Annotations ì„¹ì…˜ì„ ë³´ì‹œì˜¤. &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/annotations/index.html&#34;&gt;ë§í¬&lt;/a&gt;
&lt;code&gt;To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The @SuppressWarnings(&amp;quot;unchecked&amp;quot;) annotation suppresses unchecked warnings. If you are unfamiliar with the @SuppressWarnings syntax, see Annotations.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ì—­ì ì²¨ë¶€&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ javac WarningDemo.java 

Note: WarningDemo.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
    
$ javac -Xlint:unchecked WarningDemo.java

WarningDemo.java:7: warning: [unchecked] unchecked conversion
        bi = createBox();
                      ^
required: Box&amp;lt;Integer&amp;gt;
found:    Box
1 warning
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>