<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ê°œë°œ ì €ì¥ì†Œ</title>
    <link>http://durtchrt.github.io/blog/tags/%EB%B2%88%EC%97%AD/index.xml</link>
    <description>Recent content on ê°œë°œ ì €ì¥ì†Œ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>durtchrt</copyright>
    <atom:link href="http://durtchrt.github.io/blog/tags/%EB%B2%88%EC%97%AD/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(8) Java Generics: ì œë„¤ë¦­ìŠ¤, ìƒì†, ì„œë¸Œíƒ€ì… (Generics, Inheritance, and Subtypes)</title>
      <link>http://durtchrt.github.io/blog/java/generics/8/</link>
      <pubDate>Sat, 05 Nov 2016 08:48:42 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/8/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/inheritance.html&#34;&gt;ì›ë¬¸ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ìš©ì–´
ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜(method signature): ë©”ì„œë“¤ê°„ì— ê°œì„± ì£¼ëŠ”ê²ƒìœ¼ë¡œ ìë°” ì»´íŒŒì¼ëŸ¬ì¸ì§€ ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë²„ë¡œë”©ì„ í•œë‹¤.  ìë°”ì—ì„œëŠ” ë©”ì„œë“œëª…, íŒŒë¼ë¯¸í„° ê°¯ìˆ˜, íŒŒë¼ë¯¸í„° íƒ€ì…, íŒŒë¼ë¯¸í„° ìˆœì„œ(ìë°”ì—ì„œëŠ” ë¦¬í„´íƒ€ì…ì€ ì‹œê·¸ë‹ˆì²˜ê°€ ì•„ë‹ˆë‹¤.) - íŒŒë¼ë¯¸í„°ëª…ë„ ì‹œê·¸ë‹ˆì²˜ì¸ì§€ëŠ” ì•„ë¦¬ê¹Œë¦¬í•˜ë‹¤. ë©”ì„œë“œ ì˜¤ë²„ë¡œë”©ë¥¼ ìƒê°í•˜ë©´ ë§ëŠ”ê±° ê°™ì€ë°&amp;hellip; ì¢€ë” ìƒê°í•´ë³´ê³  ë‚´ìš© ìˆ˜ì • ì˜ˆì •
ì½˜í¬ë¦¬íŠ¸ íƒ€ì…, êµ¬í˜„íƒ€ì…(concrete type): ìë°”ì—ì„œëŠ” íƒ€ì…ë“¤ì¤‘ interface, abstract classë¥¼ ì œì™¸í•˜ê³  ë‚¨ì€ classë¥¼ concrete íƒ€ì…ìœ¼ë¡œ ì´í•´í•˜ë©´ ë  ë“¯.&lt;a href=&#34;http://dreuarchive.cra.org/2002/heise/typeComp.html&#34;&gt;ì°¸ê³ ë§í¬ - ì˜ë¬¸: ë²ˆì—­ ì˜ˆì •&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì œë„¤ë¦­ìŠ¤-ìƒì†-ì„œë¸Œíƒ€ì…-generics-inheritance-and-subtypes&#34;&gt;ì œë„¤ë¦­ìŠ¤, ìƒì†, ì„œë¸Œíƒ€ì… &lt;code&gt;Generics, Inheritance, and Subtypes&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;íƒ€ì…ê°„ í˜¸í™˜ì´ëœë‹¤ë©´ íŠ¹ì • íƒ€ì…ì˜ ê°ì²´ë¥¼ ë‹¤ë¥¸ íƒ€ì…ì— í• ë‹¹ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. ì•„ë˜ì˜ ì½”ë“œì²˜ëŸ¼ Object íƒ€ì…ì€ Integerì˜ ìŠˆí¼íƒ€ì…ì¤‘ í•˜ë‚˜ì´ê¸° ë•Œë¬¸ì— Integer íƒ€ì…ì¸ someIntegerì˜ ê°ì²´ê°€ Object íƒ€ì…ì¸ someObjectì— í• ë‹¹ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.
&lt;code&gt;As you already know, it is possible to assign an object of one type to an object of another type provided that the types are compatible. For example, you can assign an Integer to an Object, since Object is one of Integer&#39;s supertypes:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object someObject = new Object();
Integer someInteger = new Integer(10);
someObject = someInteger;   // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê°ì²´ì§€í–¥ ì´ë¡ ì—ì„œëŠ” ì´ë¥¼ &amp;ldquo;is a&amp;rdquo;(~ëŠ” ~ì´ë‹¤) ê´€ê³„ë¼ê³  ë¶€ë¥¸ë‹¤. IntegerëŠ” Objectì˜ &amp;ldquo;is a&amp;rdquo;ì´ë¯€ë¡œ Integer íƒ€ì…ì„ Object íƒ€ì…ì— í• ë‹¹ì´ ê°€ëŠ¥í•˜ë‹¤. í•˜ì§€ë§Œ IntegerëŠ” Number íƒ€ì…ì— &amp;ldquo;is a&amp;rdquo; ê´€ê³„ì´ë‹¤. ê·¸ëŸ¬ë¯€ë¡œ ì•„ë˜ì˜ ì½”ë“œëŠ” ì˜ ë™ì‘í•œë‹¤.
&lt;code&gt;In object-oriented terminology, this is called an &amp;quot;is a&amp;quot; relationship. Since an Integer is a kind of Object, the assignment is allowed. But Integer is also a kind of Number, so the following code is valid as well:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void someMethod(Number n) { /* ... */ }

someMethod(new Integer(10));   // OK
someMethod(new Double(10.1));   // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ë£°ì€ genericsë„ ë§ˆì°¬ê°€ì§€ë‹¤. generic íƒ€ì…ì„ í˜¸ì¶œí• ë•Œ, íƒ€ì…ì¸ìê°€ Number íƒ€ì…ê³¼ í˜¸í™˜ë˜ëŠ” &amp;ldquo;is a&amp;rdquo; ê´€ê³„ë¼ë©´ Number íƒ€ì…ìœ¼ë¡œ íƒ€ì…ì¸ìë¥¼ ì „ë‹¬í•œë‹¤.
&lt;code&gt;The same is also true with generics. You can perform a generic type invocation, passing Number as its type argument, and any subsequent invocation of add will be allowed if the argument is compatible with Number:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Number&amp;gt; box = new Box&amp;lt;Number&amp;gt;();
box.add(new Integer(10));   // OK
box.add(new Double(10.1));  // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì•„ë˜ì˜ ë©”ì„œë“œë¥¼ ì‚´í´ë³´ì
&lt;code&gt;Now consider the following method:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void boxTest(Box&amp;lt;Number&amp;gt; n) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì–´ë–¤ íƒ€ì…ì„ ì¸ìë¡œ ë°›ì„ìˆ˜ ìˆì„ê¹Œ? ë©”ì„œë“œì˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ë³´ë©´, Box&lt;Number&gt; íƒ€ì…ì˜ ê°ì²´ í•˜ë‚˜ë¥¼ ì¸ìë¡œ ë°›ëŠ” ë©”ì„œë“œì´ë‹¤. ê·¸ëŸ¼, Box&amp;lt;Integer&amp;gt;ë‚˜ Box&amp;lt;Double&amp;gt;ì„ ì¸ìë¡œ ë„£ì„ìˆ˜ ìˆì„ê¹Œ? ì•„ë‹ˆë‹¤! ì™œëƒí•˜ë©´ Box&amp;lt;Integer&amp;gt;, Box&amp;lt;Double&amp;gt;ëŠ” Box&amp;lt;Number&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ì´ ì•„ë‹ˆê¸° ë•Œë¬¸ì´ë‹¤. (ìë°”ì—ì„œëŠ” êº½ì‡ ì•ˆì— Number íƒ€ì…ì€ ì»´íŒŒì¼ëŸ¬ê°€ is aê´€ê³„ë¥¼ íŒŒì•…í•˜ì§€ ëª»í•œë‹¤. - ê³µë³€ì„±, ë°˜ê³µë³€ì„±ìª½ ë‚´ìš© ì°¸ì¡°í•˜ë©´ ì¢‹ì€ë° ìë°”ëŠ” ì´ë¥¼ ì§€ì› ëª»í•¨. ìŠ¤ì¹¼ë¼ ì–¸ì–´ ì°¸ì¡°. ëˆˆì´ ê³µë¶€í•˜ë‹¤ë³´ë©´ íŒ½íŒ½ ë”.)
&lt;code&gt;What type of argument does it accept? By looking at its signature, you can see that it accepts a single argument whose type is Box&amp;lt;Number&amp;gt;. But what does that mean? Are you allowed to pass in Box&amp;lt;Integer&amp;gt; or Box&amp;lt;Double&amp;gt;, as you might expect? The answer is &amp;quot;no&amp;quot;, because Box&amp;lt;Integer&amp;gt; and Box&amp;lt;Double&amp;gt; are not subtypes of Box&amp;lt;Number&amp;gt;.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì´ê²ƒì€ genericsë¥¼ ê³µë¶€í• ë•Œ í”íˆ ê²ªëŠ” ë¬¸ì œì´ë‹¤. í•˜ì§€ë§Œ genericì„ ê³µë¶€í• ë•Œ ì¤‘ìš”í•œ ì»¨ì…‰ì´ë‹¤.
&lt;code&gt;This is a common misunderstanding when it comes to programming with generics, but it is an important concept to learn.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../8-1.gif&#34; alt=&#34;Box&amp;lt;Integer&amp;gt; is not a subtype of Box&amp;lt;Number&amp;gt; even though Integer is a subtype of Number.&#34; /&gt;
&lt;br&gt;
Numberì˜ ì„œë¸Œíƒ€ì…ì¸ Integerë¥¼ ê°€ì§„ Box&amp;lt;Integer&amp;gt;ëŠ” Box&amp;lt;Number&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ì´ ì•„ë‹ˆë‹¤.
&lt;code&gt;Box&amp;lt;Integer&amp;gt; is not a subtype of Box&amp;lt;Number&amp;gt; even though Integer is a subtype of Number.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì¤‘ìš”:  Aì™€ B ë‘ êµ¬í˜„íƒ€ì…ì„ ì œê³µí• ë•Œ(ì˜ˆë¥¼ ë“¤ì–´ Numberì™€ Integer),Aì™€ Bê°€ &amp;ldquo;is a&amp;rdquo; ê´€ê³„ê°€ ìˆë“  ìƒê´€ì—†ì´  MyClass&amp;lt;A&amp;gt;ëŠ” MyClass&amp;lt;B&amp;gt;ì™€ ë” ì´ìƒ ê´€ê³„ê°€ í˜•ì„±ë˜ì§€ ì•ŠëŠ”ë‹¤.
&lt;code&gt;Note: Given two concrete types A and B (for example, Number and Integer), MyClass&amp;lt;A&amp;gt; has no relationship to MyClass&amp;lt;B&amp;gt;, regardless of whether or not A and B are related. The common parent of MyClass&amp;lt;A&amp;gt; and MyClass&amp;lt;B&amp;gt; is Object.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ë‘ generic í´ë˜ìŠ¤ë“¤ê°„ì— ì„œë¸Œíƒ€ì…&lt;strong&gt;ì²˜ëŸ¼&lt;/strong&gt; íƒ€ì…ë§¤ê°œë³€ìˆ˜ê°€ ê´€ë ¨ìˆë‹¤ë¼ëŠ” ì •ë³´ë¥¼ ì£¼ë ¤ë©´(ì»´íŒŒì¼ëŸ¬ì—ê²Œ), ì™€ì¼ë“œì¹´ë“œì™€ ì„œë¸Œíƒ€ì´í•‘ í•­ëª©ì„ ë³´ë¼
&lt;code&gt;For information on how to create a subtype-like relationship between two generic classes when the type parameters are related, see Wildcards and Subtyping.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì œë„¤ë¦­-í´ë˜ìŠ¤ì™€-ì„œë¸Œíƒ€ì´í•‘-generic-classes-and-subtyping&#34;&gt;ì œë„¤ë¦­ í´ë˜ìŠ¤ì™€ ì„œë¸Œíƒ€ì´í•‘ &lt;code&gt;Generic Classes and Subtyping&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;generic í´ë˜ìŠ¤ ìƒì† ë˜ëŠ” generic ì¸í„°í˜ì´ìŠ¤ ë§Œë“¤ ë•Œ, ë§Œë“œëŠ” íƒ€ì…ì„ ìƒì†(ë˜ëŠ” êµ¬í˜„) ë°›ì€ ë¶€ëª¨  generic íƒ€ì…ì˜ ì„œë¸Œ generic íƒ€ì…(ìì‹íƒ€ì…)ìœ¼ë¡œ ë‘ íƒ€ì…ê°„ì— ê´€ê³„(is a)ë¥¼ ë§Œë“¤ìˆ˜ ìˆë‹¤.
&lt;code&gt;You can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the extends and implements clauses.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Collections í´ë˜ìŠ¤ë“¤ ì‚¬ìš©í•  ë•Œ ì˜ˆë¥¼ ë“¤ë©´,  ArrayList&amp;lt;E&amp;gt;ëŠ” List&amp;lt;E&amp;gt;ë¥¼ êµ¬í˜„í–ˆê³  List&amp;lt;E&amp;gt;ëŠ” Collectionì„ ìƒì†í–ˆë‹¤. ê·¸ëŸ¬ë¯€ë¡œ ArrayList&amp;lt;String&amp;gt;ì€ List&amp;lt;String&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ì´ê³  List&amp;lt;String&amp;gt;ì€ Collection&amp;lt;String&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ë‹ˆë‹¤. ê·¸ëŸ¼ &amp;lt;String&amp;gt;ì´ë¼ëŠ” í˜•ì‹ì¸ìë¥¼ ë³€ê²½í•˜ì§€ ì•Šìœ¼ë©´ íƒ€ì…ê°„ ì„œë¸Œíƒ€ì´í•‘ ê´€ê³„ê°€ ìœ ì§€ëœë‹¤.
&lt;code&gt;Using the Collections classes as an example, ArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, and List&amp;lt;E&amp;gt; extends Collection&amp;lt;E&amp;gt;. So ArrayList&amp;lt;String&amp;gt; is a subtype of List&amp;lt;String&amp;gt;, which is a subtype of Collection&amp;lt;String&amp;gt;. So long as you do not vary the type argument, the subtyping relationship is preserved between the types.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../8-2.gif&#34; alt=&#34;A sample Collections hierarchy&#34; /&gt;
&lt;br&gt;
ì½œë ‰ì…˜ë“¤ê°„ì˜ ê³„ì¸µêµ¬ì¡° ì˜ˆ&lt;code&gt;sample Collections hierarchy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;PayloadListë¼ëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•  ë•Œ Pë¼ëŠ” generic íƒ€ì…ì„ ë©”ì„œë“œì˜ íŒŒë¼ë©”í„°ë¡œ ì‚¬ìš©í•œë‹¤ê³ í–ˆì„ë•Œ, ì•„ë˜ ì½”ë“œì™€ ê°™ì„ ê²ƒì´ë‹¤.
&lt;code&gt;Now imagine we want to define our own list interface, PayloadList, that associates an optional value of generic type P with each element. Its declaration might look like:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface PayloadList&amp;lt;E,P&amp;gt; extends List&amp;lt;E&amp;gt; {
  void setPayload(int index, P val);
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;List&amp;lt;String&amp;gt;ì˜ ì„œë¸Œíƒ€ì…ì´ë©´ì„œ PayloadListê°€ íƒ€ì…ì¸ìë¡œ ì „ë‹¬í• ìˆ˜ ìˆëŠ” ê²ƒì€ ì•„ë˜ì²˜ëŸ¼ ë‹¤ì–‘í•˜ê²Œ ë³¼ìˆ˜ ìˆë‹¤.(ì¼ë¶€ì„.)
&lt;code&gt;The following parameterizations of PayloadList are subtypes of List&amp;lt;String&amp;gt;:&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PayloadList&lt;String,String&gt;&lt;/li&gt;
&lt;li&gt;PayloadList&lt;String,Integer&gt;&lt;/li&gt;
&lt;li&gt;PayloadList&lt;String,Exception&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../8-3.gif&#34; alt=&#34;A sample PayloadList hierarchy&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(7) Java Generics: Generic ë©”ì„œë“œì™€ ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ (Generic Methods and Bounded Type Parameters)</title>
      <link>http://durtchrt.github.io/blog/java/generics/7/</link>
      <pubDate>Sat, 05 Nov 2016 08:24:47 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/7/</guid>
      <description>

&lt;h3 id=&#34;generic-ë©”ì„œë“œì™€-ì œí•œëœ-íƒ€ì…-ë§¤ê°œë³€ìˆ˜-generic-methods-and-bounded-type-parameters&#34;&gt;Generic ë©”ì„œë“œì™€ ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ &lt;code&gt;Generic Methods and Bounded Type Parameters&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” generic ì•Œê³ ë¦¬ì¦˜ë“¤ì„ êµ¬í˜„í• ë•Œ í•µì‹¬ì´ëœë‹¤. ì•„ë˜ì˜ ì˜ˆëŠ” ë‘ë²ˆì§¸ ì¸ìë³´ë‹¤ í° ê°’ì´ ì²«ë²ˆì§¸ ì¸ìì¸ ë°°ì—´ì— ëª‡ê°œê°€ ìˆëŠ”ì§€ ì„¸ëŠ” ë©”ì„œë“œì´ë‹¤.
&lt;code&gt;Bounded type parameters are key to the implementation of generic algorithms. Consider the following method that counts the number of elements in an array T[] that are greater than a specified element elem.&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T&amp;gt; int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e &amp;gt; elem)  // compiler error
            ++count;
    return count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë©”ì„œë“œ êµ¬í˜„ì€ ê°„ë‹¨í•˜ì§€ë§Œ, &amp;lsquo;&amp;gt;&amp;rsquo; ì—°ì‚°ìê°€ ê¸°ë³¸í˜•(short, int, double, long, float, byte, char)ì—ë§Œ ë™ì‘ì´ í—ˆìš©ë˜ê¸° ë•Œë¬¸ì´ë‹¤. &amp;lsquo;&amp;gt;&amp;rsquo; ì—°ì‚°ìëŠ” ê°ì²´ê°„ ë¹„êµì—ëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¹„êµì—°ì‚°ì ëŒ€ì‹  Comparable&lt;T&gt;  ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•´ì„œ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
&lt;code&gt;The implementation of the method is straightforward, but it does not compile because the greater than operator (&amp;gt;) applies only to primitive types such as short, int, double, long, float, byte, and char. You cannot use the &amp;gt; operator to compare objects. To fix the problem, use a type parameter bounded by the Comparable&amp;lt;T&amp;gt; interface:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Comparable&amp;lt;T&amp;gt; {
    public int compareTo(T o);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comparable ì¸í„°í˜ì´ìŠ¤ê°€ ì ìš©ëœ ê²°ê³¼ ì½”ë“œëŠ” ì•„ë˜ì˜ ì½”ë“œì²˜ëŸ¼ ë  ê²ƒì…ë‹ˆë‹¤. &lt;code&gt;The resulting code will be:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e.compareTo(elem) &amp;gt; 0)
            ++count;
    return count;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(6) Java Generics: ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ (Bounded Type Parameters)</title>
      <link>http://durtchrt.github.io/blog/java/generics/6/</link>
      <pubDate>Fri, 04 Nov 2016 18:03:27 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/6/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/bounded.html&#34;&gt;ì›ë¬¸ ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì œí•œëœ-íƒ€ì…-ë§¤ê°œë³€ìˆ˜-bounded-type-parameters&#34;&gt;ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ &lt;code&gt;Bounded Type Parameters&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ë§¤ê°œë³€ìˆ˜í™”ëœ íƒ€ì…ì— íƒ€ì…ì¸ìë¥¼ ë„£ì„ë•Œ íƒ€ì… ì œí•œì„ ê±¸ê³  ì‹¶ì„ ë•Œê°€ ìˆì„ ê²ƒì´ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, Number íƒ€ì… ë˜ëŠ” Number íƒ€ì…ì˜ ìì‹ í´ë˜ìŠ¤ì˜ ê°ì²´ë§Œ í—ˆìš©í•˜ëŠ” ìˆ«ì ì²˜ë¦¬ë¥¼ ìœ„í•œ ë©”ì„œë“œë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤. ì´ê²ƒì´ ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ë‹¤
&lt;code&gt;There may be times when you want to restrict the types that can be used as type arguments in a parameterized type. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. This is what bounded type parameters are for.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì œí•œëœ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ëŠ” ë°©ë²•ì€, íƒ€ì…ë§¤ê°œë³€ìˆ˜ì˜ ì´ë¦„ ë’¤ì—  extends í‚¤ì›Œë“œë¥¼ ë†“ê³  ì œí•œì‹œí‚¬ íƒ€ì…ì„ ì‘ì„±í•˜ë©´ ëœë‹¤. ì•„ë˜ì˜ ì—ì—ì„œëŠ” Number íƒ€ì…ìœ¼ë¡œ í•˜ì˜€ë‹¤. ì£¼ì˜í• ì ì€, ì—¬ê¸°ì„œ ì‚¬ìš©í•œ extendsëŠ” í´ë˜ìŠ¤ì•ˆì˜ &amp;ldquo;extends&amp;rdquo; ë˜ëŠ” ì¸í„°í˜ì´ìŠ¤ì˜ &amp;ldquo;implements&amp;rdquo; ì²˜ëŸ¼ êµ¬í˜„í•œë‹¤ëŠ” ì˜ë¯¸ëŠ” ì•„ë‹ˆë‹¤.
&lt;code&gt;To declare a bounded type parameter, list the type parameter&#39;s name, followed by the extends keyword, followed by its upper bound, which in this example is Number. Note that, in this context, extends is used in a general sense to mean either &amp;quot;extends&amp;quot; (as in classes) or &amp;quot;implements&amp;quot; (as in interfaces).&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Box&amp;lt;T&amp;gt; {

    private T t;

    public void set(T t) {
        this.t = t;
    }

    public T get() {
        return t;
    }

    public &amp;lt;U extends Number&amp;gt; void inspect(U u){
        System.out.println(&amp;quot;T: &amp;quot; + t.getClass().getName());
        System.out.println(&amp;quot;U: &amp;quot; + u.getClass().getName());
    }

    public static void main(String[] args) {
        Box&amp;lt;Integer&amp;gt; integerBox = new Box&amp;lt;Integer&amp;gt;();
        integerBox.set(new Integer(10));
        integerBox.inspect(&amp;quot;some text&amp;quot;); // error: this is still String!
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generic Box í´ë˜ìŠ¤ëŠ” ì œí•œëœ íƒ€ì… íŒŒë¼ë©”í„°ë¥¼ ê°€ì§„ ë©”ì„œë“œì¸ inspectë¥¼ í¬í•¨í•˜ë„ë¡ ê¸°ì¡´ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì˜€ë‹¤. inspect ë©”ì„œë“œ í˜¸ì¶œì‹œì— String íƒ€ì…ì„ ì¸ìë¡œ ë°›ì•˜ê¸° ë•Œë¬¸ì— ì»´íŒŒì¼ì´ ì‹¤íŒ¨í•  ê²ƒì´ë‹¤.
&lt;code&gt;By modifying our generic method to include this bounded type parameter, compilation will now fail, since our invocation of inspect still includes a String:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Box.java:21: &amp;lt;U&amp;gt;inspect(U) in Box&amp;lt;java.lang.Integer&amp;gt; cannot
  be applied to (java.lang.String)
                        integerBox.inspect(&amp;quot;10&amp;quot;);
                                  ^
1 error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê²°ë¡ ì€ generic íƒ€ì…ì„ ê°ì²´ë¡œ ë§Œë“¤ë•Œ ì œí•œì„ ê±¸ìˆ˜ ìˆë‹¤. ì œí•œëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” ì •ì˜ëœ ì œí•œëœ ë²”ìœ„ ë‚´ì—ì„œ ë©”ì„œë“œë¥¼ í˜¸ì¶œ í•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;In addition to limiting the types you can use to instantiate a generic type, bounded type parameters allow you to invoke methods defined in the bounds:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class NaturalNumber&amp;lt;T extends Integer&amp;gt; {

    private T n;

    public NaturalNumber(T n)  { this.n = n; }

    public boolean isEven() {
        return n.intValue() % 2 == 0;
    }

    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;isEven ë©”ì„œë“œëŠ” ë³€ìˆ˜ nì— íƒ€ì…ì¸ìë¡œ ì „ë‹¬ëœ Integer íƒ€ì…ì— ì •ì˜ëœ intValue ë©”ì„œë“œë¥¼ í˜¸ì¶œí•œë‹¤.
&lt;code&gt;The isEven method invokes the intValue method defined in the Integer class through n.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì—¬ëŸ¬ë²ˆ-ì œí•œí•˜ê¸°-multiple-bounds&#34;&gt;ì—¬ëŸ¬ë²ˆ ì œí•œí•˜ê¸° &lt;code&gt;Multiple Bounds&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;ì´ì „ê¹Œì§€ ì˜ˆì œëŠ” í•˜ë‚˜ë§Œ ì œí•œí•œ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•œ ê²ƒë§Œ ì„¤ëª…í–ˆì§€ë§Œ, íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” ì—¬ëŸ¬ê°œë¥¼ ì œí•œí•  ìˆ˜ ìˆë‹¤.
&lt;code&gt;The preceding example illustrates the use of a type parameter with a single bound, but a type parameter can have multiple bounds:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;T extends B1 &amp;amp; B2 &amp;amp; B3&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì—¬ëŸ¬ê°œì˜ ì œí•œë“¤ë¡œ êµ¬ì„±ëœ íƒ€ì…ë§¤ê°œë³€ìˆ˜ëŠ” ì œí•œí•˜ë ¤ ë‚˜ì—´í•œ ëª¨ë“  íƒ€ì…ë“¤ì˜ ì„œë¸Œíƒ€ì…ì´ë‹¤.(êµ³ì´ classë¼ê³  ì•ˆí•˜ê³  íƒ€ì…ì´ë€ ìš©ì–´ë¥¼ ì“°ëŠ”ê±´ interfaceë¥¼ í¬í•¨í•˜ëŠ” ë‹¨ì–´ê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì´ë‹¤. í´ë˜ìŠ¤ëŠ” íƒ€ì…ì˜ ë¶€ë¶„) ì œí•œëœ íƒ€ì…ì¤‘ í•˜ë‚˜ê°€ classë¼ë©´, classëŠ” ì—´ê±°ë˜ëŠ” íƒ€ì…ë“¤ì¤‘ ì²˜ìŒì— ì‘ì„±í•´ì•¼í•œë‹¤. ì˜ˆë¥¼ ë“¤ë©´:
&lt;code&gt;A type variable with multiple bounds is a subtype of all the types listed in the bound. If one of the bounds is a class, it must be specified first. For example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Class A { /* ... */ }
interface B { /* ... */ }
interface C { /* ... */ }

class D &amp;lt;T extends A &amp;amp; B &amp;amp; C&amp;gt; { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë§Œì•½ Aë¼ëŠ” ì œí•œ classê°€ ë‹¤ë¥¸ ì œí•œ í´ë˜ìŠ¤ë“¤ì¤‘ ì²˜ìŒì— ìœ„ì¹˜í•˜ì§€ ì•Šìœ¼ë©´, ì»´íŒŒì¼íƒ€ì„ ì—ëŸ¬ë¥¼ ë°œìƒëœë‹¤.
&lt;code&gt;If bound A is not specified first, you get a compile-time error:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class D &amp;lt;T extends B &amp;amp; A &amp;amp; C&amp;gt; { /* ... */ }  // compile-time error
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(5) Java Generics: ì œë„¤ë¦­ ë©”ì„œë“œ</title>
      <link>http://durtchrt.github.io/blog/java/generics/5/</link>
      <pubDate>Fri, 04 Nov 2016 13:43:44 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/5/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/methods.html&#34;&gt;ì›ë¬¸ ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;generic-ë©”ì„œë“œ-generic-methods&#34;&gt;Generic ë©”ì„œë“œ &lt;code&gt;Generic Methods&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Generic ë©”ì„œë“œëŠ” ìì‹œì˜ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ê°€ì§„ ë©”ì„œë“œì´ë‹¤. generic íƒ€ì…ì„ ì„ ì–¸í•˜ëŠ” ê²ƒê³¼ ë¹„ìŠ·í•˜ì§€ë§Œ íƒ€ì…ë§¤ê°œë³€ìˆ˜ì˜ ìŠ¤ì½”í”„ëŠ” ë©”ì„œë“œë¡œ ì œí•œëœë‹¤. ì¼ë°˜ ë©”ì„œë“œ, ì •ì  ë©”ì„œë“œ generic í´ë˜ìŠ¤ì˜ ìƒì„±ìëŠ” ì´ ë£°ì„ ë™ì¼í•˜ê²Œ ì ìš©ëœë‹¤.
&lt;code&gt;Generic methods are methods that introduce their own type parameters. This is similar to declaring a generic type, but the type parameter&#39;s scope is limited to the method where it is declared. Static and non-static generic methods are allowed, as well as generic class constructors.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;generic ë©”ì„œë“œ ë¬¸ë²•ì€ return íƒ€ì… ì „ì— êº½ì‡  ì‚¬ì´ì— íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ í‘œê¸°í•œë‹¤. static generic ë©”ì„œë“œë¥¼ ìœ„í•´ íƒ€ì…ë§¤ê°œë³€ìˆ˜ëŠ” ë°˜ë“œì‹œ ë©”ì„œë“œì˜ return íƒ€ì… ì´ì „ì— ìœ„ì¹˜í•´ì•¼í•œë‹¤.
&lt;code&gt;The syntax for a generic method includes a type parameter, inside angle brackets, and appears before the method&#39;s return type. For static generic methods, the type parameter section must appear before the method&#39;s return type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Util í´ë˜ìŠ¤ëŠ” ë‘ Pair ê°ì²´ë¥¼ ë¹„êµí•˜ëŠ” generic ë©”ì„œë“œë¥¼ í¬í•¨í•˜ê³  ìˆìŠµë‹ˆë‹¤.
&lt;code&gt;The Util class includes a generic method, compare, which compares two Pair objects:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Util {
    public static &amp;lt;K, V&amp;gt; boolean compare(Pair&amp;lt;K, V&amp;gt; p1, Pair&amp;lt;K, V&amp;gt; p2) {
        return p1.getKey().equals(p2.getKey()) &amp;amp;&amp;amp;
               p1.getValue().equals(p2.getValue());
    }
}

public class Pair&amp;lt;K, V&amp;gt; {

    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public void setKey(K key) { this.key = key; }
    public void setValue(V value) { this.value = value; }
    public K getKey()   { return key; }
    public V getValue() { return value; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì´ ë©”ì„œë“œë¥¼(static &lt;K, V&gt; boolean compare)ë¥¼ í˜¸ì¶œí•œ ë¬¸ì¥ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.
&lt;code&gt;The complete syntax for invoking this method would be:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Pair&amp;lt;Integer, String&amp;gt; p1 = new Pair&amp;lt;&amp;gt;(1, &amp;quot;apple&amp;quot;);
Pair&amp;lt;Integer, String&amp;gt; p2 = new Pair&amp;lt;&amp;gt;(2, &amp;quot;pear&amp;quot;);
boolean same = Util.&amp;lt;Integer, String&amp;gt;compare(p1, p2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Util.&lt;strong&gt;&amp;lt;Integer, String&amp;gt;&lt;/strong&gt;compare(p1, p2)&lt;br&gt;
ê°•ì¡°í•œ ì˜ì—­ì²˜ëŸ¼ íƒ€ì…ì„ ëª…ì‹œí•˜ì˜€ë‹¤. íƒ€ì…ì¸ìëŠ” ì»´íŒŒì¼ëŸ¬ê°€ íƒ€ì… ì¶”ë¡ í• ë•Œ í•„ìš”í•œ ì •ë³´ê°€ ëœë‹¤.
&lt;code&gt;The type has been explicitly provided, as shown in bold. Generally, this can be left out and the compiler will infer the type that is needed:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Pair&amp;lt;Integer, String&amp;gt; p1 = new Pair&amp;lt;&amp;gt;(1, &amp;quot;apple&amp;quot;);
Pair&amp;lt;Integer, String&amp;gt; p2 = new Pair&amp;lt;&amp;gt;(2, &amp;quot;pear&amp;quot;);
boolean same = Util.compare(p1, p2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ì½”ë“œëŠ” íƒ€ì… ì¶”ë¡ ì„ ë‚˜íƒ€ë‚¸ê²ƒì´ë‹¤. êº½ì‡ ì— íƒ€ì… ëª…ì‹œí•˜ì§€ ì•Šê³  generic ë©”ì„œë“œê°€ ì•„ë‹Œ ì¼ë°˜ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•´ë„ íƒ€ì… ì¶”ë¡ ì´ ì´ë£¨ì–´ì§„ë‹¤. ì´ ì£¼ì œëŠ” ë’¤ì— ë‚˜ì˜¤ëŠ” íƒ€ì… ì¶”ë¡  ì„¹ì…˜ì—ì„œ ë” ë…¼ì˜í•œë‹¤.
&lt;code&gt;This feature, known as type inference, allows you to invoke a generic method as an ordinary method, without specifying a type between angle brackets. This topic is further discussed in the following section, Type Inference.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ìë°” ì œë„¤ë¦­ìŠ¤(4) Java Generics: ì›ì²œ(Raw) íƒ€ì…ë“¤</title>
      <link>http://durtchrt.github.io/blog/java/generics/4/</link>
      <pubDate>Tue, 01 Nov 2016 16:05:56 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/4/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&#34;&gt;ì›ë¬¸ ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ì›ì²œ-íƒ€ì…ë“¤-raw-types&#34;&gt;ì›ì²œ íƒ€ì…ë“¤ &lt;code&gt;Raw Types&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Raw íƒ€ì…ì€ generic í´ë˜ìŠ¤ í˜¹ì€ ì¸í„°í˜ì´ìŠ¤ì— íƒ€ì…ì¸ìê°€ ì—†ëŠ” ê²ƒ. ì˜ˆë¥¼ë“¤ì–´ generic Box í´ë˜ìŠ¤ë¥¼ ë³´ì
&lt;code&gt;A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Box&amp;lt;T&amp;gt; {
    public void set(T t) { /* ... */ }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì•„ë˜ ì½”ë“œë¥¼ ë³´ë©´ Box&lt;T&gt;ì˜ ë§¤ê°œë³€ìˆ˜í™”ëœ íƒ€ì…ì„ ë§Œë“œë©´ì„œ, íƒ€ì…ë§¤ê°œë³€ìˆ˜ Tì— í•´ë‹¹í•˜ëŠ” Integerë¥¼ íƒ€ì…ì¸ìë¡œ ì œê³µí•˜ì˜€ë‹¤.
&lt;code&gt;To create a parameterized type of Box&amp;lt;T&amp;gt;, you supply an actual type argument for the formal type parameter T:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Integer&amp;gt; intBox = new Box&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;íƒ€ì…ì¸ìê°€ ìƒëµëœ ê²½ìš° Box&lt;T&gt;ì˜ Raw íƒ€ì…ì„ ë§Œë“¤ìˆ˜ ìˆë‹¤.
&lt;code&gt;If the actual type argument is omitted, you create a raw type of Box&amp;lt;T&amp;gt;:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box rawBox = new Box();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê²°êµ­, BoxëŠ” generic íƒ€ì… Box&lt;T&gt;ì˜ raw íƒ€ì…ì´ë‹¤. í•˜ì§€ë§Œ, generic í´ë˜ìŠ¤ ë˜ëŠ” ì¸í„°í˜ì´ìŠ¤ê°€ ì•„ë‹Œê²½ìš°ëŠ” raw íƒ€ì…ì´ ë  ìˆ˜ ì—†ë‹¤.()
&lt;code&gt;Therefore, Box is the raw type of the generic type Box&amp;lt;T&amp;gt;. However, a non-generic class or interface type is not a raw type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Raw íƒ€ì…ì€ JDK 5.0 ì´ì „ ìë°” API í´ë˜ìŠ¤ë“¤ì€ ì œë„¤ë¦­ì„ ì§€ì›í•˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì—(ì˜ˆë¥¼ ë“¤ì–´ Collections í´ë˜ìŠ¤) ë ˆê±°ì‹œ ì½”ë“œì—ì„œ ë‚˜íƒ€ë‚œë‹¤. raw íƒ€ì…ì„ ì‚¬ìš©í•  ë•ŒëŠ” ë°˜ë“œì‹œ generics ì´ì „ ë°©ë²•(íƒ€ì… ìºìŠ¤íŒ…)ì„ í•˜ì‹œì˜¤. í•˜ìœ„í˜¸í™˜ì„±ì„ ìœ„í•´, íƒ€ì…ë§¤ê°œë³€ìˆ˜ëŠ” rawíƒ€ì…ì„ í—ˆìš©í•˜ì˜€ë‹¤.
&lt;code&gt;Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior â€” a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;String&amp;gt; stringBox = new Box&amp;lt;&amp;gt;();
Box rawBox = stringBox;               // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;í•˜ì§€ë§Œ íƒ€ì…ë§¤ê°œë³€ìˆ˜ì— raw íƒ€ì…ì„ í• ë‹¹í•˜ë©´ (ì»´íŒŒì¼ëŸ¬ë¡œë¶€í„°) ê²½ê³ ë¥¼ ë°›ìŠµë‹ˆë‹¤.
&lt;code&gt;But if you assign a raw type to a parameterized type, you get a warning:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box rawBox = new Box();           // rawBox is a raw type of Box&amp;lt;T&amp;gt;
Box&amp;lt;Integer&amp;gt; intBox = rawBox;     // warning: unchecked conversion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë˜í•œ generic íƒ€ì…ì— ì •ì˜ëœ generic ë©”ì„œë“œë¥¼ í˜¸ì¶œí• ë•Œì—ë„ raw íƒ€ì…ì„ ì‚¬ìš©í•˜ë©´ ê²½ê³ ë¥¼ ë°›ìŠµë‹ˆë‹¤.
&lt;code&gt;You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;String&amp;gt; stringBox = new Box&amp;lt;&amp;gt;();
Box rawBox = stringBox;
rawBox.set(8);  // warning: unchecked invocation to set(T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê²½ê³ ëŠ” raw íƒ€ì…ë“¤ì´ generic íƒ€ì…ì²´í¬ë¥¼ í• ìˆ˜ ì—†ë‹¤ëŠ” ê²ƒì„ ë³´ì—¬ì¤ë‹ˆë‹¤. (ì»´íŒŒì¼ íƒ€ì„ì— ì²´í¬ë  ìˆ˜ ìˆëŠ”) ë¶ˆì•ˆí•œ ì½”ë“œê°€ ëŸ°íƒ€ì„ì— ë¶™ì¡íˆê²Œ (ì»´íŒŒì¼ íƒ€ì„ ì²´í‚¹ì„ ëŸ°íƒ€ì„ìœ¼ë¡œ) ë”œë ˆì´ ì‹œí‚¤ëŠ” ê²ƒì´ë¯€ë¡œ raw íƒ€ì… ì‚¬ìš©ì€ í”¼í•˜ëŠ”ê²ƒì´ ì¢‹ì„ ê²ƒì´ë‹¤.&lt;br /&gt;
&lt;code&gt;The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;íƒ€ì…ì†Œê±° ì„¹ì…˜ì—ì„œëŠ” ìë°” ì»´íŒŒì¼ëŸ¬ê°€ raw íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì— ëŒ€í•œ ë” ìì„¸í•œ ì„¤ëª…ì´ ìˆë‹¤.
&lt;code&gt;The Type Erasure section has more information on how the Java compiler uses raw types.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;unchecked-error-messages&#34;&gt;Unchecked Error Messages&lt;/h3&gt;

&lt;p&gt;ì´ì „ì— ë§í–‡ë“¯, generic ì½”ë“œì™€ ë ˆê±°ì‹œ ì½”ë“œë¥¼ ì„ê²Œ ë˜ë©´, ì•„ë˜ì™€ ê°™ì€ ê²½ê³  ë©”ì„¸ì§€ë¥¼ ë§ˆì£¼ì¹  ê²ƒì´ë‹¤.
&lt;code&gt;As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Note: Example.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;This can happen when using an older API that operates on raw types, as shown in the following example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WarningDemo {
    public static void main(String[] args){
        Box&amp;lt;Integer&amp;gt; bi;
        bi = createBox();
    }

    static Box createBox(){
        return new Box();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;unchecked(ì²´í¬ë˜ì§€ ì•ŠìŒ)&amp;ldquo;ëŠ” íƒ€ì… ì•ˆì •ì„±ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ í•„ìš”í•œ íƒ€ì…ì²´í¬ ì •ë³´ê°€ ì¶©ë¶„ì¹˜ ì•Šë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤. &amp;ldquo;unchecked&amp;rdquo; ê²½ê³ ëŠ” ì»´íŒŒì¼ëŸ¬ì—ê²Œ ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤.&amp;ldquo;unchecked&amp;rdquo; ê²½ê³ ë¥¼ ë³´ê³  ì‹¶ë‹¤ë©´ -Xlint:uncheckedì˜µì…˜ì„ ì£¼ê³  ë‹¤ì‹œ ì»´íŒŒì¼í•˜ë©´ ëª¨ë“  &amp;ldquo;unchecked&amp;rdquo; ê²½ê³ ë¥¼ ë³¼ ìˆ˜ ìˆë‹¤.
&lt;code&gt;The term &amp;quot;unchecked&amp;quot; means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The &amp;quot;unchecked&amp;quot; warning is disabled, by default, though the compiler gives a hint. To see all &amp;quot;unchecked&amp;quot; warnings, recompile with -Xlint:unchecked.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;-Xlint:unchecked ì˜µì…˜ê³¼ í•¨ê»˜ ì˜ˆì œë¥¼ ë‹¤ì‹œ ì»´íŒŒì¼í•´ë³´ë©´ ì•„ë˜ì— ë³´ì´ëŠ” ë‚´ìš©ì´ ë‚˜íƒ€ë‚  ê²ƒì´ë‹¤.
&lt;code&gt;Recompiling the previous example with -Xlint:unchecked reveals the following additional information:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;WarningDemo.java:4: warning: [unchecked] unchecked conversion
found   : Box
required: Box&amp;lt;java.lang.Integer&amp;gt;
        bi = createBox();
                      ^
1 warning
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì»´íŒŒì¼ ì˜µì…˜ì— -Xlint:-unchecked í”Œë˜ê·¸ë¥¼ ì‚¬ìš©í•˜ë©´ unchecked ê²½ê³ ë¥¼ ì—†ì•¨ ìˆ˜ ìˆë‹¤. @SupporessWarnings(&amp;ldquo;unchecked&amp;rdquo;) ì–´ë…¸í…Œì´ì…˜ì€ unchecked ê²½ê³ ê°€ ë‚˜íƒ€ë‚˜ì§€ ì•Šê²Œ í•  ìˆ˜ ìˆë‹¤. @SupressWarnings ë¬¸ë²•ì´ ìƒì†Œí•˜ë©´ Annotations ì„¹ì…˜ì„ ë³´ì‹œì˜¤. &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/annotations/index.html&#34;&gt;ë§í¬&lt;/a&gt;
&lt;code&gt;To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The @SuppressWarnings(&amp;quot;unchecked&amp;quot;) annotation suppresses unchecked warnings. If you are unfamiliar with the @SuppressWarnings syntax, see Annotations.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ì—­ì ì²¨ë¶€&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ javac WarningDemo.java 

Note: WarningDemo.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
    
$ javac -Xlint:unchecked WarningDemo.java

WarningDemo.java:7: warning: [unchecked] unchecked conversion
        bi = createBox();
                      ^
required: Box&amp;lt;Integer&amp;gt;
found:    Box
1 warning
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>