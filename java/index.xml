<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java-rsses on ê°œë°œ ì €ì¥ì†Œ</title>
    <link>http://durtchrt.github.io/blog/java/index.xml</link>
    <description>Recent content in Java-rsses on ê°œë°œ ì €ì¥ì†Œ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>durtchrt</copyright>
    <lastBuildDate>Tue, 01 Nov 2016 16:05:56 +0900</lastBuildDate>
    <atom:link href="http://durtchrt.github.io/blog/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>java generics ë²ˆì—­ 4</title>
      <link>http://durtchrt.github.io/blog/java/generics/4/</link>
      <pubDate>Tue, 01 Nov 2016 16:05:56 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/4/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&#34;&gt;ì›ë¬¸ ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;raw-types&#34;&gt;Raw Types&lt;/h3&gt;

&lt;p&gt;Raw íƒ€ì…ì€ generic í´ë˜ìŠ¤ í˜¹ì€ ì¸í„°í˜ì´ìŠ¤ì— íƒ€ì…ì¸ìê°€ ì—†ëŠ” ê²ƒ. ì˜ˆë¥¼ë“¤ì–´ generic Box í´ë˜ìŠ¤ë¥¼ ë³´ì
&lt;code&gt;A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Box&amp;lt;T&amp;gt; {
    public void set(T t) { /* ... */ }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì•„ë˜ ì½”ë“œë¥¼ ë³´ë©´ Box&lt;T&gt;ì˜ ë§¤ê°œë³€ìˆ˜í™”ëœ íƒ€ì…ì„ ë§Œë“œë©´ì„œ, íƒ€ì…ë§¤ê°œë³€ìˆ˜ Tì— í•´ë‹¹í•˜ëŠ” Integerë¥¼ íƒ€ì…ì¸ìë¡œ ì œê³µí•˜ì˜€ë‹¤.
&lt;code&gt;To create a parameterized type of Box&amp;lt;T&amp;gt;, you supply an actual type argument for the formal type parameter T:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Integer&amp;gt; intBox = new Box&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;íƒ€ì…ì¸ìê°€ ìƒëµëœ ê²½ìš° Box&lt;T&gt;ì˜ Raw íƒ€ì…ì„ ë§Œë“¤ìˆ˜ ìˆë‹¤.
&lt;code&gt;If the actual type argument is omitted, you create a raw type of Box&amp;lt;T&amp;gt;:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box rawBox = new Box();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê²°êµ­, BoxëŠ” generic íƒ€ì… Box&lt;T&gt;ì˜ raw íƒ€ì…ì´ë‹¤. í•˜ì§€ë§Œ, generic í´ë˜ìŠ¤ ë˜ëŠ” ì¸í„°í˜ì´ìŠ¤ê°€ ì•„ë‹Œê²½ìš°ëŠ” raw íƒ€ì…ì´ ë  ìˆ˜ ì—†ë‹¤.()
&lt;code&gt;Therefore, Box is the raw type of the generic type Box&amp;lt;T&amp;gt;. However, a non-generic class or interface type is not a raw type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Raw íƒ€ì…ì€ JDK 5.0 ì´ì „ ìë°” API í´ë˜ìŠ¤ë“¤ì€ ì œë„¤ë¦­ì„ ì§€ì›í•˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì—(ì˜ˆë¥¼ ë“¤ì–´ Collections í´ë˜ìŠ¤) ë ˆê±°ì‹œ ì½”ë“œì—ì„œ ë‚˜íƒ€ë‚œë‹¤. raw íƒ€ì…ì„ ì‚¬ìš©í•  ë•ŒëŠ” ë°˜ë“œì‹œ generics ì´ì „ ë°©ë²•(íƒ€ì… ìºìŠ¤íŒ…)ì„ í•˜ì‹œì˜¤. í•˜ìœ„í˜¸í™˜ì„±ì„ ìœ„í•´, íƒ€ì…ë§¤ê°œë³€ìˆ˜ëŠ” rawíƒ€ì…ì„ í—ˆìš©í•˜ì˜€ë‹¤.
&lt;code&gt;Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior â€” a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;String&amp;gt; stringBox = new Box&amp;lt;&amp;gt;();
Box rawBox = stringBox;               // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;í•˜ì§€ë§Œ íƒ€ì…ë§¤ê°œë³€ìˆ˜ì— raw íƒ€ì…ì„ í• ë‹¹í•˜ë©´ (ì»´íŒŒì¼ëŸ¬ë¡œë¶€í„°) ê²½ê³ ë¥¼ ë°›ìŠµë‹ˆë‹¤.
&lt;code&gt;But if you assign a raw type to a parameterized type, you get a warning:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box rawBox = new Box();           // rawBox is a raw type of Box&amp;lt;T&amp;gt;
Box&amp;lt;Integer&amp;gt; intBox = rawBox;     // warning: unchecked conversion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë˜í•œ generic íƒ€ì…ì— ì •ì˜ëœ generic ë©”ì„œë“œë¥¼ í˜¸ì¶œí• ë•Œì—ë„ raw íƒ€ì…ì„ ì‚¬ìš©í•˜ë©´ ê²½ê³ ë¥¼ ë°›ìŠµë‹ˆë‹¤.
&lt;code&gt;You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;String&amp;gt; stringBox = new Box&amp;lt;&amp;gt;();
Box rawBox = stringBox;
rawBox.set(8);  // warning: unchecked invocation to set(T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê²½ê³ ëŠ” raw íƒ€ì…ë“¤ì´ generic íƒ€ì…ì²´í¬ë¥¼ í• ìˆ˜ ì—†ë‹¤ëŠ” ê²ƒì„ ë³´ì—¬ì¤ë‹ˆë‹¤. (ì»´íŒŒì¼ íƒ€ì„ì— ì²´í¬ë  ìˆ˜ ìˆëŠ”) ë¶ˆì•ˆí•œ ì½”ë“œê°€ ëŸ°íƒ€ì„ì— ë¶™ì¡íˆê²Œ (ì»´íŒŒì¼ íƒ€ì„ ì²´í‚¹ì„ ëŸ°íƒ€ì„ìœ¼ë¡œ) ë”œë ˆì´ ì‹œí‚¤ëŠ” ê²ƒì´ë¯€ë¡œ raw íƒ€ì… ì‚¬ìš©ì€ í”¼í•˜ëŠ”ê²ƒì´ ì¢‹ì„ ê²ƒì´ë‹¤.&lt;br /&gt;
&lt;code&gt;The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;íƒ€ì…ì†Œê±° ì„¹ì…˜ì—ì„œëŠ” ìë°” ì»´íŒŒì¼ëŸ¬ê°€ raw íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì— ëŒ€í•œ ë” ìì„¸í•œ ì„¤ëª…ì´ ìˆë‹¤.
&lt;code&gt;The Type Erasure section has more information on how the Java compiler uses raw types.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;unchecked-error-messages&#34;&gt;Unchecked Error Messages&lt;/h3&gt;

&lt;p&gt;ì´ì „ì— ë§í–‡ë“¯, generic ì½”ë“œì™€ ë ˆê±°ì‹œ ì½”ë“œë¥¼ ì„ê²Œ ë˜ë©´, ì•„ë˜ì™€ ê°™ì€ ê²½ê³  ë©”ì„¸ì§€ë¥¼ ë§ˆì£¼ì¹  ê²ƒì´ë‹¤.
&lt;code&gt;As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Note: Example.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;This can happen when using an older API that operates on raw types, as shown in the following example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WarningDemo {
    public static void main(String[] args){
        Box&amp;lt;Integer&amp;gt; bi;
        bi = createBox();
    }

    static Box createBox(){
        return new Box();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;unchecked(ì²´í¬ë˜ì§€ ì•ŠìŒ)&amp;ldquo;ëŠ” íƒ€ì… ì•ˆì •ì„±ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ í•„ìš”í•œ íƒ€ì…ì²´í¬ ì •ë³´ê°€ ì¶©ë¶„ì¹˜ ì•Šë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤. &amp;ldquo;unchecked&amp;rdquo; ê²½ê³ ëŠ” ì»´íŒŒì¼ëŸ¬ì—ê²Œ ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤.&amp;ldquo;unchecked&amp;rdquo; ê²½ê³ ë¥¼ ë³´ê³  ì‹¶ë‹¤ë©´ -Xlint:uncheckedì˜µì…˜ì„ ì£¼ê³  ë‹¤ì‹œ ì»´íŒŒì¼í•˜ë©´ ëª¨ë“  &amp;ldquo;unchecked&amp;rdquo; ê²½ê³ ë¥¼ ë³¼ ìˆ˜ ìˆë‹¤.
&lt;code&gt;The term &amp;quot;unchecked&amp;quot; means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The &amp;quot;unchecked&amp;quot; warning is disabled, by default, though the compiler gives a hint. To see all &amp;quot;unchecked&amp;quot; warnings, recompile with -Xlint:unchecked.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;-Xlint:unchecked ì˜µì…˜ê³¼ í•¨ê»˜ ì˜ˆì œë¥¼ ë‹¤ì‹œ ì»´íŒŒì¼í•´ë³´ë©´ ì•„ë˜ì— ë³´ì´ëŠ” ë‚´ìš©ì´ ë‚˜íƒ€ë‚  ê²ƒì´ë‹¤.
&lt;code&gt;Recompiling the previous example with -Xlint:unchecked reveals the following additional information:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;WarningDemo.java:4: warning: [unchecked] unchecked conversion
found   : Box
required: Box&amp;lt;java.lang.Integer&amp;gt;
        bi = createBox();
                      ^
1 warning
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì»´íŒŒì¼ ì˜µì…˜ì— -Xlint:-unchecked í”Œë˜ê·¸ë¥¼ ì‚¬ìš©í•˜ë©´ unchecked ê²½ê³ ë¥¼ ì—†ì•¨ ìˆ˜ ìˆë‹¤. @SupporessWarnings(&amp;ldquo;unchecked&amp;rdquo;) ì–´ë…¸í…Œì´ì…˜ì€ unchecked ê²½ê³ ê°€ ë‚˜íƒ€ë‚˜ì§€ ì•Šê²Œ í•  ìˆ˜ ìˆë‹¤. @SupressWarnings ë¬¸ë²•ì´ ìƒì†Œí•˜ë©´ Annotations ì„¹ì…˜ì„ ë³´ì‹œì˜¤. &lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/annotations/index.html&#34;&gt;ë§í¬&lt;/a&gt;
&lt;code&gt;To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The @SuppressWarnings(&amp;quot;unchecked&amp;quot;) annotation suppresses unchecked warnings. If you are unfamiliar with the @SuppressWarnings syntax, see Annotations.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ì—­ì ì²¨ë¶€&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ javac WarningDemo.java 

Note: WarningDemo.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
    
$ javac -Xlint:unchecked WarningDemo.java

WarningDemo.java:7: warning: [unchecked] unchecked conversion
        bi = createBox();
                      ^
required: Box&amp;lt;Integer&amp;gt;
found:    Box
1 warning
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>java generics ë²ˆì—­ 3</title>
      <link>http://durtchrt.github.io/blog/java/generics/3/</link>
      <pubDate>Mon, 31 Oct 2016 17:08:57 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/3/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/types.html&#34;&gt;ì›ë¬¸ ë§í¬&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ìš©ì–´ ì°¸ì¡°&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;íƒ€ì… : ìë°”ì—ì„œëŠ” í´ë˜ìŠ¤, ì¶”ìƒí´ë˜ìŠ¤, ì¸í„°í˜ì´ìŠ¤, ì—´ê±°í˜•(Enum), ë°°ì—´ì„ ì˜ë¯¸. ê¸°ë³¸í˜•, ì°¸ì¡°í˜•ì„ í¬ê´„í•˜ëŠ” ê°œë…

&lt;ul&gt;
&lt;li&gt;ê¸°ë³¸í˜•: byte, short, int, long, float, double, char, String, boolean (call by value)&lt;/li&gt;
&lt;li&gt;ì°¸ì¡°í˜•: ê¸°ë³¸í˜•ì„ ì œì™¸í•œ ëª¨ë“  íƒ€ì… (call by reference)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ë§¤ê°œë³€ìˆ˜ vs ì¸ì&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ë§¤ê°œë³€ìˆ˜(Parameter): í•¨ìˆ˜ ì„ ì–¸í•  ë•Œ ë³€ìˆ˜ì˜ ì´ë¦„&lt;/li&gt;
&lt;li&gt;ì¸ì(Argument): í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ ì „ë‹¬í•˜ëŠ” ê°’&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;generic-types&#34;&gt;Generic Types&lt;/h3&gt;

&lt;p&gt;generic íƒ€ì…ì€ í´ë˜ìŠ¤, ì¸í„°í˜ì´ìŠ¤ë¥¼ íƒ€ì… íŒŒë¼ë¯¸í„°í™”í•˜ëŠ” ê²ƒì´ë‹¤. Box í´ë˜ìŠ¤ëŠ” generic  íƒ€ì…ì„ ì„¤ëª…í•˜ë©´ì„œ ì½”ë“œë¥¼ ìˆ˜ì •í•  ê²ƒì´ë‹¤.
&lt;code&gt;A generic type is a generic class or interface that is parameterized over types. The following Box class will be modified to demonstrate the concept.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-simple-box-class&#34;&gt;A Simple Box Class&lt;/h3&gt;

&lt;p&gt;genericì„ ì‚¬ìš©í•˜ì§€ ì•Šì€ ì˜ˆì œë¡œ ì‹œì‘í•´ë´…ì‹œë‹¤. Box í´ë˜ìŠ¤ëŠ” set(ì¶”ê°€), get(ì¡°íšŒ) 2ê°œì˜ ë©”ì„œë“œê°€ ìˆìŠµë‹ˆë‹¤.
&lt;code&gt;Begin by examining a non-generic Box class that operates on objects of any type. It needs only to provide two methods: set, which adds an object to the box, and get, which retrieves it:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Box {
    private Object object;

    public void set(Object object) { this.object = object; }
    public Object get() { return object; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ê°ì²´ì˜ set, get ë©”ì„œë“œëŠ” ê¸°ë³¸í˜•ì„ ì œì™¸í•˜ë©´ ì–´ë–¤ íƒ€ì…(ì°¸ì¡°í˜•)ì´ë“  ì¸ìë¡œ ë„£ì„ìˆ˜ ìˆë‹¤. Box í´ë˜ìŠ¤ê°€ ì‚¬ìš©ë˜ì–´ì§€ì§€ë§Œ ì»´íŒŒì¼ íƒ€ì„ì— ê²€ì¦í•  ë°©ë²•ì´ ì—†ë‹¤. ì½”ë“œ ì¼ë¶€ë¶„ì—ì„œëŠ” Integerë¥¼ ë„£ê³  Integerê°€ returnë˜ì–´ì§€ê¸¸ ê¸°ëŒ€í•˜ì§€ë§Œ ë‹¤ë¥¸ ì¼ë¶€ë¶„ì—ì„œëŠ” ì‹¤ìˆ˜ë¡œ Stringì„ ì…ë ¥í•´ì„œ ëŸ°íƒ€ì„ ì—ëŸ¬ê°€ ë‚˜ì˜¬ ê²ƒì´ë‹¤.
&lt;code&gt;Since its methods accept or return an Object, you are free to pass in whatever you want, provided that it is not one of the primitive types. There is no way to verify, at compile time, how the class is used. One part of the code may place an Integer in the box and expect to get Integers out of it, while another part of the code may mistakenly pass in a String, resulting in a runtime error.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;generic-ë²„ì „ì˜-box-í´ë˜ìŠ¤-br&#34;&gt;Generic ë²„ì „ì˜ Box í´ë˜ìŠ¤.&lt;br&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;A Generic Version of the Box Class&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;generic í´ë˜ì‹œëŠ” ì•„ë˜ í¬ë©§ì²˜ëŸ¼ ì •ì˜ë˜ì—ˆë‹¤.&lt;br&gt;
&lt;code&gt;A generic class is defined with the following format:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class name&amp;lt;T1, T2, ..., Tn&amp;gt; { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;íƒ€ì… íŒŒë¼ë¯¸í„° ë¬¸ë²•ì€ í´ë˜ìŠ¤ëª… ë’¤ì— êº½ì‡ (&amp;lt;&amp;gt;) ê¸°í˜¸ë¡œ êµ¬ë¶„ëœë‹¤. ì´ê²ƒì€ T1, T2, &amp;hellip;, and Tn ë“±ìœ¼ë¡œ íƒ€ì… ë§¤ê°œë³€ìˆ˜ë¥¼ ëª…ì‹œí•œë‹¤.(íƒ€ì…ë³€ìˆ˜ë¼ê³  ë¶ˆë¦¬ê¸°ë„í•œë‹¤.)
&lt;code&gt;The type parameter section, delimited by angle brackets (&amp;lt;&amp;gt;), follows the class name. It specifies the type parameters (also called type variables) T1, T2, ..., and Tn.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Box í´ë˜ìŠ¤ë¥¼ genericsë¡œ ë³€ê²½í•´ë³´ì. &amp;ldquo;public class Box&amp;rdquo; ì½”ë“œë¥¼ &amp;ldquo;public class Box&lt;T&gt;&amp;ldquo;ë¡œ ë³€ê²½í•´ì„œ generic íƒ€ì…ì„ ì„ ì–¸í•˜ì—¬ ë§Œë“ ë‹¤. Të¼ëŠ” íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” í´ë˜ìŠ¤ ì–´ë””ë“ ì§€ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë³€ìˆ˜ì´ë‹¤.
&lt;code&gt;To update the Box class to use generics, you create a generic type declaration by changing the code &amp;quot;public class Box&amp;quot; to &amp;quot;public class Box&amp;lt;T&amp;gt;&amp;quot;. This introduces the type variable, T, that can be used anywhere inside the class.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Box í´ë˜ìŠ¤ê°€ ì´ë ‡ê²Œ ë°”ë€ë‹¤.&lt;br&gt;
&lt;code&gt;With this change, the Box class becomes:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Generic version of the Box class.
 * @param &amp;lt;T&amp;gt; the type of the value being boxed
 */
public class Box&amp;lt;T&amp;gt; {
    // T stands for &amp;quot;Type&amp;quot;
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì†ŒìŠ¤ ì½”ë“œ ë³€ê²½ì—ì„œ ë³´ì´ë“¯, ê¸°ì¡´ ì½”ë“œì—ì„œ Object ëŒ€ì‹  Të¡œ ìˆ˜ì •ë˜ì—ˆë‹¤. Type ë³€ìˆ˜ëŠ” ê¸°ë³¸í˜• ë¹¼ê³ ëŠ”(=ì°¸ì¡°í˜•)ì´ë©´ ëœë‹¤.(í´ë˜ìŠ¤/ì¸í„°í˜ì´ìŠ¤/ë°°ì—´ íƒ€ì… ë˜ëŠ” ë‹¤ë¥¸ Type ë³€ìˆ˜ê°€ Type ë³€ìˆ˜ë¡œ ë  ìˆ˜ ìˆë‹¤.)
&lt;code&gt;As you can see, all occurrences of Object are replaced by T. A type variable can be any non-primitive type you specify: any class type, any interface type, any array type, or even another type variable.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;generic ì¸í„°í˜ì´ìŠ¤ë¥¼ ë§Œë“œëŠ” ë°©ë²•ë„ ê°™ë‹¤.
&amp;lsquo;This same technique can be applied to create generic interfaces.&amp;rsquo;&lt;/p&gt;

&lt;h3 id=&#34;type-íŒŒë¼ë¯¸í„°-ë„¤ì´ë°-ê´€ìŠµ&#34;&gt;Type íŒŒë¼ë¯¸í„° ë„¤ì´ë° ê´€ìŠµ&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Type Parameter Naming Conventions&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ê´€ìŠµì— ì˜í•˜ë©´, Type íŒŒë¼ë¯¸í„°ëŠ” ë‹¨ì¼ ëŒ€ë¬¸ìì…ë‹ˆë‹¤. ì´ ê¸°ì¤€ì€ ì´ë¯¸ ì•Œê³  ìˆëŠ” ë³€ìˆ˜ ë„¤ì´ë° ê´€ìŠµì— ê·¹ëª…í•˜ê²Œ ë°˜ëŒ€ì…ë‹ˆë‹¤. (ì¢‹ì€ì ì€)ì´ëŸ° ê´€ìŠµì´ ì—†ìœ¼ë©´ Type ë³€ìˆ˜ì™€ ì¼ë°˜ì ì¸ í´ë˜ìŠ¤ í˜¹ì€ ì¸í„°í˜ì´ìŠ¤ëª… ì‚¬ì´ì— ì°¨ì´ë¥¼ ì „ë‹¬í•˜ê¸° ì–´ë ¤ìš¸ê²ë‹ˆë‹¤.
&lt;code&gt;By convention, type parameter names are single, uppercase letters. This stands in sharp contrast to the variable naming conventions that you already know about, and with good reason: Without this convention, it would be difficult to tell the difference between a type variable and an ordinary class or interface name.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ìš©ë˜ì–´ì§€ëŠ” TypeíŒŒë¼ë¯¸í„°ëª…&lt;br&gt;
&lt;code&gt;The most commonly used type parameter names are:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E - Element (ìë°” ì½œë ‰ì…˜ í”„ë ˆì¸ì›Œí¬ì— ê´‘ë²”ìœ„í•˜ê²Œ ì‚¬ìš©ë¨ - used extensively by the Java Collections Framework)
K - Key
N - Number
T - Type
V - Value
S,U,V etc. - 2nd, 3rd, 4th types
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì´ëŸ¬í•œ ì´ë¦„ë“¤ì´ ìë°”SE APIì„ í†µí•´ ì“°ì—¬ì§€ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆì„ ê²ƒì…ë‹ˆë‹¤.
&lt;code&gt;You&#39;ll see these names used throughout the Java SE API and the rest of this lesson.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;generic-type-í˜¸ì¶œê³¼-ê°ì²´-ìƒì„±&#34;&gt;Generic Type í˜¸ì¶œê³¼ ê°ì²´ ìƒì„±&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Invoking and Instantiating a Generic Type&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì½”ë“œë‚´ì— generic Box í´ë˜ìŠ¤ë¥¼ ì°¸ì¡°í•˜ë ¤ë©´, generic Typeì„ í˜¸ì¶œí•´ Integer ê°™ì€ êµ¬í˜„ê°’(íƒ€ì…ê°’)ìœ¼ë¡œ Të¥¼ êµì²´í•©ë‹ˆë‹¤.
&lt;code&gt;To reference the generic Box class from within your code, you must perform a generic type invocation, which replaces T with some concrete value, such as Integer:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Integer&amp;gt; integerBox;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;í”í•œ ë©”ì†Œë“œ í˜¸ì¶œê³¼ generic type í˜¸ì¶œì´ ë¹„ìŠ·í•˜ê³  ìƒê°í•  ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ &lt;strong&gt;ë©”ì†Œë“œ&lt;/strong&gt;ì— ì¸ìë¥¼ ì „ë‹¬í•˜ëŠ” ë°˜ë©´ì— Box &lt;strong&gt;í´ë˜ìŠ¤&lt;/strong&gt;ì— type ì¸ìë¥¼ ì „ë‹¬í•œë‹¤(ì´ë²ˆì—ëŠ” Integerì„).
&lt;code&gt;You can think of a generic type invocation as being similar to an ordinary method invocation, but instead of passing an argument to a method, you are passing a type argument â€” Integer in this case â€” to the Box class itself.&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;Type íŒŒë¼ë¯¸í„°&#39;, &#39;Type ì¸ì&#39; ìš©ì–´ ì„¤ëª…: ë§ì€ ê°œë°œìë“¤ì€ &amp;quot;type íŒŒë¼ë¯¸í„°&amp;quot;ì™€ &amp;quot;type ì¸ì&amp;quot;ë¥¼ í˜¼ìš©í•´ì„œ ì‚¬ìš©í•œë‹¤. í•˜ì§€ë§Œ ì´ ìš©ì–´ë‚˜ ê°™ì§€ ì•Šë‹¤. ì½”ë”©í•  ë•Œ íŒŒë¼ë¯¸í„°í™”í•œ typeì„ ìƒì„±í•˜ê¸° ìœ„í•´ì„œ typeì¸ìë¥¼ ë§Œë“ ë‹¤. ê·¸ ê²°ê³¼, Foo&amp;lt;T&amp;gt;ì˜ TëŠ” Type íŒŒë¼ë¯¸í„°ì´ê³  Foo&amp;lt;String&amp;gt;ì˜ Stringì€  Type ì¸ìì´ë‹¤. ì´ë²ˆì¥ì—ì„œ Type ì¸ìì™€ Type íŒŒë¼ë¯¸í„°ë¥¼ ì‚¬ìš©í•  ë•Œ ìœ„ì— ì„¤ëª…í•œ ë‚´ìš©ì„ ìƒê¸°í•˜ê³  ì‚´í´ë´…ì‹œë‹¤.

`Type Parameter and Type Argument Terminology: Many developers use the terms &amp;quot;type parameter&amp;quot; and &amp;quot;type argument&amp;quot; interchangeably, but these terms are not the same. When coding, one provides type arguments in order to create a parameterized type. Therefore, the T in Foo&amp;lt;T&amp;gt; is a type parameter and the String in Foo&amp;lt;String&amp;gt; f is a type argument. This lesson observes this definition when using these terms.`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë‹¤ë¥¸ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ë“¯ì´, ì´ ì½”ë“œëŠ” ìƒˆë¡œìš´ Box ê°ì²´ë¥¼ ì‹¤ì œë¡œ ìƒì„±í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê°„ë‹¨íˆ ë§í•˜ë©´ integerBox ë³€ìˆ˜ëŠ” &amp;ldquo;Integer íƒ€ì…ì˜ Box í´ë˜ìŠ¤&amp;rdquo;ë¥¼ ê°€ë¦¬í‚¨ë‹¤.( Box&lt;Integer&gt;ëŠ” &amp;ldquo;Box of Integer&amp;rdquo;ë¼ê³  ì½ëŠ”ë‹¤.)
Like any other variable declaration, this code does not actually create a new Box object. It simply declares that integerBox will hold a reference to a &amp;ldquo;Box of Integer&amp;rdquo;, which is how Box&lt;Integer&gt; is read.&lt;/p&gt;

&lt;p&gt;generic íƒ€ì… í˜¸ì¶œì€ ì¼ë°˜ì ìœ¼ë¡œ íŒŒë¼ë¯¸í„°í™”ëœ typeìœ¼ë¡œ ì•Œë ¤ì ¸ ìˆë‹¤.
&lt;code&gt;An invocation of a generic type is generally known as a parameterized type.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;í´ë˜ìŠ¤ë¥¼ ê°ì²´í™”í• ë•Œ ì‚¬ìš©í•˜ëŠ” new í‚¤ì›Œë“œëŠ” ê¸°ì¡´ê³¼ ê°™ì§€ë§Œ Genericsë¥¼ ìœ„í•œ í‘œê¸°ë²•ìœ¼ë¡œ  &lt;strong&gt;&lt;Integer&gt;&lt;/strong&gt;ê°€ í´ë˜ìŠ¤ëª…ê³¼ ì†Œê´„í˜¸(()) ì‚¬ì´ì— ìˆë‹¤.
&lt;code&gt;To instantiate this class, use the new keyword, as usual, but place &amp;lt;Integer&amp;gt; between the class name and the parenthesis:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Box&amp;lt;Integer&amp;gt; integerBox = new Box&amp;lt;Integer&amp;gt;();
````
### ë‹¤ì´ì•„ëª¬ë“œ ì—°ì‚°ì(&amp;lt;&amp;gt;) `The Diamond`

ìë°”SE 7ë¶€í„° ì»´íŒŒì¼ëŸ¬ê°€ ì½”ë“œì˜ ë¬¸ë§¥ì„ ë³´ê³  íƒ€ì…ì„ ì¶”ë¡  í• ìˆ˜ ìˆê²Œ ë˜ì–´ íƒ€ì… ì¸ìê°€ í•„ìš”í•œ ë¶€ë¶„ì— empty type argument(ë¹ˆ type ì¸ì = &amp;lt;&amp;gt;)ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. êº½ì‡ (&amp;lt;&amp;gt;)ëŠ” ë¹„ê³µì‹ì ì´ì§€ë§Œ ë‹¤ì´ì•„ëª¬ë“œë¼ê³  ë¶ˆë¦°ë‹¤. ì˜ˆë¥¼ ë“¤ë©´, Box&amp;lt;Integer&amp;gt; ê°ì²´ë¥¼ ìƒì„±í• ë•Œ ì•„ë˜ì˜ ë¬¸ë²•ì„ ë”°ë¥¸ë‹¤:
`In Java SE 7 and later, you can replace the type arguments required to invoke the constructor of a generic class with an empty set of type arguments (&amp;lt;&amp;gt;) as long as the compiler can determine, or infer, the type arguments from the context. This pair of angle brackets, &amp;lt;&amp;gt;, is informally called the diamond. For example, you can create an instance of Box&amp;lt;Integer&amp;gt; with the following statement:`

```java
Box&amp;lt;Integer&amp;gt; integerBox = new Box&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ë‹¤ì´ì•„ëª¬ë“œ í‘œê¸°ë²•ê³¼ íƒ€ì… ì¶”ë¡ ì— ëŒ€í•œ ë” ìì„¸í•œ ì •ë³´ëŠ” íƒ€ì… ì¶”ë¡ ì„ ë³´ì‹œì˜¤.
&lt;code&gt;For more information on diamond notation and type inference, see Type Inference.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;ë³µìˆ˜ê°œì˜-íƒ€ì…ë§¤ê°œë³€ìˆ˜&#34;&gt;ë³µìˆ˜ê°œì˜ íƒ€ì…ë§¤ê°œë³€ìˆ˜&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Multiple Type Parameters&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì´ì „ì— ë§í–ˆë“¯ì´, generic í´ë˜ìŠ¤ëŠ” ì—¬ëŸ¬ê°œì˜ íƒ€ì…ë§¤ê°œë³€ìˆ˜ë¥¼ ê°€ì§ˆìˆ˜ ìˆë‹¤. ì˜ˆë¥¼ë“¤ì–´, generic OrderdPairí´ë˜ìŠ¤ëŠ” generic Pair ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ì˜€ë‹¤.
&lt;code&gt;As mentioned previously, a generic class can have multiple type parameters. For example, the generic OrderedPair class, which implements the generic Pair interface:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Pair&amp;lt;K, V&amp;gt; {
    public K getKey();
    public V getValue();
}

public class OrderedPair&amp;lt;K, V&amp;gt; implements Pair&amp;lt;K, V&amp;gt; {

    private K key;
    private V value;

    public OrderedPair(K key, V value) {
	this.key = key;
	this.value = value;
    }

    public K getKey()	{ return key; }
    public V getValue() { return value; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì•„ë˜ëŠ” OrderedPairí´ë˜ìŠ¤ë¡œ ë‘ê°œì˜ ê°ì²´ë¥¼ ë§Œë“œëŠ” ì½”ë“œì´ë‹¤.
&lt;code&gt;The following statements create two instantiations of the OrderedPair class:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Pair&amp;lt;String, Integer&amp;gt; p1 = new OrderedPair&amp;lt;String, Integer&amp;gt;(&amp;quot;Even&amp;quot;, 8);
Pair&amp;lt;String, String&amp;gt;  p2 = new OrderedPair&amp;lt;String, String&amp;gt;(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ì½”ë“œëŠ” OrderedPair&lt;String, Integer&gt; ê°ì²´ë¥¼ ìƒì„±í•˜ë©´, KëŠ” String íƒ€ì…ì´ê³  VëŠ” Integer íƒ€ì…ì´ë‹¤. Orderedpairì˜ ìƒì„±ìì˜ íŒŒë¼ë¯¸í„° íƒ€ì…ë“¤ì€ String, Integerì´ë‹¤.  autoboxingì„ í†µí•´ Stringê³¼ intë¥¼ OrderedPairí´ë˜ìŠ¤ì— ì „ë‹¬í•´ë„ ë¬¸ì œì—†ë‹¤.(ì°¸ì¡°í˜•ì€ ìƒê´€ ì—†ëŠ”ë° ê¸°ë³¸í˜•ì¸ intëŠ” ì°¸ì¡°í˜•ìœ¼ë¡œ ë³€ê²½ë˜ì–´ì•¼í•œë‹¤. int -&amp;gt; Integer) 
&lt;code&gt;The code, new OrderedPair&amp;lt;String, Integer&amp;gt;, instantiates K as a String and V as an Integer. Therefore, the parameter types of OrderedPair&#39;s constructor are String and Integer, respectively. Due to autoboxing, it is valid to pass a String and an int to the class.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ì´ì „ì— ë‹¤ì•„ëª¬ë“œ ì—°ì‚°ìë¥¼ ì–¸ê¸‰í–ˆë“¯ì´, ìë°” ì»´íŒŒì¼ëŸ¬ëŠ” OrderedPair&lt;String, Integer&gt;ë¡œ ì„ ì–¸í•œ K, V íƒ€ì…ì„ ì¶”ë¡  í• ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ë‹¤ì´ì•„ëª¬ë“œë¬¸ë²•ì„ ì‚¬ìš©í•´ì„œ ì½”ë“œë¥¼ ì¤„ì¼ìˆ˜ ìˆë‹¤.
&lt;code&gt;As mentioned in The Diamond, because a Java compiler can infer the K and V types from the declaration OrderedPair&amp;lt;String, Integer&amp;gt;, these statements can be shortened using diamond notation:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;OrderedPair&amp;lt;String, Integer&amp;gt; p1 = new OrderedPair&amp;lt;&amp;gt;(&amp;quot;Even&amp;quot;, 8);
OrderedPair&amp;lt;String, String&amp;gt;  p2 = new OrderedPair&amp;lt;&amp;gt;(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generic ì¸í„°í˜ì´ìŠ¤ë¥¼ ìƒì„±í•˜ëŠ”ê²ƒì€ generic í´ë˜ìŠ¤ë¥¼ ë§Œë“œëŠ” ë°©ë²•ê³¼ ê°™ë‹¤
&lt;code&gt;To create a generic interface, follow the same conventions as for creating a generic class.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;íƒ€ì…-íŒŒë¼ë¯¸í„°í™”&#34;&gt;íƒ€ì… íŒŒë¼ë¯¸í„°í™”&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Parameterized Types&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ë§¤ê°œë³€ìˆ˜íƒ€ì…(ì˜ˆ K, V)ì€  ë§¤ê°œë³€ìˆ˜í™”ëœ íƒ€ì…(ì˜ˆ List&lt;String&gt;)ìœ¼ë¡œ ëŒ€ì²´í•  ìˆ˜ ìˆë‹¤. OrderedPair&lt;K, V&gt;ë¥¼ ì˜ˆë¥¼ ë“¤ë©´:
&lt;code&gt;You can also substitute a type parameter (i.e., K or V) with a parameterized type (i.e., List&amp;lt;String&amp;gt;). For example, using the OrderedPair&amp;lt;K, V&amp;gt; example:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;OrderedPair&amp;lt;String, Box&amp;lt;Integer&amp;gt;&amp;gt; p = new OrderedPair&amp;lt;&amp;gt;(&amp;quot;primes&amp;quot;, new Box&amp;lt;Integer&amp;gt;(...));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ìœ„ì˜ ì½”ë“œì—ì„œ ë§¤ê°œë³€ìˆ˜í™”ëœ íƒ€ì…(Parameterized Type)ì€ ìœ„ì˜ ì†ŒìŠ¤ì—ì„œëŠ” &lt;strong&gt;Box&amp;lt;Integer&amp;gt;&lt;/strong&gt;ì„ ì˜ë¯¸&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java Generics ë²ˆì—­ 2</title>
      <link>http://durtchrt.github.io/blog/java/generics/2/</link>
      <pubDate>Mon, 31 Oct 2016 15:52:48 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/2/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/why.html&#34;&gt;ì›ë¬¸&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GenericsëŠ” ì™œ ì‚¬ìš©í•˜ëŠ”ê°€&lt;/strong&gt;  (Why Use Generics?)&lt;/p&gt;

&lt;p&gt;ê°„ë‹¨íˆ ë§í•˜ë©´, genericsëŠ” íƒ€ì…ì„ í´ë˜ìŠ¤, ì¸í„°í˜ì´ìŠ¤, ë©”ì†Œë“œë¥¼ ì •ì˜í•  ë•Œ íŒŒë¼ë©”í„°í™” í•  ìˆ˜ ìˆë‹¤. ë©”ì†Œë“œ ì„ ì–¸ì— ì‚¬ìš©ë˜ëŠ” íŒŒë¼ë¯¸í„° í˜•ì‹ì²˜ëŸ¼, íƒ€ì… íŒŒë¼ë¯¸í„°ëŠ” ë‹¤ë¥¸ ì…ë ¥ê°’ì„ ê°™ì€ ì½”ë“œë¥¼ ì¬ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì„ ì œì‹œí•œë‹¤. ë‹¤ë¥¸ì ì€ í˜•ì‹ íŒŒë¼ë¯¸í„°ëŠ” ê°’ì´ ì…ë ¥ì´ë‹¤, íƒ€ì… íŒŒë¼ë©”í„°ëŠ” íƒ€ì…ì´ ì…ë ¥ì´ë‹¤.
&lt;code&gt;In a nutshell, generics enable types (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar formal parameters used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to type parameters are types.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;genericë¥¼ ì‚¬ìš©í•œ ì½”ë“œëŠ” ê·¸ë ‡ì§€ ì•ŠëŠ” ì½”ë“œ ëŒ€ë¹„ ë§ì€ ì¥ì ì„ ê°€ì¡Œë‹¤:
&lt;code&gt;Code that uses generics has many benefits over non-generic code&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ì»´íŒŒì¼ íƒ€ì„ì— ê°•ë ¥í•œ íƒ€ì… ì²´í¬ë¥¼í•œë‹¤.
&lt;code&gt;Stronger type checks at compile time.&lt;/code&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ìë°” ì»´íŒŒì¼ëŸ¬ëŠ” íƒ€ì… ì•ˆì „ì„±ì— ìœ„ë°˜í•˜ëŠ” ì½”ë“œê°€ ìˆë‹¤ë©´ ì¼ë°˜ì ì¸ ì½”ë“œì™€ ì˜¤ë¥˜ ì´ìŠˆì— ê°•í•œ íƒ€ì… ê²€ì‚¬ë¥¼ ì ìš©í•œë‹¤. ì»´íŒŒì¼íƒ€ì„ì— ì—ëŸ¬ë¥¼ ê³ ì¹˜ëŠ” ê²ƒì€ ëŸ°íƒ€ì„ ì—ëŸ¬ë¥¼ ê³ ì¹˜ëŠ” ê²ƒ ë³´ë‹¤ ì‰½ë‹¤.&lt;br /&gt;
&lt;code&gt;A Java compiler applies strong type checking to generic code and issues errors if the code violates type safety. Fixing compile-time errors is easier than fixing runtime errors, which can be difficult to find.&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Elimination of casts. &lt;br/&gt;
generics ì—†ì´ ìºìŠ¤íŒ…ì´ í•„ìš”í•œ ì½”ë“œ ì¡°ê°ì…ë‹ˆë‹¤.
&lt;code&gt;The following code snippet without generics requires casting:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List list = new ArrayList();
list.add(&amp;quot;hello&amp;quot;);
String s = (String) list.get(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;genericsë¥¼ ì‚¬ìš©í•´ì„œ ì½”ë“œë¥¼ ë‹¤ì‹œ ì‘ì„±í•˜ë©´, ì½”ë“œëŠ” ë”ì´ìƒ ìºìŠ¤íŒ…ì´ í•„ìš” ì—†ì–´ì§‘ë‹ˆë‹¤.
&lt;code&gt;When re-written to use generics, the code does not require casting:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
list.add(&amp;quot;hello&amp;quot;);
String s = list.get(0);   // no cast
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;í”„ë¡œê·¸ë˜ë¨¸ë“¤ì´ ì¼ë°˜ì ì¸ ì•Œê³ ë¦¬ì¦˜ì„ êµ¬í˜„í•˜ë„ë¡ ì§€ì›í•œë‹¤.&lt;br&gt;
genericsë¥¼ ì‚¬ìš©í•˜ë©´ì„œ í”„ë¡œê·¸ë˜ë¨¸ë“¤ì€ ë‹¤ì–‘í•œ íƒ€ì…ë“¤ì˜ ì½œë ‰ì…˜ì—ì„œ ë™ì‘í•˜ê³ , ìˆ˜ì •ê°€ëŠ¥í•˜ë©°, ë” ì•ˆì •ì ì´ê³  ì½ê¸° ì‰¬ìš´ ì½”ë“œë¥¼ ì¼ë°˜ì ì¸ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Enabling programmers to implement generic algorithms.
By using generics, programmers can implement generic algorithms that work on collections of different types, can be customized, and are type safe and easier to read.&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>java generics ë²ˆì—­ 1</title>
      <link>http://durtchrt.github.io/blog/java/generics/1/</link>
      <pubDate>Mon, 31 Oct 2016 15:07:44 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/java/generics/1/</guid>
      <description>

&lt;h1 id=&#34;ìë°”-ì œë„¥ë¦­ìŠ¤-java-generics-1&#34;&gt;ìë°” ì œë„¥ë¦­ìŠ¤ - Java Generics 1&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/generics/index.html&#34;&gt;ì›ë³¸&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-java-tutorials&#34;&gt;The Java Tutorials&lt;/h2&gt;

&lt;h3 id=&#34;lesson-generics-updated&#34;&gt;Lesson: Generics(Updated)&lt;/h3&gt;

&lt;p&gt;ì†Œí”„íŠ¸ì›¨ì–´ì—ì„œ ë²„ê·¸ëŠ” ì¼ìƒì´ë‹¤. &lt;del&gt;ëª¨ë“  ì‚¬ì†Œí•˜ì§€ ì•Šì€ ì†Œí”„íŠ¸ì›¨ì–´ í”„ë¡œì íŠ¸ì—ì„œ ë²„ê·¸ëŠ” ì‚¶ì˜ ì§„ì‹¤ì´ë‹¤.&lt;/del&gt; ì£¼ì˜ê¹Šê²Œ ê³„íš, í”„ë¡œê·¸ë˜ë°, í…ŒìŠ¤íŠ¸ëŠ” ë²„ê·¸ê°€ ìŠ¤ë©°ë“œëŠ”ê²ƒì„ ì¤„ì—¬ì¤€ë‹¤. í•˜ì§€ë§Œ ì—¬ì°Œëë“ , ì–¸ì  ê°€! ë²„ê·¸ëŠ” ì½”ë“œì—ì„œ ê¸°ì–´ë‹¤ë‹ ë°©ë²•ì„ í•­ìƒ ì°¾ëŠ”ë‹¤. ì´ëŠ” ê²°êµ­ ìƒˆë¡œìš´ ê¸°ëŠ¥ì´ ë„ì…ë˜ê±°ë‚˜ ì½”ë“œ ì‚¬ì´ì¦ˆì™€ ë³µì¡ì„­ì´ ì¦ê°€ë¨ì— ë”°ë¼ ì‹¬ê°í•˜ê²Œ ëˆˆì— ë„ê²Œ ë  ê²ƒì´ë‹¤.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;In any nontrivial software project, bugs are simply a fact of life. Careful planning, programming, and testing can help reduce their pervasiveness, but somehow, somewhere, they&#39;ll always find a way to creep into your code. This becomes especially apparent as new features are introduced and your code base grows in size and complexity.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ìš´ì¢‹ê²Œ ëª‡ëª‡ ë²„ê·¸ëŠ” ì°¾ê¸° ì‰½ë‹¤. ì˜ˆë¥¼ë“¤ì–´, ì»´íŒŒì¼ íƒ€ì„ ë²„ê·¸ëŠ” ì´ˆê¸°ì— ì°¾ì„ ìˆ˜ ìˆë‹¤. ì»´íŒŒì¼ëŸ¬ì˜ ì—ëŸ¬ ë©”ì„¸ì§€ë¥¼ ì´ìš©í•˜ì—¬ ë¬¸ì œì ì„ ë°œê²¬í•˜ê³  ë°”ë¡œ ê±°ê¸°ì„œ ê³ ì¹ ìˆ˜ ìˆë‹¤. ë°˜ë©´ì— ëŸ°íƒ€ì„ ë²„ê·¸ëŠ” í›¨ì”¬ ë” í•´ê²°ì´ ì–´ë µë‹¤. ëŸ°íƒ€ì„ ë²„ê·¸ëŠ” ê²‰ìœ¼ë¡œ ì§ì ‘ ë‚˜íƒ€ë‚˜ì§€ ì•Šìœ¼ë©°, ë²„ê·¸ê°€ ë™ì‘í•  ë•Œ, ê·¸ê²ƒì€ í”„ë¡œê·¸ë¨ì—ì„œ ì‹¤ì œ ë¬¸ì œì˜ ì›ì¸ì—ì„œ ë©€ë¦¬ ë–¨ì–´ì§„ ì§€ì ì— ìˆì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Fortunately, some bugs are easier to detect than others. Compile-time bugs, for example, can be detected early on; you can use the compiler&#39;s error messages to figure out what the problem is and fix it, right then and there. Runtime bugs, however, can be much more problematic; they don&#39;t always surface immediately, and when they do, it may be at a point in the program that is far removed from the actual cause of the problem.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;GenericsëŠ” ì»´íŒŒì¼ íƒ€ì„ì— ë²„ê·¸ë¥¼ ì°¾ì„ìˆ˜ ìˆê²Œë˜ì–´ ì½”ë“œì— ì•ˆì •ì„±ì„ ë”í•©ë‹ˆë‹¤. ì´ ê³¼ì •ì„ ë§ˆì¹œí›„ì—ëŠ” Gilad Brachaì˜ Generics íŠœí† ë¦¬ì–¼ì„ ì§„í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Generics add stability to your code by making more of your bugs detectable at compile time. After completing this lesson, you may want to follow up with the Generics tutorial by Gilad Bracha.&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>