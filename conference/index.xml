<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Conference-rsses on 개발 저장소</title>
    <link>http://durtchrt.github.io/blog/conference/index.xml</link>
    <description>Recent content in Conference-rsses on 개발 저장소</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>durtchrt</copyright>
    <lastBuildDate>Wed, 21 Dec 2016 19:10:41 +0900</lastBuildDate>
    <atom:link href="http://durtchrt.github.io/blog/conference/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>컨퍼런스 후기:20161221 AKKA</title>
      <link>http://durtchrt.github.io/blog/conference/20161221/akka/</link>
      <pubDate>Wed, 21 Dec 2016 19:10:41 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/conference/20161221/akka/</guid>
      <description>

&lt;p&gt;Open Community의 정기기술 세미나 75차 발표 - Akka를 이용한 리엑티브 프로그래밍 101&lt;/p&gt;

&lt;p&gt;발표자- 고재도&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/jeado/akka101&#34;&gt;github&lt;/a&gt;, &lt;a href=&#34;http://open.egovframe.go.kr/cop/bbs/selectBoardArticle.do?bbsId=BBSMSTR_000000000014&amp;amp;nttId=18918&#34;&gt;opencommunity 공지&lt;/a&gt;, &lt;a href=&#34;../pdf.pdf&#34;&gt;발표자료&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;akka&#34;&gt;AKKA&lt;/h1&gt;

&lt;h4 id=&#34;reactive란&#34;&gt;Reactive란?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;유저액션에 즉각적인 빠른 응답&lt;/li&gt;
&lt;li&gt;데이터 바인딩 선언적(절차지향과 반대)&lt;/li&gt;
&lt;li&gt;리액티브 스트림은 비동기적인 데이터 스트림&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.reactivemanifesto.org/&#34;&gt;리액티브 선언&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;reative-선언&#34;&gt;Reative 선언&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;민감성(Responsive) -&amp;gt;  낮은 대기 시간&lt;/li&gt;
&lt;li&gt;유연성(Resilient) -&amp;gt; 실패 탐색기로부터 장애상황시 즉각적으로 버팀.&lt;/li&gt;
&lt;li&gt;신축성(Elastic) -&amp;gt; 클러스터 + 샤딩으로부터 스케일 up/out&lt;/li&gt;
&lt;li&gt;메세지주도(Message-Driven) -&amp;gt; 액터 + 스트림을 통해 콤포넌트들간의 비동기 커뮤니케이션&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://www.zdnet.co.kr/column/column_view.asp?artice_id=20161010104628&#34;&gt;참고 - ZD넷 - 임백준 - 리액티브 개발 패러다임에 담긴 메시지&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;실무에-사용되는-회사&#34;&gt;실무에 사용되는 회사&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;../1.png&#34; alt=&#34;회사&#34; /&gt;&lt;/p&gt;

&lt;p&gt;paypal - 우리는 Akka로 148,000,000명이 넘는 사람들에게 미래의 돈을 전달하고 있습니다.&lt;/p&gt;

&lt;h4 id=&#34;akka-소개&#34;&gt;Akka 소개&lt;/h4&gt;

&lt;p&gt;아카는 Java와 스칼라를 둘다 지원하고 JVM 기반에서 병렬성, 신축성, 유연성을 처리하기위해 actor 기반의 메세지 주도 런타임과 툴킷입니다.(framework는 아닙니다. 기존 코드에 유틸리티 코드처럼 쉽게 추가할 수 있습니다.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Akka is an actor-based message-driven runtime and toolkit for managing concurrency, elasticity and resilence on the JVM with support for both Java and Scala
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;간단하게 강력한 병렬성과 분산 어플리케이션을 만들수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;akka-1&#34;&gt;AKKA&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Actors - 간단하고 높은 성능의 병행처리&lt;/li&gt;
&lt;li&gt;Cluster / Remoting - 지역 투명성, 유연성&lt;/li&gt;
&lt;li&gt;Cluster Sharding - remote시에 자동으로 처리되는 것.&lt;/li&gt;
&lt;li&gt;Streams - 스트림 back-pressured&lt;/li&gt;
&lt;li&gt;Persistence - 이벤트 sourcing&lt;/li&gt;
&lt;li&gt;HTTP - 카프카, 카산드라, DynamoDB와 통합된 완벽하게 비동기적이고 리액티브한  HTTP Server&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://doc.akka.io/docs/akka/snapshot/intro/what-is-akka.html&#34;&gt;akka doc - what is akka&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Actors
- Simple and high-level abstractions for distribution, concurrency and parallelism.
- Asynchronous, non-blocking and highly performant message-driven programming model.
- Very lightweight event-driven processes (several million actors per GB of heap memory).

Fault Tolerance
- Supervisor hierarchies with &amp;quot;let-it-crash&amp;quot; semantics.
- Actor systems can span over multiple JVMs to provide truly fault-tolerant systems.
- Excellent for writing highly fault-tolerant systems that self-heal and never stop.

Location Transparency
- Everything in Akka is designed to work in a distributed environment: all interactions of actors use pure message passing and everything is asynchronous.

Persistence
- State changes experienced by an actor can optionally be persisted and replayed when the actor is started or restarted. This allows actors to recover their state, even after JVM crashes or when being migrated to another node.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;actor&#34;&gt;Actor&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://doc.akka.io/docs/akka/snapshot/general/actors.html&#34;&gt;akka doc - actor&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;actor-model-frameworks-languages&#34;&gt;Actor Model Frameworks / Languages&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Erlang / Elixer&lt;/li&gt;
&lt;li&gt;Akka(JVM/Akka.ent)&lt;/li&gt;
&lt;li&gt;Orleans(.NET)&lt;/li&gt;
&lt;li&gt;CAF(C++)&lt;/li&gt;
&lt;li&gt;Celluloid(Ruby)&lt;/li&gt;
&lt;li&gt;Pulsar(Python)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1973 Actor모델 이론 발표  -&amp;gt; 1986 Erlang이 Actor모델 적용 -&amp;gt; 2009 jvm scala akka 탄생&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Actor model은 컴퓨터 과학에서 행위자를 형행 연산의 기본적 기본 단위로 취급하는 병행 컴퓨팅의 수학적 모델이다. 행위자가 받는 메시지에 댕으하여, 행위자는 자체적인 결정을 하고 더 많은 행위자를 만들며, 더 많은 메시지를 보내고, 다음에 받을 메시지에 대한 응답 행위를 결정할 수 있다. 행위자는 개인 상태를 수정할 수 있지만, 메시지를 통해서만 서로에게 영향을 줄 수 있다.(락의 필요성을 제거함.)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;액터는 병행처리 원시 기술. -&amp;gt; Thread 대신 Actor로 병행처리 지원&lt;/p&gt;

&lt;h4 id=&#34;actor-1&#34;&gt;Actor&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;concurrency primitive&lt;/li&gt;
&lt;li&gt;persistent&lt;/li&gt;
&lt;li&gt;encapsulate internal state&lt;/li&gt;
&lt;li&gt;actors interact exclusively via asychronous messages&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;actor가-할-수-있는것&#34;&gt;Actor가 할 수 있는것.&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Actor sends messages&lt;/li&gt;
&lt;li&gt;Actor change its state&lt;/li&gt;
&lt;li&gt;Actor change its behavior&lt;/li&gt;
&lt;li&gt;Actor create more actors&lt;/li&gt;
&lt;li&gt;Actor process exactly one message at a time&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;actor-구조&#34;&gt;actor 구조&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;../2.png&#34; alt=&#34;Akka Actor&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;akka-actor-path&#34;&gt;Akka Actor Path&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;../3.png&#34; alt=&#34;akka path&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;액터 identifies&lt;/li&gt;
&lt;li&gt;액터를 가리키는 proxy / forwarder를 표현할 수 있다.&lt;/li&gt;
&lt;li&gt;Contains location and transport information&lt;/li&gt;
&lt;li&gt;지역 투명성

&lt;ul&gt;
&lt;li&gt;하나의 path는 많은 actor를 표현할 수 있다.(router pool)&lt;/li&gt;
&lt;li&gt;하나의 actor는 많은 주소를 가질 수 있다.(cluster)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;supervision&#34;&gt;supervision&lt;/h4&gt;

&lt;p&gt;액터의 동작 상태는 다른 액터에게 감시되고 관리되어진다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The running state of an actor is monitored and managed by another actor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;let it crash -&amp;gt; supervision after crash&lt;/p&gt;

&lt;h4 id=&#34;akka-actor-hierachy&#34;&gt;Akka Actor Hierachy&lt;/h4&gt;

&lt;!-- TODO 이미지 참조 --&gt;

&lt;p&gt;parent actor는 child actor를 supervision할 수 있어서 child의 상태를 받아볼 수 있고 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../4.png&#34; alt=&#34;akka actor hierarchy&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://doc.akka.io/docs/akka/current/general/addressing.html&#34;&gt;참조 - Actor References, Paths and Addresses &lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;demo&#34;&gt;Demo&lt;/h4&gt;

&lt;p&gt;CO2 Monitoring Device -&amp;gt; Akka baseed Rule Engine System&lt;/p&gt;

&lt;h2 id=&#34;scale-up-with-router&#34;&gt;Scale up with router&lt;/h2&gt;

&lt;h4 id=&#34;routers&#34;&gt;Routers&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;pool - the router creates routees as child actors and removes them from the router if they terminate&lt;/li&gt;
&lt;li&gt;group - the routee actors are created externally to ther router and the router sends messages to the specified path using actor selection, without watching for termination.
a pool needs the number of routee instances, and a group needs a list of routee paths.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../5.png&#34; alt=&#34;router&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;routers-1&#34;&gt;Routers&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;akka.actor.deployment {
	/parent/router1 {
		router = round-robin-pool
		nr-of-instances = 5
	}
}

val poolRouter: ActorRef = 
	context.actorOf(FromConfig.props(Props[Worker]), &amp;quot;router1&amp;quot;)

val router2: ActorRef = 
	context.actorOf(RoundRobinBool(5).props(Props[Workder]), &amp;quot;router2&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;routers-2&#34;&gt;Routers&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;akka.actor.deployment {
	/parent/router3 {
		router = round-robin-group
		routees.paths = [&amp;quot;/user/workers/w1&amp;quot;, &amp;quot;/user/workers/w2&amp;quot;, &amp;quot;/user/workers/w3&amp;quot;]
	}
}

val pool: ActorRef = 
	context.actorOf(FromConfig.props(), &amp;quot;router3&amp;quot;)

val router2: ActorRef = 
	context.actorOf(RoundRobinBool(paths).props), &amp;quot;router4&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;routing-logic&#34;&gt;Routing Logic&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;RoundRobinPool and RoundRobinGroup&lt;/li&gt;
&lt;li&gt;RandomPool and RandomGroup&lt;/li&gt;
&lt;li&gt;BalancingPool&lt;/li&gt;
&lt;li&gt;SmallestMailboxPool&lt;/li&gt;
&lt;li&gt;BroadcastPool and BroadcastGroup&lt;/li&gt;
&lt;li&gt;ScatterGatherFirstCompletedPool and ScatterGatherFirstCompletedGroup&lt;/li&gt;
&lt;li&gt;TailChoppingPool and TailChoppingGroup&lt;/li&gt;
&lt;li&gt;ConsistentHashingPool and ConsistentHashingGroup&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;demo-1&#34;&gt;DEMO&lt;/h4&gt;

&lt;h2 id=&#34;akka-cluster&#34;&gt;Akka Cluster&lt;/h2&gt;

&lt;h4 id=&#34;akka-cluster-1&#34;&gt;Akka Cluster&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;../6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;akka-cluster-membership&#34;&gt;Akka Cluster Membership&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;../7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;akka-cluster-joining-the-cluster&#34;&gt;Akka Cluster Joining the cluster&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;../8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;akka-cluster-leaving-and-exiting&#34;&gt;Akka Cluster Leaving and Exiting&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;../9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;demo-2&#34;&gt;DEMO&lt;/h4&gt;

&lt;h4 id=&#34;akka-in-ligthbend&#34;&gt;akka in ligthbend&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;../10.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;auto downing은 production에 사용하지 말라고함 -_-?&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://doc.akka.io/docs/akka/snapshot/scala/cluster-usage.html&#34;&gt;http://doc.akka.io/docs/akka/snapshot/scala/cluster-usage.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;anti-use-case&#34;&gt;anti use case&lt;/h4&gt;

&lt;p&gt;actor 안에서 future를 쓸 때 sender가 꼬이는 문제가 있으니 조심.
&lt;a href=&#34;http://stackoverflow.com/questions/16898131/sender-inside-a-future&#34;&gt;http://stackoverflow.com/questions/16898131/sender-inside-a-future&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title> 20161125 나는 프로그래머다 컨퍼런스</title>
      <link>http://durtchrt.github.io/blog/conference/20161125/1/</link>
      <pubDate>Fri, 25 Nov 2016 14:08:04 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/conference/20161125/1/</guid>
      <description>

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;발표 후기 1&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;functional-programming-그게-뭐죠&#34;&gt;Functional Programming 그게 뭐죠?&lt;/h1&gt;

&lt;h4 id=&#34;함수&#34;&gt;함수&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;절차지향

&lt;ul&gt;
&lt;li&gt;subroutin&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;functional

&lt;ul&gt;
&lt;li&gt;수학에서 말하는 함수&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;why-functional-programming&#34;&gt;Why? Functional Programming&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;동시성
무어의 법칙이 깨진후
CPU제조업체가 멀티 코어 성능 향상을 꾀함.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;간결
expression의 조합
고민해야할 문제가 하나로 줄어듬.
oop의 단일책임원칙이 자연스럽게 적용됨.
동일 입력값이 동일 출력값으로&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;테스트
값을 직접입력하지 않아도 테스트 프레임워크가 자동으로 생성도 가능&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;재미!!!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;과거 함수형 프로그래밍 언어는 느려서 못썼는데 요새는 속도가 빠름.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;맛보기&#34;&gt;맛보기&lt;/h4&gt;

&lt;p&gt;haskel 샘플&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskel&#34;&gt;let add :: Int -&amp;gt; Int -&amp;gt; Int
add a b = a + b

add 1 2
=&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;let add // 함수 선언
Int -&amp;gt;Int -&amp;gt; Int  // Int 파라메터 -&amp;gt; Int 파라메터 -&amp;gt; Int 리턴
add a b // add 함수는 a, b  두 파라메터를 받음(Int, Int)
add a b = a + b // a + b 동작 함수를  add에 할당.&lt;/p&gt;

&lt;p&gt;함수형언어들은 함수 우선권을 가짐
add 2 5 * 3
=&amp;gt; 21
add 2 (5 * 3)이 아니라 (add 2 5) *3으로 평가함.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;1.toString()
==&amp;gt; error
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;1.toString
==&amp;gt; &amp;quot;1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자바에서의 1은 기본형(primitive type)
scala에서의 1은 객체(object)   =&amp;gt; &lt;code&gt;PURE&lt;/code&gt; object oriented programming language&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Full-blown
Functional Language
=&amp;gt; 순수 함수형 언어가 아닌 함수형 프로그래밍하기에 적합한 언어를 지칭
=&amp;gt; 스칼라가 이 범위에 있음.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;호주 이민은 스칼라&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;kevin github -&amp;gt;
functional transaction without aop(비공개인듯 안보임)
aop를 사용하지 않고 transaction을 처리한 예제를 케빈 github에 공유하였다고함.&lt;/p&gt;

&lt;h2 id=&#34;br-br-br-br-br&#34;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;발표 후기 2&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;machine-intelligence-at-google-service&#34;&gt;Machine Intelligence at Google Service&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;영어 발표&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;what-is-neural-network-and-deep-learning&#34;&gt;What is Neural Network and Deep Learning&lt;/h4&gt;

&lt;p&gt;Neural network is a functio that can learn
-&amp;gt; 고양이의 이미지를 분석해서 레이블을 만듬.
-&amp;gt; 이러한 기술을 게임서버에서 로그를 분석해서 악성행위 분석 가능&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../1.png&#34; alt=&#34;spiral&#34; /&gt;&lt;/p&gt;

&lt;p&gt;나선 이미지를 보면 오렌지, 블루 색상을 사람은 쉽게 알 수 있음&lt;/p&gt;

&lt;p&gt;하지만 컴퓨터는&amp;hellip;
점마다 위치정보를 if-else하는 프로그래밍은 괴로움.
-&amp;gt; 이러한 문제를 해결하기 위해 ML사용&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://playground.tensorflow.org/#activation=tanh&amp;amp;batchSize=10&amp;amp;dataset=spiral&amp;amp;regDataset=reg-plane&amp;amp;learningRate=0.03&amp;amp;regularizationRate=0&amp;amp;noise=0&amp;amp;networkShape=4,2&amp;amp;seed=0.82086&amp;amp;showTestData=false&amp;amp;discretize=false&amp;amp;percTrainData=50&amp;amp;x=true&amp;amp;y=true&amp;amp;xTimesY=false&amp;amp;xSquared=false&amp;amp;ySquared=false&amp;amp;cosX=false&amp;amp;sinX=false&amp;amp;cosY=false&amp;amp;sinY=false&amp;amp;collectStats=false&amp;amp;problem=classification&amp;amp;initZero=false&amp;amp;hideText=false&#34;&gt;Neural network traning play ground&lt;/a&gt; - site sample&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;site에서 패턴인식하는게 실시간으로 나와서 파란색과 오렌지색을 인식하는것을 볼 수 있음&lt;/li&gt;
&lt;li&gt;더 많은 데이터와 더 많은 샘플을 주면 더 빠르고 더 정확하게 데이터를 학습함.&lt;/li&gt;
&lt;li&gt;한레이어에서 나오는 아웃풋을 그 다음 레이어의 인풋으로 제공해서 더 스마트헤거 됨.&lt;/li&gt;
&lt;li&gt;각각의 레이어는 단순하지만 이 것들이 통합하면서 스마트한 뉴런네트워크가 됨.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 사람이 이미지를 어떻게 인식하라고 알려주지 않아도 알아서 하는 것이 중요&lt;br&gt;
=&amp;gt; AI, AlphaGo가 이세돌을 이길수 있었던것.
=&amp;gt; 컴퓨터가 스스로 방법을 찾아내기 때문에 사람보다 뛰어난 방법을 찾아낼 수 있는 것.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.petdrugsonline.co.uk/images/page-headers/cats-master-header&#34; alt=&#34;cat&#34; /&gt;&lt;/p&gt;

&lt;p&gt;고양이 인식&lt;br&gt;
=&amp;gt; 고양이를 인식하기 위해 50개 이상의 레이어가 생성되고, 각각의 레이어(뉴런)은 단순 하지만 모이면 스마트해지면서 컴퓨터가 이미지상에서 고양이를 판별할 수 있게됨.&lt;/p&gt;

&lt;h4 id=&#34;machine-learning-use-cases-at-google-services&#34;&gt;machine learning use cases at google services&lt;/h4&gt;

&lt;p&gt;구글 검색을 통해 이를 사용하고 있음
최근에 구글은 랭크브레인이라는 서비스를 내놓음
Image를 컨텐츠에 따라 구분하는 google photo
gmail - smart reply in box mobile - 이메일을 자동으로 전송.
google translate with neural machine translation
data center - energy save
More&amp;hellip;. 60개 이상의 프로덕트에 사용&lt;/p&gt;

&lt;h4 id=&#34;externalizing-the-power-of-ml&#34;&gt;externalizing the power of ML&lt;/h4&gt;

&lt;p&gt;ML api는 머신러닝과 상관없는 개발자가 사용하도록 제공하려함.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CoudVision API
이미 트레이닝된 모델을 제공하기 때문에 이미지가 인풋되면 바로 결과가 나옴.
8만개 이상의 이미지를 이용해서 서비스를 사용.
사진을 주면 다양한 레이블 정보를 줌 (0_0 데모 우와~~)&lt;/li&gt;
&lt;li&gt;WebSpeech Api
google.com/speech&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;tensorflow-the-open-source-library-for-ml&#34;&gt;tensorFlow: the open source library for ML&lt;/h4&gt;

&lt;p&gt;자신의 뉴럴네트워크를 구축하고 싶을때 사용하는 오픈소스
Portable and Scalable&lt;/p&gt;

&lt;h4 id=&#34;tensorflow-in-the-wild&#34;&gt;tensorFlow in the wild&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;일본의 예를 보여줌.
어머니는 오이를 하루 8시간씩 골라내는 일을 함.
스스로 텐서플로우로 오이 분류기를 만듬.
embedded software 개발자로 머신러닝을 모르는 사람이지만 함!!!
현재 70%의 정확성으로 오이를 9개의 등급으로 나눌수 있다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;치킨너겟을 서빙하는 로봇 팔.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;드론으로 트럭의 갯수를 세는 것.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;distributed-training-and-prediction-in-computing-power&#34;&gt;Distributed training and prediction in Computing power(?)&lt;/h4&gt;

&lt;p&gt;컴퓨터 파워가 엄청 필요함.
GPU가 있어도 몇주가 걸리기도 함.&lt;/p&gt;

&lt;p&gt;구글 클라우드가 수십만개의 GPU 클러스터를 가짐.&lt;/p&gt;

&lt;p&gt;jupitor network
tensor processiong unit&lt;/p&gt;

&lt;p&gt;=&amp;gt; 40배 ~ 300배 성능 향상 가능&lt;/p&gt;

&lt;h2 id=&#34;br-br-br-br-br-1&#34;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;발표 후기 3&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;스칼라로-웹사이트-개발하기&#34;&gt;스칼라로 웹사이트 개발하기&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;라스칼라코딩단, 최정열 &amp;amp; 케빈리&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 라이브 코딩(작성 못함. T-T)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;나프다 동영상 참조. 시연신이 나오셔서 방해를 엄청하심;;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;br-br-br-br-br-2&#34;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;발표 후기 4&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;ms는-rx를-왜-만들었을까-feat-rxjs&#34;&gt;MS는 Rx를 왜 만들었을까?  feat. RxJS&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;네이버, 김훈민&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://huns.me/development/2051&#34;&gt;발표자가 발표 주제로 포스팅한 글&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;rx는-어디에서-왔을까&#34;&gt;Rx는 어디에서 왔을까?&lt;/h4&gt;

&lt;p&gt;volta project에서 시작
-&amp;gt; live labs 다양한 기술을 하나의 플랫폼에서 실행 GWT과 비슷하지만 많은 플랫폼과 대응하는게 목적.
-&amp;gt; volta 프로젝트는 좌초됨.&lt;/p&gt;

&lt;p&gt;volta =&amp;gt; Reactive Framework를 가져와서 =&amp;gt; .Net의 Reactive Extenstion&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2009.11.17
Rx.NET 릴리즈&lt;/li&gt;
&lt;li&gt;2010.03.17
RxJS&lt;/li&gt;
&lt;li&gt;2012.11.06
오픈소스 공개
Rx.NET, RxJS, Rx++&lt;/li&gt;
&lt;li&gt;2013.02.05
RxJava by Netflix&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://www.reactivemanifesto.org&#34;&gt;리액트 선언 - Reative Manifesto&lt;/a&gt;
&lt;img src=&#34;http://www.reactivemanifesto.org/images/reactive-traits.svg&#34; alt=&#34;설명&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-rx를-지탱하는-키워드&#34;&gt;2 Rx를 지탱하는 키워드&lt;/h4&gt;

&lt;p&gt;Reactive Programming
데이터 플로우와 상태 변경을 전파한다는 생각에 근간을 둔 프로그래밍 패러다임.&lt;/p&gt;

&lt;p&gt;1985 - on the development of reactive systems
=&amp;gt; 논문에 reactive란 용어 시초라고 봄.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;반응
자극은 밖에서 안으로 흐름
자극이 있어야만 반응하는 수동성&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://huns.me/wp/wp-content/uploads/2016/09/reactive-eric.png&#34; alt=&#34;참조이미지&#34; /&gt;&lt;/p&gt;

&lt;p&gt;iterator pattern - pull
observalbe pattern - push&lt;/p&gt;

&lt;p&gt;iterator - observable 쌍대 관계에 있다.
-&amp;gt; slide의 설명문을 보면  @_@
=&amp;gt; A와 B의 본질이 같다.&lt;/p&gt;

&lt;p&gt;메서드표 자료 참조&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;LINQ to Events
이벤트와  LINQ의 개념을 결합한 오퍼레이터(Operator) 제공
Language Intergrated Query
에릭마이어가 만든 통합 질의 언어 C# 3.0부터 등장 데이터 질의 문법 설탕
두가지 스타일을 지원&lt;/li&gt;
&lt;li&gt;Query syntax&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Method syntax&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Scheduler
비동기 환경에서 오퍼레이터 실행 시점 제어&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;rp와-frp의-경계에서&#34;&gt;RP와 FRP의 경계에서&lt;/h4&gt;

&lt;p&gt;RP != FRP&lt;/p&gt;

&lt;p&gt;FRAN(Functional Reactive Animaton)1997 - 표현과 모델링의 분리 -&amp;gt;  시간에 따라 변하는 값을 표현(Behavior)
-&amp;gt; 함수형 리액티브 프로그래밍의 시작&lt;/p&gt;

&lt;p&gt;Evan Czaplicki - Elm만든 사람.
Controlling Time and Space -&amp;gt; FRP 다양한 변종들 설명.&lt;/p&gt;

&lt;p&gt;FRP 번위를 간단히 좁히면 (FRAN 논문 저자 왈)
1. denotational : 연속하는 시간에 따라 변하는 값이 1급 시민으로 표현되어야함.
2. countinuous-time&lt;/p&gt;

&lt;p&gt;개념적인 FRAN, 실질적인 Rx불연속값 처리 스트림 결합시 일괁성 없는 동시 이벤트 처리 발생
단점 -&amp;gt; 구성성 결여&lt;/p&gt;

&lt;p&gt;rx는 순간 불일치(glitch) 생김 =&amp;gt; 진정한 FRP 구현체라고 보기 힘들어함.&lt;/p&gt;

&lt;p&gt;제대로된 reactive를 보고 싶으면 &amp;lsquo;reactive-banana&amp;rsquo; 라이브러리 참조.
=&amp;gt; FRP 설명을 하스켈로 설명.&lt;/p&gt;

&lt;h4 id=&#34;웹프론트엔드-그리고-rxjs&#34;&gt;웹프론트엔드, 그리고  RxJS&lt;/h4&gt;

&lt;p&gt;뷰와 상태의 동기화 문제를 프레임워크마다 푸는 방식
backborn - KVO(key-value observing) =&amp;gt; 데이터 변경 체크 까지만 프레임워크 뷰의 상태 변화는 개발자가(MVC)
angular - 양방향 databinding =&amp;gt; 속도 문제 발생
reactjs - virtual dom - 상대가 변경되면 뷰가 바낌.
flux - react는 view만 담당. 순수 함수 조합 단방향 데이터 플로우
MVI(Model-view-intent) 순환 스트림 설계 함수형 프로그래밍.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reactive&lt;/li&gt;
&lt;li&gt;Functinal&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;rx는-fe-개발자에게-좋은-자극제&#34;&gt;Rx는 FE 개발자에게 좋은 자극제&lt;/h4&gt;

&lt;p&gt;Elm에서 영감을 얻은 Redux, Cycle.js
다른 진영 또는 클래식한 기술에서 새로운 통찰을 경험.&lt;/p&gt;

&lt;h2 id=&#34;br-br-br-br-br-br-br&#34;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;발표 후기 5&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;스타트업-1인-개발-극복기-와-javascript-vs-scala-함수형-언어-관점으로-방황기&#34;&gt;&amp;lsquo;스타트업 1인 개발 극복기&amp;rsquo;와 &amp;lsquo;javascript vs Scala, (함수형 언어 관점으로)방황기&amp;rsquo;&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;I/O Inc, 박미정&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;왜-함수형-언어&#34;&gt;왜 함수형 언어?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;개인

&lt;ul&gt;
&lt;li&gt;성장욕구&lt;/li&gt;
&lt;li&gt;높은 추상화&lt;/li&gt;
&lt;li&gt;코드 신뢰성&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;회사

&lt;ul&gt;
&lt;li&gt;시간적 여유&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;lsquo;코드 신뢰성&amp;rsquo; -&amp;gt; 적은 코드가 적은 버그를 만들어낸다.&lt;/p&gt;

&lt;h4 id=&#34;어떻게-팀에-도입을&#34;&gt;어떻게 팀에 도입을?&lt;/h4&gt;

&lt;p&gt;매주 sw 세미나 -&amp;gt; (관심끌기 성공) -&amp;gt; 함수형 패러다임 도적 -&amp;gt; 프로덕션 적용 시작&lt;/p&gt;

&lt;p&gt;&amp;lsquo;관심끌기 사례&amp;rsquo;
 - &amp;gt; 같은 입력 같은 출력 (사이드이펙트가 없으니) TDD시에 상당히 자연스럽게 연결.&lt;/p&gt;

&lt;h4 id=&#34;어떻게-팀에-도입을-1&#34;&gt;어떻게 팀에 도입을?&lt;/h4&gt;

&lt;p&gt;함수형 언어에 등장하는 &amp;lsquo;특성들&amp;rsquo;을 &amp;lsquo;기존 제품의 서버에 적용&amp;rsquo; 해보고 함수형 패러다임의 &amp;lsquo;매력&amp;rsquo;을 멤버들과 동기화&lt;/p&gt;

&lt;h4 id=&#34;왜-scala&#34;&gt;왜 Scala&lt;/h4&gt;

&lt;p&gt;함수형 프로그래밍 언어 -&amp;gt; side effect 없는 프로그래밍을 지원하고 장려하는 언어&lt;/p&gt;

&lt;p&gt;scala oop+fP 다리역할
  -&amp;gt; 멤버들이 oop에 익숙한 상태에서 fp를 자연스럽게 넘어갈때 !!&lt;/p&gt;

&lt;p&gt;#(2번째 주제) 스타트업 1인 개발 극복기
&lt;a href=&#34;http://www.slideshare.net/ParkMijeong/ss-65069602&#34;&gt;슬라이드참조&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[컨퍼런스 후기- 20161123] playnode2016</title>
      <link>http://durtchrt.github.io/blog/conference/20161123/1/</link>
      <pubDate>Wed, 23 Nov 2016 11:55:37 +0900</pubDate>
      
      <guid>http://durtchrt.github.io/blog/conference/20161123/1/</guid>
      <description>

&lt;p&gt;&lt;code&gt;강연후기 1&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;javascrpt-everywhere-하나의-프로그래밍-언어로-모바일부터-로봇까지&#34;&gt;javascrpt everywhere - 하나의 프로그래밍 언어로 모바일부터 로봇까지&lt;/h1&gt;

&lt;p&gt;#소개
JavaScript Everywhere - 하나의 프로그래밍 언어로 천하통일을 꿈꾸는 메이커&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;JavaScript 와 Node.JS 만으로 IoT 제작/교육 플랫폼을 만들고, 로봇을 위한 임베디드도 Node.JS 로 제작한 사례를 공유합니다.
MongoDB 와 Elasticsearch 채용으로, 모바일 부터 로봇, 그리고 데이터 분석 까지 전 영역에 JavaScript 를 적용함으로써 얻은 교훈을 이야기 합니다.

박종건 | Circulus 대표/수원대학교 조교수

게임을 너무 좋아하여 휴학하고 다음 게임에 입사 하였다가, 직장이 아닌 직업을 찾기위해 IT개발을 위해 삼성SDS 정보기술연구소로 입사, IoT 기반 공급망/물류 시스템및 데이터 시각화 업무를 담당했습니다. 삼성 근무 시 내가 해야할 일은 남들도 누구나 SW+HW 를 이용하여 만들 수 있게 하자는 목적으로, 2013년 Circulus 커뮤니티를 시작, 뜻을 펼치기 위해 2016년 로봇 기반 에듀테크 스타트업 Circulus 를 시작하였습니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;주제&#34;&gt;주제&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;why? nodejs&lt;/li&gt;
&lt;li&gt;how?&lt;/li&gt;
&lt;li&gt;what&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;발표자&#34;&gt;발표자&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;rippertnt@gmail.com&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.circul.us&#34;&gt;http://www.circul.us&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;why-javascript&#34;&gt;Why - Javascript&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;One Language - Multi platform
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;과거
기계어 -&amp;gt; 저급언어 -&amp;gt; 하이레벨
==&amp;gt; 언어의 파편화&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;desktop : C#&lt;/li&gt;
&lt;li&gt;mobile: Object-C&lt;/li&gt;
&lt;li&gt;web: javascripot&lt;/li&gt;
&lt;li&gt;server : java&lt;/li&gt;
&lt;li&gt;embeded : c/c++&lt;/li&gt;
&lt;li&gt;database : sql&lt;/li&gt;

&lt;li&gt;&lt;p&gt;analysis : etc&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://namu.wiki/w/%EB%B0%94%EB%B2%A8%ED%83%91&#34;&gt;바벨탑&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;하나의 언어를 사용하던 시대에서&lt;/li&gt;
&lt;li&gt;바벨탑의 저로 언어가 다양해짐.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;자바스크립크 랭크&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://githut.info/&#34;&gt;github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/research/developer-survey-2016&#34;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;javascript-everywhere&#34;&gt;Javascript everywhere&lt;/h2&gt;

&lt;p&gt;모바일부터 로봇까지 가장 폭넓게 활용할 수 있는 언어&lt;/p&gt;

&lt;h5 id=&#34;개발자-메이커의-시대&#34;&gt;개발자 -&amp;gt; 메이커의 시대&lt;/h5&gt;

&lt;p&gt;기존 sw개발에서, HW + SW 결합하고 아이디어를 개발 SW개발자에서 융복합 메이커로의 진화&lt;/p&gt;

&lt;h5 id=&#34;opensource-hardware&#34;&gt;Opensource Hardware&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;저렴한 마이크로 컨트롤러/컴퓨터의 등장으로 H/W 영역도 실패가 가능해짐.(출시하면 납땜다시하지 않는이상 변경 불가였던 시절이 있었음 - 지금은 H/W rewrite 가능해짐)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kickstarter.com/projects/1598272670/chip-the-worlds-first-9-computer&#34;&gt;CHIP&lt;/a&gt; =&amp;gt; 9$ 컴퓨터&lt;/li&gt;
&lt;li&gt;3D 프린터&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;make-movement&#34;&gt;Make Movement&lt;/h5&gt;

&lt;p&gt;기존의 DIY 영역에서 ICT 기술이 접목.
&lt;a href=&#34;http://makerfaire.com/&#34;&gt;Maker Faire&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;S/W + H/W + Service 결합되어 다양한 아이디어들이 실제로 구현&lt;/p&gt;

&lt;h4 id=&#34;arduino-vs-raspberry-pi&#34;&gt;Arduino vs Raspberry Pi&lt;/h4&gt;

&lt;p&gt;Raspberry pi - microcomputer
(s/w)linux + javascript
(h/w) gpio
==&amp;gt; javascript로 개발하고 gpio와 연결된 외부 디바이스를 제어(ex- 모터, led)&lt;/p&gt;

&lt;h2 id=&#34;circulus&#34;&gt;Circulus&lt;/h2&gt;

&lt;p&gt;=&amp;gt; 발표자 회사 및 서비스 소개 자세한 내용은 슬라이드 참조.&lt;/p&gt;

&lt;h4 id=&#34;program-or-be-programmed&#34;&gt;Program or be programmed&lt;/h4&gt;

&lt;h4 id=&#34;education-making-with-circulus&#34;&gt;Education/Making with circulus&lt;/h4&gt;

&lt;h4 id=&#34;circulus-iot-platform&#34;&gt;Circulus Iot Platform&lt;/h4&gt;

&lt;h4 id=&#34;javascript-in-circulus&#34;&gt;javaScript in Circulus&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Web&lt;/th&gt;
&lt;th&gt;Server&lt;/th&gt;
&lt;th&gt;IoT platform&lt;/th&gt;
&lt;th&gt;Database&lt;/th&gt;
&lt;th&gt;win pc&lt;/th&gt;
&lt;th&gt;mobile&lt;/th&gt;
&lt;th&gt;wearable&lt;/th&gt;
&lt;th&gt;analysis&lt;/th&gt;
&lt;th&gt;embeded&lt;/th&gt;
&lt;th&gt;linux pc&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;javascript&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;mongodb&lt;/td&gt;
&lt;td&gt;nw.js&lt;/td&gt;
&lt;td&gt;cordova&lt;/td&gt;
&lt;td&gt;tizen&lt;/td&gt;
&lt;td&gt;elastic serach&lt;/td&gt;
&lt;td&gt;nodejs&lt;/td&gt;
&lt;td&gt;nw.js&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;how-robotics-intelligent-bot&#34;&gt;How - Robotics (Intelligent Bot)&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 발표자 회사 소개 자료..&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;code&gt;강연후기 2&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;how-the-node-js-event-loop-works&#34;&gt;How the Node.js event loop works&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Node.js프로그래머들은 비동기 I/O와 event loop에 대해 너무나 익숙합니다. 하지만 event loop가 실제 어떻게 작동되는지 아는 사람은 많지 않습니다. node가 Threads를 쓰는지 안쓰는지? Callback은 어디에서 오는지? nextTick을 쓸지 setImmediate을 쓸지? node 저변에는 &amp;quot;libuv&amp;quot;라이브러리가 여러 플랫폼 간의 이 모든 마법을 가능하게 합니다. HTTP 요청 처리 여부, 파일의 읽기나 타이머 처리까지 libuv 가 이 모든 것을 가능하게 합니다. 이 세션에서 libuv아키텍트인 Bert Belder는 event loop의 작동 방식, libuv가 어떻게 비동기화 I/O를 가능하게 하는지, 그리고 당신의 Node.js코드를 최대한 활용할 수 있도록 어떻게 돕는지에 대해 이해하기 쉽게 설명할 것입니다.

Bert Belder | Node.js core developer / Strongloop founder, IBM

Bert Belder는 2011년부터 Node.js 코어 컨트리뷰터로, 가장 오래된 node 메인테이너이자 지금도 활발하게 활동하고 있습니다. 2013년에 Bert는 동료 Ben Noordhuis와 함께 StrongLoop을 설립했습니다. 오픈 소스에는 libuv를 윈도우에 포팅하는 작업을 기점으로 첫 발을 들였으며, 그 이후로 지금까지 node 커뮤니티의 리더로 활동하고 있습니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;how-the-node-js-event-loop-works-1&#34;&gt;How the node.js event loop works&lt;/h1&gt;

&lt;p&gt;=&amp;gt; 사전 지식으로 커널에 대해 알고 있어야 이해가 감.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Bert Belder 
Node.js core developer / Strongloop founder, IBM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://www.google.co.kr/search?q=nodejs+eventloop&amp;amp;espv=2&amp;amp;biw=1246&amp;amp;bih=780&amp;amp;source=lnms&amp;amp;tbm=isch&amp;amp;sa=X&amp;amp;ved=0ahUKEwja-KWEib7QAhWJVLwKHQcICc0Q_AUIBigB&#34;&gt;구글 이미지 검색 node.js event loop&lt;/a&gt;
=&amp;gt; 모두 잘못되었다고 말함;; 임팩트를 줌!!&lt;/p&gt;

&lt;h4 id=&#34;네트워킹-프로그래밍을-할때-최소-3번은-blocking이-생긴다&#34;&gt;네트워킹 프로그래밍을 할때 최소 3번은 blocking이 생긴다.&lt;/h4&gt;

&lt;p&gt;(psedo code로 c 코드를 보여줌)
- I/O 작업시에 블럭킹 발생
    - connect method
    - write method
    - read method&lt;/p&gt;

&lt;p&gt;==&amp;gt; 그러나 컴퓨터 H/W는 비동기임.
==&amp;gt; 보여준 코드는 절차적이면서 스테이트먼트가 끝나려면 응답을 기다리는 blocking 구조임.&lt;/p&gt;

&lt;h4 id=&#34;h-w-비동기-참조-pio-dma&#34;&gt;H/W 비동기 참조 PIO -&amp;gt; DMA&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8_%EC%9E%85%EC%B6%9C%EB%A0%A5&#34;&gt;PIO&lt;/a&gt;
&lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%A7%81%EC%A0%91_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%A0%91%EA%B7%BC&#34;&gt;DMA&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;cpu &amp;ndash; command  &amp;mdash;&amp;gt;
    &amp;lt;&amp;ndash;interrupt  &amp;mdash;  disk &amp;lt;&amp;ndash;data&amp;mdash;&amp;gt; ram&lt;/p&gt;

&lt;h4 id=&#34;nodejs-eventloop&#34;&gt;nodejs eventloop&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;../1.jpg&#34; alt=&#34;설명자료1&#34; /&gt;
&lt;img src=&#34;../2.jpg&#34; alt=&#34;설명자료&#34; /&gt;
&lt;img src=&#34;../3.jpg&#34; alt=&#34;설명자료&#34; /&gt;
&lt;img src=&#34;../4.jpg&#34; alt=&#34;설명자료&#34; /&gt;
&lt;img src=&#34;../5.jpg&#34; alt=&#34;설명자료&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;유니콘-함수-설명&#34;&gt;유니콘 함수 설명.&lt;/h5&gt;

&lt;p&gt;function unicorn {
  //Put the main thread to sleep
  // Wake u when:
  * there ar events ffrom the kernel to process
  * a thread pool thread has completed an operation
  * the next timer goes off&lt;/p&gt;

&lt;p&gt;nonblocking o/s main method
linux - epoll_wait
ios- kevent
windows-GetQueuedCompletionStatusEx()&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h4 id=&#34;non-blocking-i-o&#34;&gt;Non-blocking I/O&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Try an I/O operation(rad, write)&lt;/li&gt;
&lt;li&gt;If it couldn&amp;rsquo;t be done immediately, EAGAIN or EWOULDBLCIK is returned&lt;/li&gt;
&lt;li&gt;Call epoll() / kqueue() to knwo when you should try again&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Overlapped I/O
1. send a command to the kernel(WSARecv, WSASend)
2. Call GetQueuedCompletionStatusEx() later to get the result.&lt;/p&gt;

&lt;h5 id=&#34;node에서-커널관심사&#34;&gt;node에서 커널관심사&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;../6.jpg&#34; alt=&#34;이미지&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;node-loop-tick&#34;&gt;node loop tick(??)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;../7.jpg&#34; alt=&#34;이미지&#34; /&gt;
원래는 nextTick/callback만 있었는데 Resolve/Promise&lt;/p&gt;

&lt;p&gt;발표자 트위터 @scisauresus&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;code&gt;강연후기 3&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;electron을-이용한-모바일-테스트-자동화-소프트웨어-개발&#34;&gt;Electron을 이용한 모바일 테스트 자동화 소프트웨어 개발&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Electron을 이용한 모바일 테스트 자동화 소프트웨어 개발

Node기반의 Electron을 이용하여 모바일 앱 테스트 자동화 소프트웨어 개발 사례를 소개하고, Node가 가진 인프라를(NPM) 프론트-엔드 기술에 접목시켰을 때의 효과와, 달라지는 것은 무엇인지에 대하여 알아보는 시간을 가져봅시다.

경준호 | 알서포트

자바스크립트를 매우 사랑하는 10년차 프론트-엔드 개발자입니다. Firejune이라는 닉으로 활동 중이며, 순수 미술을 전공했고 웹 디자인을 시작으로 IT업계에 발을 들여 놓았다가 안타깝게도 개발자가 되고 말았습니다…
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;agenda&#34;&gt;Agenda&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Test Atutomationwith ATDD&lt;/li&gt;
&lt;li&gt;node based desktop application&lt;/li&gt;
&lt;li&gt;introduction to project psyclone&lt;/li&gt;
&lt;li&gt;test cloud service with psyclone&lt;/li&gt;
&lt;li&gt;QA&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;test-automation-with-atdd&#34;&gt;Test Automation with ATDD&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;ATDD: Acceptance Test Driven Development&amp;rdquo;
수용가능한 테스트 주도 개발&lt;/p&gt;

&lt;p&gt;pullrequest시에 코드만 있고 테스트가 없을때&lt;/p&gt;

&lt;p&gt;Where is Test
정적테스트 -  개발중인 테스트 코드
Dynamic test - 이미 완성된 코드를 테스트할때&lt;/p&gt;

&lt;p&gt;TDD, BDD, ATDD cycle 이미지 참조&lt;/p&gt;

&lt;h3 id=&#34;web-e2e-testing-tools&#34;&gt;Web E2E Testing tools&lt;/h3&gt;

&lt;p&gt;selenium, Webdriver, nemo, nightwatch, protractor webdriverIO, &amp;hellip;.&lt;/p&gt;

&lt;p&gt;CI와 연계하면 좋음&lt;/p&gt;

&lt;h4 id=&#34;selenium&#34;&gt;Selenium&lt;/h4&gt;

&lt;p&gt;Webdriver - selenium이 만든 spec - 브라우저 벤더가 만들어줌. &lt;a href=&#34;https://www.w3.org/TR/webdriver/&#34;&gt;2015 W3C 채택&lt;/a&gt;
Grid
IDE
Remote Controlll&lt;/p&gt;

&lt;p&gt;Testscript -&amp;gt; webdriver client -&amp;gt; remote server -&amp;gt; selenium(?)&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;nightwatch-script&#34;&gt;Nightwatch Script&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://nightwatchjs.org/&#34;&gt;링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;examples/test/googleDemoTest.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  &#39;Demo test Google&#39; : function (client) {
    client
      .url(&#39;http://www.google.com&#39;)
      .waitForElementVisible(&#39;body&#39;, 1000)
      .assert.title(&#39;Google&#39;)
      .assert.visible(&#39;input[type=text]&#39;)
      .setValue(&#39;input[type=text]&#39;, &#39;rembrandt van rijn&#39;)
      .waitForElementVisible(&#39;button[name=btnG]&#39;, 1000)
      .click(&#39;button[name=btnG]&#39;)
      .pause(1000)
      .assert.containsText(&#39;ol#rso li:first-child&#39;,
        &#39;Rembrandt - Wikipedia&#39;)
      .end();
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;./bin/nightwatch -t examples/test/googleDemoTest.js&lt;/p&gt;

&lt;h5 id=&#34;node-based-desktop-application&#34;&gt;Node based Desktop Application&lt;/h5&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sindresorhus/awesome-electron&#34;&gt;Awesome Electron&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;electron-atom-shell&#34;&gt;Electron(Atom-Shell)&lt;/h4&gt;

&lt;p&gt;architecture&lt;/p&gt;

&lt;h4 id=&#34;psyclone&#34;&gt;Psyclone&lt;/h4&gt;

&lt;p&gt;Environments
- React + reduct
- mocha should
- node canvas
- opencv
- pty.js
- highcharts
- fallow W3c&amp;rsquo;s web driver spec
- next generator javascript
- custom npm modules&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/wycats/javascript-decorators&#34;&gt;javascript decorator&lt;/a&gt;
&lt;a href=&#34;https://github.com/a-framework/REMOVE-react-redux-decorators&#34;&gt;react-redux-decorators&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;code&gt;강연후기 4&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;docker-docker-swarm-관리-툴-gorae-project&#34;&gt;Docker, Docker Swarm 관리 툴 Gorae Project&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;React.js, Node.js 로 개발되어진 Docker 관리 도구인 Gorae 프로젝트의 개발 구조와 과정에 대해서 이야기하고 Docker 환경에 친해지고 인사이트를 얻을 수 있는 시간을 마련해보고자 합니다.

Rhio Kim (김양원) | CDNetworks

프론트 엔드 기술을 좋아하고 늘 꾸준한 개발과 연구를 즐겨합니다. Haroopress 와 Haroopad 개발자입니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;gorae&#34;&gt;Gorae&lt;/h4&gt;

&lt;p&gt;hypervisor vs LXC(LinuX Containers)
&lt;img src=&#34;http://blog.jayway.com/wp-content/uploads/2015/03/vm-vs-docker.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;hypervisor - kvm, vmware, hyper-v
LXC - docker &lt;a href=&#34;http://robinsystems.com/blog/linux-containers-comparison-lxc-docker/&#34;&gt;참고&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=UEK-mpfjrMM&amp;amp;feature=youtu.be&#34;&gt;참고동영상&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s Gorae&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Docker GUI tool&lt;/li&gt;
&lt;li&gt;Docker Swarm GUI tool&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;비슷한 docker ochestration tool(도커 컨테이너 관리,  WEB UI)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://kubernetes.io/&#34;&gt;kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/ui/&#34;&gt;kubernetes ui&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Components&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Gorae(ui)&lt;/li&gt;
&lt;li&gt;Gorae-swarm(ui)&lt;/li&gt;
&lt;li&gt;Gorae-server(Backend)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>